# Flattening Metadata Design

## Overview

This document captures the architectural design for extending ApiSchema.json with flattening metadata to support relational database table generation from Ed-Fi resources. This design is part of DMS-830: Design Flattening Metadata Structure.

## Current ApiSchema.json Structure

The existing ApiSchema.json generated by MetaEd follows this hierarchy:

```json
{
  "apiSchemaVersion": "1.0.0",
  "projectSchema": {
    "abstractResources": {...},
    "resourceSchemas": {
      "students": {
        "identityJsonPaths": [...],
        "documentPathsMapping": {...},
        "authorizationPathways": [...],
        "booleanJsonPaths": [...],
        "dateJsonPaths": [...],
        "decimalPropertyValidationInfos": [...],
        "arrayUniquenessConstraints": [...],
        "securableElements": {...},
        "allowIdentityUpdates": false,
        "isDescriptor": false,
        "isSchoolYearEnumeration": false
      }
    }
  }
}
```

## Proposed Flattening Metadata Extension

The design extends each resource schema with a new `flatteningMetadata` property containing a recursive table structure definition.

### Recursive Table Structure

```json
{
  "resourceSchemas": {
    "students": {
      // Existing properties remain unchanged
      "identityJsonPaths": [...],
      "documentPathsMapping": {...},

      // NEW: Flattening metadata extension
      "flatteningMetadata": {
        "table": {
          "baseName": "Student",
          "jsonPath": "$",
          "columns": [...],
          "childTables": [...]
        }
      }
    }
  }
}
```

## Complete Examples

### Example 1: School with Nested Collections (Addresses â†’ Periods)

```json
{
  "schools": {
    "flatteningMetadata": {
      "table": {
        "baseName": "School",
        "jsonPath": "$",
        "columns": [
          {
            "jsonPath": "$.schoolId",
            "columnName": "SchoolId",
            "columnType": "integer",
            "isNaturalKey": true
          },
          {
            "jsonPath": "$.nameOfInstitution",
            "columnName": "NameOfInstitution",
            "columnType": "string",
            "maxLength": "255"
          }
        ],
        "childTables": [
          {
            "baseName": "SchoolAddress",
            "jsonPath": "$.addresses[*]",
            "columns": [
              {
                "columnName": "School_Id",
                "columnType": "bigint",
                "isParentReference": true,
                "isRequired": true
              },
              {
                "jsonPath": "$.addressTypeDescriptor",
                "columnName": "AddressTypeDescriptor",
                "columnType": "descriptor",
                "isNaturalKey": true
              },
              {
                "jsonPath": "$.streetNumberName",
                "columnName": "StreetNumberName",
                "columnType": "string",
                "maxLength": "150"
              }
            ],
            "childTables": [
              {
                "baseName": "SchoolAddressPeriod",
                "jsonPath": "$.periods[*]",
                "columns": [
                  {
                    "columnName": "SchoolAddress_Id",
                    "columnType": "bigint",
                    "isParentReference": true,
                    "isRequired": true
                  },
                  {
                    "jsonPath": "$.beginDate",
                    "columnName": "BeginDate",
                    "columnType": "date",
                    "isNaturalKey": true
                  },
                  {
                    "jsonPath": "$.endDate",
                    "columnName": "EndDate",
                    "columnType": "date"
                  }
                ],
                "childTables": []
              }
            ]
          }
        ]
      }
    }
  }
}
```

### Example 2: StudentAssessment with Nested Collections

```json
{
  "studentAssessments": {
    "flatteningMetadata": {
      "table": {
        "baseName": "StudentAssessment",
        "jsonPath": "$",
        "columns": [
          {
            "jsonPath": "$.studentReference.studentUniqueId",
            "columnName": "StudentUniqueId",
            "columnType": "string",
            "maxLength": "100",
            "isNaturalKey": true
          },
          {
            "columnName": "StudentId",
            "columnType": "bigint",
            "fromReferencePath": "StudentReference",
            "isRequired": true
          },
          {
            "jsonPath": "$.assessmentReference.assessmentIdentifier",
            "columnName": "AssessmentIdentifier",
            "columnType": "string",
            "maxLength": "60",
            "isNaturalKey": true
          },
          {
            "columnName": "AssessmentId",
            "columnType": "bigint",
            "fromReferencePath": "AssessmentReference",
            "isRequired": true
          }
        ],
        "childTables": [
          {
            "baseName": "StudentAssessmentStudentObjectiveAssessment",
            "jsonPath": "$.studentObjectiveAssessments[*]",
            "columns": [
              {
                "columnName": "StudentAssessment_Id",
                "columnType": "bigint",
                "isParentReference": true,
                "isRequired": true
              },
              {
                "jsonPath": "$.objectiveAssessmentReference.identificationCode",
                "columnName": "IdentificationCode",
                "columnType": "string",
                "maxLength": "60",
                "isNaturalKey": true
              }
            ],
            "childTables": [
              {
                "baseName": "StudentAssessmentStudentObjectiveAssessmentScoreResult",
                "jsonPath": "$.scoreResults[*]",
                "columns": [
                  {
                    "columnName": "StudentObjectiveAssessment_Id",
                    "columnType": "bigint",
                    "isParentReference": true,
                    "isRequired": true
                  },
                  {
                    "jsonPath": "$.assessmentReportingMethodDescriptor",
                    "columnName": "AssessmentReportingMethodDescriptor",
                    "columnType": "descriptor",
                    "isNaturalKey": true
                  },
                  {
                    "jsonPath": "$.result",
                    "columnName": "Result",
                    "columnType": "string",
                    "maxLength": "100"
                  },
                  {
                    "jsonPath": "$.resultDatatypeTypeDescriptor",
                    "columnName": "ResultDatatypeTypeDescriptor",
                    "columnType": "descriptor"
                  }
                ],
                "childTables": []
              }
            ]
          }
        ]
      }
    }
  }
}
```

### Example 3: Contact with Extension (Extension-Only Pattern)

```json
{
  "contacts": {
    "flatteningMetadata": {
      "table": {
        "baseName": "ContactExtension",
        "jsonPath": "$._ext.sample",
        "isExtensionTable": true,
        "columns": [
          {
            "columnName": "Contact_Id",
            "columnType": "bigint",
            "isParentReference": true,
            "isRequired": true
          }
          // Any scalar extension properties would be here
        ],
        "childTables": [
          {
            // This is a common extension of Address
            "baseName": "ContactExtensionAddress",
            "jsonPath": "$._ext.sample.addresses[*]",
            "columns": [
              {
                "columnName": "ContactExtension_Id",
                "columnType": "bigint",
                "isParentReference": true,
                "isRequired": true
              },
              {
                "jsonPath": "$.addressTypeDescriptor",
                "columnName": "AddressTypeDescriptor",
                "columnType": "descriptor",
                "isNaturalKey": true
              },
              {
                "jsonPath": "$.city",
                "columnName": "City",
                "columnType": "string",
                "maxLength": "30",
                "isNaturalKey": true
              },
              {
                // Part of common extension
                "jsonPath": "$._ext.sample.complex",
                "columnName": "Complex",
                "columnType": "string",
                "maxLength": "255"
              },
              {
                // Part of common extension
                "jsonPath": "$._ext.sample.onBusRoute",
                "columnName": "OnBusRoute",
                "columnType": "boolean",
                "isRequired": true
              }
            ],
            "childTables": []
          }
        ]
      }
    }
  }
}
```

### Example 4: StudentSchoolAssociation (Multiple Resource References)

```json
{
  "studentSchoolAssociations": {
    "flatteningMetadata": {
      "table": {
        "baseName": "StudentSchoolAssociation",
        "jsonPath": "$",
        "columns": [
          {
            "columnName": "Student_Id",
            "columnType": "bigint",
            "fromReferencePath": "Student",
            "isRequired": true,
            "isNaturalKey": true
          },
          {
            "columnName": "School_Id",
            "columnType": "bigint",
            "fromReferencePath": "School",
            "isRequired": true,
            "isNaturalKey": true
          },
          {
            "jsonPath": "$.entryDate",
            "columnName": "EntryDate",
            "columnType": "date",
            "isRequired": true,
            "isNaturalKey": true
          },
          {
            "jsonPath": "$.entryGradeLevelDescriptor",
            "columnName": "EntryGradeLevelDescriptor",
            "columnType": "descriptor"
          },
          {
            "jsonPath": "$.exitWithdrawDate",
            "columnName": "ExitWithdrawDate",
            "columnType": "date"
          }
        ],
        "childTables": []
      }
    }
  }
}
```

### Example 5: StudentEducationOrganizationResponsibilityAssociation (Polymorphic Reference)

```json
{
  "studentEducationOrganizationResponsibilityAssociations": {
    "flatteningMetadata": {
      "table": {
        "baseName": "StudentEducationOrganizationResponsibilityAssociation",
        "jsonPath": "$",
        "columns": [
          {
            "columnName": "Student_Id",
            "columnType": "bigint",
            "fromReferencePath": "StudentReference",
            "isRequired": true,
            "isNaturalKey": true
          },
          {
            // Polymorphic reference - can be School, LEA, SEA, etc.
            "columnName": "EducationOrganization_Id",
            "columnType": "bigint",
            "fromReferencePath": "EducationOrganizationReference",
            "isRequired": true,
            "isNaturalKey": true,
            "isPolymorphicReference": true,
            "polymorphicType": "EducationOrganization"  // Specifies which superclass hierarchy
          },
          {
            // Auto-generated discriminator for polymorphic reference
            "columnName": "EducationOrganization_Discriminator",
            "columnType": "string",
            "maxLength": "128",
            "isDiscriminator": true,
            "polymorphicType": "EducationOrganization",  // Links discriminator to its polymorphic reference
            "isRequired": true
          },
          {
            "jsonPath": "$.responsibilityDescriptor",
            "columnName": "ResponsibilityDescriptorId",
            "columnType": "descriptor",
            "isRequired": true,
            "isNaturalKey": true
          },
          {
            "jsonPath": "$.beginDate",
            "columnName": "BeginDate",
            "columnType": "date",
            "isRequired": true
          },
          {
            "jsonPath": "$.endDate",
            "columnName": "EndDate",
            "columnType": "date"
          }
        ],
        "childTables": []
      }
    }
  }
}
```

## TypeScript Type Definitions

```typescript
// Main flattening metadata structure
interface FlatteningMetadata {
  table: TableMetadata;  // Root table (can be core resource or extension)
}

// Recursive table structure
interface TableMetadata {
  baseName: string;  // Table name (will be transformed per database conventions)
  jsonPath: string;  // Relative path from document root, includes [*] for collections
  columns: ColumnMetadata[];
  childTables: TableMetadata[];  // Recursive reference for nested collections
  isExtensionTable?: boolean;  // Indicates this is an extension table
  discriminatorValue?: string;  // For subclasses, the value for union view discriminator (e.g., 'School')
}

// Column metadata
interface ColumnMetadata {
  jsonPath?: string;  // Relative to the table's jsonPath (optional for generated columns)
  columnName: string;  // Column name (will be transformed downstream per database conventions)
  columnType: ColumnType;  // Abstract column type
  maxLength?: string;  // For string columns (e.g., "100")
  precision?: string;  // For decimal columns (e.g., "10")
  scale?: string;  // For decimal columns (e.g., "4")
  isNaturalKey?: boolean;
  isRequired?: boolean;
  isParentReference?: boolean;  // Indicates this is a foreign key to parent table
  fromReferencePath?: string;  // documentPathsMapping key for document references
  isPolymorphicReference?: boolean;  // Indicates reference can point to multiple resource types
  polymorphicType?: string;  // Which superclass hierarchy (e.g., 'EducationOrganization', 'GeneralStudentProgramAssociation')
  isDiscriminator?: boolean;  // Marks this as a discriminator column for polymorphic reference
  isSuperclassIdentity?: boolean;  // Is a natural key that maps to superclass identity
}

// Abstract column types (from MetaEd relational plugin)
type ColumnType =
  | 'bigint'     // Maps to BIGINT
  | 'boolean'    // Maps to BIT (SQL Server) or BOOLEAN (PostgreSQL)
  | 'currency'   // Maps to MONEY
  | 'date'       // Maps to DATE
  | 'datetime'   // Maps to DATETIME2(7) (SQL Server) or TIMESTAMP (PostgreSQL)
  | 'decimal'    // Maps to DECIMAL(precision, scale)
  | 'descriptor'  // Maps to BIGINT (foreign key to descriptor table)
  | 'duration'   // Maps to NVARCHAR(30) (SQL Server) or VARCHAR(30) (PostgreSQL)
  | 'integer'    // Maps to INT
  | 'percent'    // Maps to DECIMAL(5, 4)
  | 'short'      // Maps to SMALLINT
  | 'string'     // Maps to NVARCHAR(length) (SQL Server) or VARCHAR(length) (PostgreSQL)
  | 'time'       // Maps to TIME
  | 'year'       // Maps to SMALLINT
  | 'unknown';

// Abstract resource flattening metadata (for superclasses like EducationOrganization)
interface AbstractResourceFlatteningMetadata {
  subclassTypes: string[];  // List of concrete subclass resource names
  unionViewName: string;  // Name of the union view for polymorphic access
}

// BaseResourceSchema will be extended with flattening metadata
interface BaseResourceSchema {
  // Existing properties
  resourceName: string;
  identityJsonPaths: string[];
  documentPathsMapping: { [key: string]: DocumentPath };
  // ... other existing properties

  // New required property for flattening
  flatteningMetadata: FlatteningMetadata;
}

// Abstract resources also extended, with different metadata structure
interface AbstractResourceSchema {
  resourceName: string;
  identityJsonPaths: string[];
  flatteningMetadata: AbstractResourceFlatteningMetadata;
}
```

## Metadata Requirements for Polymorphic References

### Information Needed by DDL Generator

The C# DDL generator requires specific metadata to handle polymorphic references correctly:

#### 1. For Abstract Resources (e.g., EducationOrganization)

The ApiSchema's `abstractResources` section needs enhancement:
```json
"abstractResources": {
  "EducationOrganization": {
    "identityJsonPaths": ["$.educationOrganizationId"],
    "flatteningMetadata": {
      "subclassTypes": [
        "School",
        "LocalEducationAgency",
        "StateEducationAgency",
        "EducationServiceCenter",
        "OrganizationDepartment"
      ],
      "unionViewName": "EducationOrganization"
    }
  }
}
```

#### 2. For Concrete Subclass Resources (e.g., School)

The resource schema needs to indicate inheritance and complete materialization:
```json
"schools": {
  "isSubclass": true,  // Existing resource-level property
  "subclassType": "School",  // Existing property
  "superclassResourceName": "EducationOrganization",
  "superclassProjectName": "Ed-Fi",
  "superclassIdentityJsonPath": "$.educationOrganizationId",
  "flatteningMetadata": {
    "table": {
      "baseName": "School",
      "discriminatorValue": "School",  // For union view
      "columns": [
        // ALL columns including inherited ones are already defined here
        {
          "jsonPath": "$.schoolId",
          "columnName": "SchoolId",
          "columnType": "bigint",
          "isNaturalKey": true,
          "isSuperclassIdentity": true  // Maps to educationOrganizationId value
        },
        {
          "jsonPath": "$.nameOfInstitution",
          "columnName": "NameOfInstitution",
          "columnType": "string",
          "maxLength": "255"
        }
        // ... all other columns (both inherited and school-specific)
      ]
    }
  }
}
```

#### 3. For Resources with Polymorphic References

Polymorphic references require both the FK column and a discriminator:
```json
"columns": [
  {
    "columnName": "EducationOrganization_Id",
    "columnType": "bigint",
    "fromReferencePath": "EducationOrganizationReference",
    "isPolymorphicReference": true,
    "polymorphicType": "EducationOrganization",
    "isNaturalKey": true
  },
  {
    // Auto-generated by DDL generator when isPolymorphicReference is true
    "columnName": "EducationOrganization_Discriminator",
    "columnType": "string",
    "maxLength": "128",
    "isDiscriminator": true,
    "polymorphicType": "EducationOrganization"
  }
]
```

### DDL Generator Processing Logic

1. **Abstract Resources**:
   - Skip physical table creation (they're abstract)
   - Generate union view using `subclassTypes` list
   - Each subclass provides its own complete column set

2. **Subclass Resources**:
   - Generate complete table with all columns (already defined in metadata)
   - Use `discriminatorValue` for union view compatibility
   - The `isSubclass` flag at resource level indicates inheritance

3. **Polymorphic References**:
   - Create FK column without constraint when `isPolymorphicReference: true`
   - Auto-generate discriminator column
   - Create check constraint for valid discriminator values
   - Generate view with virtual FK join

4. **Resolution Process**: Use DMS Alias and Document tables to resolve concrete type

## Key Architectural Decisions

1. **Recursive Structure**: Single, unified `TableMetadata` type that can represent any level of nesting through the `childTables` array. The schema name for all tables is derived from the projectSchema configuration rather than being specified per-table.

2. **Database-Specific Naming**: Table and column names use PascalCase for both PostgreSQL and SQL Server. Underscores are used specifically for:
   - Foreign key references to surrogate keys (e.g., `School_Id`, `StudentAddress_Id`)
   - Document metadata columns (e.g., `Document_Id`, `Document_PartitionKey`)

3. **JsonPath Scoping**:
   - Table jsonPaths are absolute from document root (`$`)
   - Collection table jsonPaths include the array notation (e.g., `$.addresses[*]`)
   - Column jsonPaths are relative to their containing table's jsonPath
   - This avoids redundancy and clearly shows the hierarchical structure

4. **Natural vs Surrogate Keys**:
   - Natural keys marked with `isNaturalKey: true`
   - Surrogate keys (Id) generated downstream, not in metadata

5. **Reference Resolution**: Resource references are columns with `fromReferencePath` pointing to the existing `documentPathsMapping` entries. The DMS runtime can look up the reference details from `documentPathsMapping[fromReferencePath]` which already contains:
   - The target resource type
   - The JSON paths for natural key resolution
   - Whether it's required or optional
   - The reference validation rules

6. **Parent-Child Relationships**: Parent foreign keys are regular columns marked with `isParentReference: true`. Foreign keys back to table surrogate keys follow the naming convention `<TableName>_Id` (e.g., `School_Id` for a FK back to the School table, `StudentAddress_Id` for a FK back to the StudentAddress table).

7. **Extension Handling**: Extensions from different projects (e.g., Sample, TPDM) are separated into their own table hierarchies:
   - Extension root tables are named `{ResourceName}Extension` (e.g., `ContactExtension`)
   - Extension tables are marked with `isExtensionTable: true`
   - Extension project name is derived from projectSchema, not stored in metadata
   - Extension tables have a foreign key back to the core resource's surrogate key
   - Extension collections follow the same recursive pattern as core collections
   - Document paths starting with `$._ext.{projectName}` indicate extension content
   - Extensions can extend both resources AND common types within those resources
   - When extending common types (e.g., Address), the extension fields appear under a second-level `_ext` (e.g., `addresses[*]._ext.sample.complex`)
   - Extension-only schemas have their root table marked with `isExtensionTable: true`

### Integration with Existing documentPathsMapping

The `fromReferencePath` property references keys in the existing `documentPathsMapping`. For example:

```json
// In existing documentPathsMapping:
"StudentReference": {
  "isReference": true,
  "projectName": "Ed-Fi",
  "resourceName": "Student",
  "isDescriptor": false,
  "isRequired": true,
  "path": "$.studentReference"
}

// In flatteningMetadata column:
{
  "columnName": "StudentId",
  "columnType": "bigint",
  "fromReferencePath": "StudentReference",  // Links to documentPathsMapping["StudentReference"]
  "isRequired": true
}
```

This design reuses existing metadata rather than duplicating reference information, and allows the use of referentialId to lookup surrogate keys for flattened references e.g. Student_Id.

### Database-Specific Transformations

The simplified metadata uses abstract types and base names that will be transformed by database-specific plugins:

**Column Name Conventions:**
- Both PostgreSQL and SQL Server use PascalCase (e.g., `StudentUniqueId`)
- Underscores are reserved for specific patterns like foreign keys (`School_Id`) and document metadata (`Document_Id`)

**Type Mappings:**
- `string` with `maxLength`:
  - PostgreSQL: `VARCHAR({maxLength})`
  - SQL Server: `NVARCHAR({maxLength})` or `NVARCHAR(MAX)` if length > 4000
- `decimal` with `precision` and `scale`:
  - PostgreSQL: `DECIMAL({precision}, {scale})`
  - SQL Server: `DECIMAL({precision}, {scale})`
- `bigint`: Maps to `BIGINT` in both databases
- `integer`: Maps to `INT` in both
- `descriptor`: Maps to `BIGINT` in both databases, and also indicates a FK to unified `Descriptor` table
- `date`: Maps to `DATE` in both
- `datetime`: Maps to `TIMESTAMP` (PostgreSQL) or `DATETIME2(7)` (SQL Server)
- `boolean`: Maps to `BOOLEAN` (PostgreSQL) or `BIT` (SQL Server)

## Unified Descriptor Table Design

### Overview

In DMS, descriptors are stored as documents in the Document table just like any other resource. For relational flattening, we need to replicate the ODS/API structure which uses a single unified `Descriptor` table that stores all descriptors regardless of type. This table serves as the target for all descriptor foreign key references from flattened resource tables.

### Integration with DMS Three-Table Architecture

The DMS uses a three-table design:
- **Document**: Stores all documents including descriptors (marked with `IsDescriptor = true`)
- **Alias**: Maps `ReferentialId` (UUID) to `DocumentId` for identity-based lookups
- **Reference**: Tracks all references between documents (including descriptor references)

Descriptor references in DMS:
- Each descriptor has a `ReferentialId` computed from its URI: `namespace#codeValue` (lowercased)
- The `DescriptorReference` type contains the `ReferentialId` for lookups
- The existing Alias table already indexes `ReferentialId` for efficient lookups

### Descriptor Table Structure

PostgreSQL:
```sql
CREATE TABLE dms.Descriptor (
    Id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    -- Lookup keys for integration with DMS
    ReferentialId UUID NOT NULL,
    ReferentialPartitionKey SMALLINT NOT NULL,
    -- Core descriptor fields (extracted from Document.EdfiDoc)
    Namespace VARCHAR(255) NOT NULL,
    CodeValue VARCHAR(50) NOT NULL,
    ShortDescription VARCHAR(75) NOT NULL,
    Description VARCHAR(1024),
    Uri VARCHAR(306) GENERATED ALWAYS AS (Namespace || '#' || CodeValue) STORED,
    Discriminator VARCHAR(128),  -- e.g., 'GradeLevelDescriptor', 'AcademicSubjectDescriptor'
    -- Link back to source document
    Document_Id BIGINT NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    -- Constraints and indexes
    UNIQUE (ReferentialId, ReferentialPartitionKey),
    FOREIGN KEY (Document_PartitionKey, Document_Id)
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);

-- Critical index for flattening process lookups
CREATE INDEX IX_Descriptor_ReferentialId
    ON dms.Descriptor(ReferentialPartitionKey, ReferentialId);
```

For SQL Server, the structure is similar with appropriate type adjustments:
```sql
CREATE TABLE dms.Descriptor (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    ReferentialId UNIQUEIDENTIFIER NOT NULL,
    ReferentialPartitionKey SMALLINT NOT NULL,
    Namespace NVARCHAR(255) NOT NULL,
    CodeValue NVARCHAR(50) NOT NULL,
    ShortDescription NVARCHAR(75) NOT NULL,
    Description NVARCHAR(1024),
    Uri AS (Namespace + '#' + CodeValue) PERSISTED NOT NULL,
    Discriminator NVARCHAR(128),
    Document_Id BIGINT NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    UNIQUE (ReferentialId, ReferentialPartitionKey),
    FOREIGN KEY (Document_PartitionKey, Document_Id)
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);
```

### Population Strategy

1. **Initial Population**: When a descriptor document is inserted/updated in the Document table (where `IsDescriptor = true`), the descriptor fields are extracted from the `EdfiDoc` JSONB column and upserted into the Descriptor table.

2. **Field Extraction**: The following fields are extracted from the descriptor document:
   - `namespace` â†’ `Namespace`
   - `codeValue` â†’ `CodeValue`
   - `shortDescription` â†’ `ShortDescription`
   - `description` â†’ `Description` (optional)
   - The descriptor type (e.g., 'GradeLevelDescriptor') â†’ `Discriminator`

### Descriptor Reference Resolution During Flattening

When flattening a resource document that contains descriptor references:

1. **Compute ReferentialId**: The DMS already computes the ReferentialId from the URI using the same algorithm as for document identity

2. **Lookup Descriptor.Id**: Query the Descriptor table using the ReferentialId and ReferentialPartitionKey:
   ```sql
   SELECT Id FROM dms.Descriptor
   WHERE ReferentialId = ? AND ReferentialPartitionKey = ?
   ```

3. **Store Foreign Key**: Store the retrieved `Descriptor.Id` in the descriptor FK column of the flattened resource table

### Example Usage in Flattened Tables

```sql
-- Flattened resource table with descriptor references
CREATE TABLE edfi.School (
    Id BIGINT PRIMARY KEY,
    SchoolId INT NOT NULL,
    NameOfInstitution VARCHAR(255) NOT NULL,
    -- Descriptor foreign key columns
    SchoolTypeDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    CharterStatusDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    -- ... other columns
);
```

### Key Design Decisions

1. **Single Unified Table**: Following the ODS/API pattern, all descriptor types are stored in a single table rather than separate tables per descriptor type.

2. **ReferentialId as Lookup Key**: Leverages the existing DMS ReferentialId infrastructure for efficient descriptor resolution during flattening.

3. **Surrogate Key Pattern**: The `Descriptor.Id` serves as the surrogate key referenced by all flattened resource tables, matching the ODS/API design.

4. **Bidirectional Navigation**: Maintains the link back to the source Document through `Document_Id`, enabling bidirectional navigation if needed.

5. **Efficient Indexing**: The index on `(ReferentialPartitionKey, ReferentialId)` ensures fast lookups during the flattening process.

## Polymorphic Reference Handling

### Overview

Polymorphic references occur when a reference can point to multiple resource types. The primary examples in Ed-Fi are:
- **EducationOrganization**: Superclass of School, LocalEducationAgency, StateEducationAgency, EducationServiceCenter, etc.
- **GeneralStudentProgramAssociation**: Superclass of StudentProgramAssociation, StudentSpecialEducationProgramAssociation, StudentSchoolFoodServiceProgramAssociation, etc.

In DMS, the Alias table already handles polymorphic references by mapping a single ReferentialId to the appropriate DocumentId regardless of the concrete type. For relational flattening, we need to translate this to a table structure that maintains the ODS/API appearance while efficiently handling these references.

### Complete Materialization Pattern

Each concrete subclass table contains all fields from both the superclass and its own specific fields. This eliminates the need for inheritance joins while maintaining data integrityâ€”each entity exists in exactly one table.

### Table Structure

```sql
-- Complete School table (includes all EducationOrganization fields)
CREATE TABLE edfi.School (
    Id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,  -- Surrogate key
    SchoolId BIGINT NOT NULL,  -- Natural key (same value as EducationOrganizationId)
    -- Common EducationOrganization fields
    NameOfInstitution VARCHAR(255) NOT NULL,
    OperationalStatusDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    ShortNameOfInstitution VARCHAR(75),
    WebSite VARCHAR(255),
    -- School-specific fields
    SchoolTypeDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    CharterStatusDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    AdministrativeFundingControlDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    LocalEducationAgency_Id BIGINT,
    -- Metadata
    Document_Id BIGINT NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    -- Non-model colums like create date added by C# generation
    UNIQUE (SchoolId)
);

-- Complete StateEducationAgency table
CREATE TABLE edfi.StateEducationAgency (
    Id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    StateEducationAgencyId BIGINT NOT NULL,  -- Natural key (same value as EducationOrganizationId)
    -- Common EducationOrganization fields
    NameOfInstitution VARCHAR(255) NOT NULL,
    OperationalStatusDescriptorId BIGINT REFERENCES dms.Descriptor(Id),
    ShortNameOfInstitution VARCHAR(75),
    WebSite VARCHAR(255),
    -- StateEducationAgency-specific fields (if any)
    -- Metadata
    Document_Id BIGINT NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    -- Non-model colums like create date added by C# generation
    UNIQUE (StateEducationAgencyId)
);

-- Union view for polymorphic EducationOrganization references
CREATE VIEW edfi.EducationOrganization_View AS
SELECT
    Id,
    SchoolId as EducationOrganizationId,
    NameOfInstitution,
    OperationalStatusDescriptorId,
    ShortNameOfInstitution,
    WebSite,
    'School' as Discriminator,
    Document_Id,
    Document_PartitionKey
FROM edfi.School
UNION ALL
SELECT
    Id,
    StateEducationAgencyId as EducationOrganizationId,
    NameOfInstitution,
    OperationalStatusDescriptorId,
    ShortNameOfInstitution,
    WebSite,
    'StateEducationAgency' as Discriminator,
    Document_Id,
    Document_PartitionKey
FROM edfi.StateEducationAgency
UNION ALL
SELECT
    Id,
    LocalEducationAgencyId as EducationOrganizationId,
    NameOfInstitution,
    OperationalStatusDescriptorId,
    ShortNameOfInstitution,
    WebSite,
    'LocalEducationAgency' as Discriminator,
    Document_Id,
    Document_PartitionKey
FROM edfi.LocalEducationAgency;
-- ... additional subclasses as needed
```

### Union View Performance Considerations

**Note**: The union view pattern is not expected to be a performance concern for the following reasons:
- Education organization data is slowly changing (updates measured in days/weeks, not seconds)
- Total row count across all education organization types typically remains under 1,000 rows
- Modern database optimizers handle small union views efficiently with proper statistics

However, if performance issues are observed in production, several optimization strategies are available:

1. **Materialized Views** (PostgreSQL) or **Indexed Views** (SQL Server)
   - Pre-compute and store the union results
   - Refresh on source table changes via triggers
   - Reduces query time from ~5ms to ~1ms

2. **Database-Specific Optimizations**
   - Update statistics with `FULLSCAN` for accurate query plans
   - Use query hints to force optimal join strategies
   - Consider unlogged/memory-optimized tables for ultra-low latency

These optimizations should only be implemented if monitoring reveals actual performance degradation, following the principle of avoiding premature optimization.

### Polymorphic Reference Resolution During Flattening

A simple approach when flattening a document that contains a polymorphic reference (e.g., an educationOrganizationReference):

1. **Extract the reference's ReferentialId** from the document

2. **Use DMS Alias table** to find the DocumentId:
   ```sql
   SELECT DocumentId, DocumentPartitionKey
   FROM dms.Alias
   WHERE ReferentialId = ? AND ReferentialPartitionKey = ?
   ```

3. **Determine the concrete type** from the Document table:
   ```sql
   SELECT ResourceName
   FROM dms.Document
   WHERE Id = ? AND DocumentPartitionKey = ?
   ```

4. **Look up the surrogate key** from the appropriate concrete table:
   ```sql
   -- If ResourceName = 'schools'
   SELECT Id FROM edfi.School WHERE Document_Id = ? AND Document_PartitionKey = ?
   ```

5. **Store the foreign key** in the referencing table

Note these queries can be combined.

### Optimized Polymorphic Reference Resolution (Stored Procedure)

To improve performance, the polymorphic reference resolution should be consolidated into a single stored procedure that eliminates multiple round-trips to the database:

#### PostgreSQL Implementation

```sql
CREATE OR REPLACE FUNCTION dms.resolve_polymorphic_reference(
  p_referential_id UUID,
  p_partition_key SMALLINT,
  p_abstract_type VARCHAR(128) DEFAULT 'EducationOrganization'
)
RETURNS TABLE(concrete_id BIGINT, discriminator VARCHAR(128))
LANGUAGE SQL
STABLE
PARALLEL SAFE
AS $$
  SELECT
    CASE d.ResourceName
      WHEN 'School' THEN s.Id
      WHEN 'LocalEducationAgency' THEN lea.Id
      WHEN 'StateEducationAgency' THEN sea.Id
      WHEN 'EducationServiceCenter' THEN esc.Id
      WHEN 'OrganizationDepartment' THEN od.Id
      WHEN 'PostsecondaryInstitution' THEN psi.Id
      WHEN 'CommunityOrganization' THEN co.Id
      WHEN 'CommunityProvider' THEN cp.Id
      -- Additional concrete types can be added here
      ELSE NULL
    END as concrete_id,
    d.ResourceName as discriminator
  FROM dms.Alias a
  INNER JOIN dms.Document d
    ON a.DocumentId = d.Id
    AND a.DocumentPartitionKey = d.DocumentPartitionKey
  LEFT JOIN edfi.School s
    ON d.Id = s.Document_Id
    AND d.DocumentPartitionKey = s.Document_PartitionKey
    AND d.ResourceName = 'School'
  LEFT JOIN edfi.LocalEducationAgency lea
    ON d.Id = lea.Document_Id
    AND d.DocumentPartitionKey = lea.Document_PartitionKey
    AND d.ResourceName = 'LocalEducationAgency'
  LEFT JOIN edfi.StateEducationAgency sea
    ON d.Id = sea.Document_Id
    AND d.DocumentPartitionKey = sea.Document_PartitionKey
    AND d.ResourceName = 'StateEducationAgency'
  LEFT JOIN edfi.EducationServiceCenter esc
    ON d.Id = esc.Document_Id
    AND d.DocumentPartitionKey = esc.Document_PartitionKey
    AND d.ResourceName = 'EducationServiceCenter'
  LEFT JOIN edfi.OrganizationDepartment od
    ON d.Id = od.Document_Id
    AND d.DocumentPartitionKey = od.Document_PartitionKey
    AND d.ResourceName = 'OrganizationDepartment'
  LEFT JOIN edfi.PostsecondaryInstitution psi
    ON d.Id = psi.Document_Id
    AND d.DocumentPartitionKey = psi.Document_PartitionKey
    AND d.ResourceName = 'PostsecondaryInstitution'
  LEFT JOIN edfi.CommunityOrganization co
    ON d.Id = co.Document_Id
    AND d.DocumentPartitionKey = co.Document_PartitionKey
    AND d.ResourceName = 'CommunityOrganization'
  LEFT JOIN edfi.CommunityProvider cp
    ON d.Id = cp.Document_Id
    AND d.DocumentPartitionKey = cp.Document_PartitionKey
    AND d.ResourceName = 'CommunityProvider'
  WHERE a.ReferentialId = p_referential_id
    AND a.ReferentialPartitionKey = p_partition_key;
$$;

-- Create similar function for GeneralStudentProgramAssociation hierarchy
```

### Foreign Key Storage Pattern

For tables with polymorphic references, we store the concrete table's surrogate key:

```sql
CREATE TABLE edfi.StaffEducationOrganizationAssignmentAssociation (
    Id BIGINT PRIMARY KEY,
    Staff_Id BIGINT NOT NULL REFERENCES edfi.Staff(Id),
    -- Polymorphic reference: could be School, LEA, SEA, etc.
    -- We don't use a foreign key constraint here since it could reference multiple tables
    EducationOrganization_Id BIGINT NOT NULL,

    EducationOrganization_Discriminator VARCHAR(128) NOT NULL,  -- Stores the concrete type
    -- ... other fields
);
```

During queries, joins can use the discriminator to determine which table to join:
```sql
-- Example query joining to the appropriate concrete table
SELECT
    seoaa.*,
    CASE
        WHEN seoaa.EducationOrganization_Discriminator = 'School'
        THEN s.NameOfInstitution
        WHEN seoaa.EducationOrganization_Discriminator = 'StateEducationAgency'
        THEN sea.NameOfInstitution
    END as EducationOrganizationName
FROM edfi.StaffEducationOrganizationAssignmentAssociation seoaa
LEFT JOIN edfi.School s
    ON seoaa.EducationOrganization_Id = s.Id
    AND seoaa.EducationOrganization_Discriminator = 'School'
LEFT JOIN edfi.StateEducationAgency sea
    ON seoaa.EducationOrganization_Id = sea.Id
    AND seoaa.EducationOrganization_Discriminator = 'StateEducationAgency';
```

Alternatively, use the union view for simpler (though potentially less performant) queries:
```sql
SELECT
    seoaa.*,
    eo.NameOfInstitution as EducationOrganizationName
FROM edfi.StaffEducationOrganizationAssignmentAssociation seoaa
JOIN edfi.EducationOrganization eo ON seoaa.EducationOrganization_Id = eo.Id;
```

### Key Design Decisions

1. **Complete Materialization**: Each concrete table contains all fields from its inheritance hierarchy.

2. **No Physical Inheritance**: Unlike ODS/API's table inheritance pattern, we don't create separate superclass tables. The inheritance exists only conceptually through the union view.

3. **Union Views for Polymorphism**: When polymorphic access is needed, union views provide a unified interface across all concrete types.

4. **Discriminator Storage**: For polymorphic foreign keys, we store both the Id and a discriminator to identify the concrete type, enabling efficient targeted joins.

### Reconstructing Foreign Keys Through Views

Since polymorphic references cannot have physical foreign key constraints (they would need to reference multiple tables), we reconstruct the FK relationship through views:

#### Base Table Without Physical FK
```sql
CREATE TABLE edfi.StaffEducationOrganizationAssignmentAssociation (
    Id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    Staff_Id BIGINT NOT NULL REFERENCES edfi.Staff(Id),
    -- No FK constraint possible here since it references multiple tables
    EducationOrganization_Id BIGINT NOT NULL,
    EducationOrganization_Discriminator VARCHAR(128) NOT NULL,
    BeginDate DATE NOT NULL,
    -- ... other columns
    UNIQUE (Staff_Id, EducationOrganization_Id, BeginDate)
);

-- Add check constraint to ensure valid discriminator values
ALTER TABLE edfi.StaffEducationOrganizationAssignmentAssociation
ADD CONSTRAINT CK_EducationOrganization_Discriminator
CHECK (EducationOrganization_Discriminator IN (
    'School',
    'LocalEducationAgency',
    'StateEducationAgency',
    'EducationServiceCenter',
    'OrganizationDepartment'
));
```

#### Query View with Virtual FK Join
```sql
-- This view reconstructs the FK relationship through the union view
CREATE VIEW edfi.StaffEducationOrganizationAssignmentAssociation_View AS
SELECT
    seoaa.*,
    eo.EducationOrganizationId,
    eo.NameOfInstitution,
    eo.OperationalStatusDescriptorId,
    eo.ShortNameOfInstitution,
    eo.WebSite
FROM edfi.StaffEducationOrganizationAssignmentAssociation seoaa
-- This JOIN effectively reconstructs the FK relationship
INNER JOIN edfi.EducationOrganization eo
    ON seoaa.EducationOrganization_Id = eo.Id
    AND seoaa.EducationOrganization_Discriminator = eo.Discriminator;
```

#### Optional Trigger-Based FK Enforcement

For full referential integrity at the database level, triggers can enforce the relationship:

```sql
CREATE OR REPLACE FUNCTION edfi.validate_education_organization_reference()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if the reference exists in the union view
    IF NOT EXISTS (
        SELECT 1 FROM edfi.EducationOrganization
        WHERE Id = NEW.EducationOrganization_Id
        AND Discriminator = NEW.EducationOrganization_Discriminator
    ) THEN
        RAISE EXCEPTION 'Invalid EducationOrganization reference: % (%)',
            NEW.EducationOrganization_Id, NEW.EducationOrganization_Discriminator;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_edorg_reference
BEFORE INSERT OR UPDATE ON edfi.StaffEducationOrganizationAssignmentAssociation
FOR EACH ROW EXECUTE FUNCTION edfi.validate_education_organization_reference();
```

#### Benefits of View-Based FK Reconstruction

1. **Referential Integrity at Query Time**: The INNER JOIN ensures only valid references are returned
2. **Single Join Path**: Instead of multiple LEFT JOINs to each possible concrete table
3. **Simpler Application Queries**: Applications can treat it like a normal FK relationship through the view
4. **Performance Options**: Can create indexed/materialized views if needed for frequent queries
5. **Data Integrity Options**: Check constraints and triggers provide varying levels of enforcement

## Database Table Structure Generated

### PostgreSQL Example
```sql
-- Root table
CREATE TABLE edfi.Student (
    Id BIGSERIAL PRIMARY KEY,
    StudentUniqueId VARCHAR(100) NOT NULL,
    FirstName VARCHAR(75) NOT NULL,
    LastSurname VARCHAR(75) NOT NULL,
    Document_Id UUID NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    UNIQUE (StudentUniqueId)
);

-- First-level collection
CREATE TABLE edfi.StudentAddress (
    Id BIGSERIAL PRIMARY KEY,
    Student_Id BIGINT NOT NULL REFERENCES edfi.Student(Id) ON DELETE CASCADE,
    AddressTypeDescriptorId BIGINT NOT NULL REFERENCES dms.Descriptor(Id),
    StreetNumberName VARCHAR(150),
    UNIQUE (Student_Id, AddressTypeDescriptorId)
);

-- Second-level collection (nested)
CREATE TABLE edfi.StudentAddressPeriod (
    Id BIGSERIAL PRIMARY KEY,
    StudentAddress_Id BIGINT NOT NULL REFERENCES edfi.StudentAddress(Id) ON DELETE CASCADE,
    BeginDate DATE NOT NULL,
    EndDate DATE,
    UNIQUE (StudentAddress_Id, BeginDate)
);

-- Extension table example
CREATE TABLE edfi.Contact (
    Id BIGSERIAL PRIMARY KEY,
    ContactUniqueId VARCHAR(32) NOT NULL,
    FirstName VARCHAR(75),
    LastSurname VARCHAR(75),
    Document_Id UUID NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    UNIQUE (ContactUniqueId)
);

-- Extension root table (one per extension project)
CREATE TABLE edfi.ContactExtension (
    Id BIGSERIAL PRIMARY KEY,
    Contact_Id BIGINT NOT NULL REFERENCES edfi.Contact(Id) ON DELETE CASCADE,
    -- Extension-specific scalar columns would go here
    UNIQUE (Contact_Id)
);

-- Extension collection table
-- Contains both base Address fields (from core common type) and extension fields
CREATE TABLE edfi.ContactExtensionAddress (
    Id BIGSERIAL PRIMARY KEY,
    ContactExtension_Id BIGINT NOT NULL REFERENCES edfi.ContactExtension(Id) ON DELETE CASCADE,
    AddressTypeDescriptorId BIGINT NOT NULL REFERENCES dms.Descriptor(Id),
    City VARCHAR(30) NOT NULL,  -- Core Address field
    Complex VARCHAR(255),  -- Extension field (addresses[*]._ext.sample.complex)
    OnBusRoute BOOLEAN NOT NULL,  -- Extension field (addresses[*]._ext.sample.onBusRoute)
    UNIQUE (ContactExtension_Id, AddressTypeDescriptorId, City)
);
```

### SQL Server Example
```sql
-- Root table
CREATE TABLE edfi.Student (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    StudentUniqueId NVARCHAR(100) NOT NULL,
    FirstName NVARCHAR(75) NOT NULL,
    LastSurname NVARCHAR(75) NOT NULL,
    Document_Id UNIQUEIDENTIFIER NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    UNIQUE (StudentUniqueId)
);

-- First-level collection
CREATE TABLE edfi.StudentAddress (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    Student_Id BIGINT NOT NULL FOREIGN KEY REFERENCES edfi.Student(Id) ON DELETE CASCADE,
    AddressTypeDescriptorId BIGINT NOT NULL FOREIGN KEY REFERENCES dms.Descriptor(Id),
    StreetNumberName NVARCHAR(150),
    UNIQUE (Student_Id, AddressTypeDescriptorId)
);

-- Second-level collection (nested)
CREATE TABLE edfi.StudentAddressPeriod (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    StudentAddress_Id BIGINT NOT NULL FOREIGN KEY REFERENCES edfi.StudentAddress(Id) ON DELETE CASCADE,
    BeginDate DATE NOT NULL,
    EndDate DATE,
    UNIQUE (StudentAddress_Id, BeginDate)
);

-- Extension table example
CREATE TABLE edfi.Contact (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    ContactUniqueId NVARCHAR(32) NOT NULL,
    FirstName NVARCHAR(75),
    LastSurname NVARCHAR(75),
    Document_Id UNIQUEIDENTIFIER NOT NULL,
    Document_PartitionKey SMALLINT NOT NULL,
    UNIQUE (ContactUniqueId)
);

-- Extension root table (one per extension project)
CREATE TABLE edfi.ContactExtension (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    Contact_Id BIGINT NOT NULL FOREIGN KEY REFERENCES edfi.Contact(Id) ON DELETE CASCADE,
    -- Extension-specific scalar columns would go here
    UNIQUE (Contact_Id)
);

-- Extension collection table
-- Contains both base Address fields (from core common type) and extension fields
CREATE TABLE edfi.ContactExtensionAddress (
    Id BIGINT IDENTITY(1,1) PRIMARY KEY,
    ContactExtension_Id BIGINT NOT NULL FOREIGN KEY REFERENCES edfi.ContactExtension(Id) ON DELETE CASCADE,
    AddressTypeDescriptorId BIGINT NOT NULL FOREIGN KEY REFERENCES dms.Descriptor(Id),
    City NVARCHAR(30) NOT NULL,  -- Core Address field
    Complex NVARCHAR(255),  -- Extension field (addresses[*]._ext.sample.complex)
    OnBusRoute BIT NOT NULL,  -- Extension field (addresses[*]._ext.sample.onBusRoute)
    UNIQUE (ContactExtension_Id, AddressTypeDescriptorId, City)
);
```

## Integration Points

### MetaEd Enhancement Pipeline
New enhancers needed in the API Schema plugin:
1. **FlatteningMetadataInitializer** - Creates empty flattening structure
2. **TableStructureAnalyzer** - Analyzes entity model to determine table hierarchy
3. **ColumnMappingBuilder** - Maps entity properties to column definitions
4. **CollectionTableBuilder** - Recursively processes collections
5. **ReferenceResolver** - Identifies and maps foreign key relationships
6. **SqlTypeMapper** - Assigns database-specific SQL types

### DMS Runtime Consumption
- DMS reads flatteningMetadata at startup via ResourceSchema.cs
- C# CLI tool uses metadata to generate DDL scripts
- Runtime flattening uses metadata for document processing

## Open Design Questions

1. **Name Length Handling**: Handle hash-truncation here or downstream?
2. **Table DB Schemas**: Should flattened tables be in the schema of their project like ODS/API (e.g. edfi.Student) or table name prefixed (e.g. dms.edfi_Student)? I am wondering if in DMS world we should avoid using up schemas by prefixing. It would close off any future opportunity to have multiple DMS instances in the same database. It also just seems awkward to put them in different namespaces when DMS only has a few tables and every flattened table will be referencing them. If we were starting from scratch and didn't have the ODS/API as an example, I don't think a separate schema design would have occurred to me.
