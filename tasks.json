[
  {
    "category": "Contracts",
    "description": "Redesign the trigger inventory contract to be unambiguous and key-unification-ready. Replace the overloaded `DbTriggerInfo.Table`/`TargetTable` semantics with an explicit `TriggerTable` (table the trigger is created on / fires on). Add a propagation-specific payload for `DbTriggerKind.IdentityPropagationFallback` that supports the chosen strategy: one trigger per referenced table, fan-out to many referrers. Acceptance: (1) `DbTriggerInfo` (or derived trigger records) can represent propagation intent without reusing `KeyColumns`/`IdentityProjectionColumns`; (2) propagation intent includes explicit referrer table + referencing `..._DocumentId` + referenced `DocumentId` + ordered identity column pairs `(referrer_storage_column, referenced_storage_column)`; (3) XML docs state `IdentityProjectionColumns` are a null-safe value-diff compare set (not `UPDATE(column)` gating); (4) all consumers compile (derivation, shortening, DDL emitter, golden manifest writer/tests).",
    "steps-to-verify": [
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Trigger Inventory",
    "description": "Fix root identity-projection column derivation so stamping + referential-identity maintenance can detect identity changes correctly (and later work under unified aliases). Update `DeriveTriggerInventoryPass` so root `IdentityProjectionColumns` includes: (a) root scalar identity columns bound to `identityJsonPaths`, and (b) for every `DocumentReferenceBinding` with `IsIdentityComponent == true`, the locally stored reference identity-part columns (`IdentityBindings[*].Column`) instead of (or in addition to) the stable `..._DocumentId`. Acceptance: (1) root `DocumentStamping` triggers and `ReferentialIdentityMaintenance` triggers include propagated identity-part columns for identity-component references; (2) column set is deterministic and de-duplicated; (3) behavior is documented as value-diff based (not “updated column” based).",
    "steps-to-verify": [
      "Update/add unit tests in `src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs` asserting identity projection includes propagated identity columns for identity-component references.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Propagation Fallback",
    "description": "Rework MSSQL identity-propagation fallback derivation to match the locked decisions and key-unification requirements. Emit propagation fallback triggers on MSSQL only, as **one trigger per referenced table** (root or abstract identity table) that updates all referrers. Triggers must be modeled as firing on the referenced table and updating referrer tables’ **storage** columns (canonical under key unification; never alias/binding columns). Coverage must include reference sites on root, child/collection, and `_ext` tables (not root-only). Acceptance: (1) triggers are created on the referenced table (`TriggerTable`), not the referrer; (2) the propagation payload includes every eligible incoming edge where the referenced target is abstract or allows identity updates; (3) propagated columns are storage-mapped via `DbColumnModel.Storage` and de-duplicated deterministically; (4) no propagation triggers are emitted on PostgreSQL; (5) unit tests cover concrete + abstract targets and non-root referrers.",
    "steps-to-verify": [
      "Update unit tests in `src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs` to assert propagation triggers fire on the referenced table and contain referrer actions (and remove assertions that lock in the current inversion).",
      "Add/extend a fixture with a non-root reference binding (child or extension) and assert it appears in the propagation trigger’s fan-out list on MSSQL.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Identifier Shortening",
    "description": "Update dialect identifier shortening + uniqueness validation for the new trigger contract shape. Ensure `ApplyDialectIdentifierShorteningPass` shortens all newly introduced trigger fields (trigger table, referrer table, FK columns, and column pairs) deterministically. Ensure `RelationalModelSetBuilderContext` ordering and uniqueness checks use `TriggerTable` (not the old `Table` field) and still respect dialect scoping rules (Pgsql table-scoped trigger-name uniqueness; MSSQL schema-scoped). Acceptance: (1) shortening applies to every trigger identifier field; (2) determinism tests still pass; (3) name-collision detection remains correct for both dialects.",
    "steps-to-verify": [
      "Update/extend `src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DialectIdentifierShorteningTests.cs` to validate shortening covers the new trigger fields (including propagation payload fields).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "DDL Emission",
    "description": "Update `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/RelationalModelDdlEmitter.cs` to consume the redesigned trigger inventory contract. `CREATE TRIGGER ... ON ...` must use the explicit `TriggerTable`. Propagation triggers may continue to emit a placeholder body for now, but the emitted SQL must reference the correct owning table and produce deterministic trigger statements for both dialects. Acceptance: DDL emission compiles, emits triggers on the correct tables for all trigger kinds, and remains deterministic across runs.",
    "steps-to-verify": [
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj` (covers DDL identifier quoting and related invariants).",
      "If DDL golden outputs exist for triggers, update them to reflect `TriggerTable` semantics and verify diffs are only the intended structural changes."
    ],
    "completed": false
  },
  {
    "category": "Index Inventory",
    "description": "Confirm index derivation remains compatible with key unification without adding filtered/partial index modeling. Ensure FK-support index derivation continues to operate over the final FK column lists (which must be storage columns after key unification mapping) and add an invariant check that no FK constraint references a unified alias/binding column. Acceptance: (1) no changes add filtered/partial index representations to `DbIndexInfo`; (2) a fail-fast invariant prevents FKs over `UnifiedAlias` columns once key unification lands; (3) unit tests cover a key-unification scenario where multiple binding endpoints map to one storage column and FK/index derivation remains deterministic and collision-free.",
    "steps-to-verify": [
      "Add a unit fixture (post key-unification implementation) that unifies at least one identity-part column and assert FK constraints are emitted only over storage columns and `DeriveIndexInventoryPass` derives FK-support indexes using those storage columns.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Docs",
    "description": "Align design docs and story text to the locked decisions and the updated contract. Update: `reference/design/backend-redesign/design-docs/key-unification.md`, `reference/design/backend-redesign/design-docs/transactions-and-concurrency.md`, and `reference/design/backend-redesign/epics/01-relational-model/07-index-and-trigger-inventory.md` to reflect: MSSQL always uses `ON UPDATE NO ACTION` + trigger-based propagation fallback; propagation triggers are one-per-referenced-table and fire on the referenced table; propagation updates canonical/storage columns only; `IdentityProjectionColumns` are value-diff compare sets; and pass naming matches implementation (`DeriveIndexInventoryPass` + `DeriveTriggerInventoryPass`). Acceptance: docs describe the same strategy implemented in code and do not reference filtered/partial index inventory modeling for this workstream.",
    "steps-to-verify": [
      "Run: `rg -n \"ON UPDATE CASCADE|fallback|PropagateIdentity|IdentityProjectionColumns\" reference/design/backend-redesign/design-docs/key-unification.md reference/design/backend-redesign/design-docs/transactions-and-concurrency.md reference/design/backend-redesign/epics/01-relational-model/07-index-and-trigger-inventory.md` and confirm wording matches the locked decisions.",
      "Manual review: confirm docs no longer imply “try cascade then fallback” on MSSQL for this implementation."
    ],
    "completed": false
  },
  {
    "category": "Query Planning",
    "description": "Implement the locked decision for unified-alias predicate rewrite so canonical storage indexes stay effective. When a query predicate binds to a unified alias column, rewrite it to an equivalent predicate on the canonical storage column plus presence gating (`PresenceColumn IS NOT NULL`) when applicable. Acceptance: (1) semantics are preserved for optional references/paths (filtering on a per-path alias still implies the path was present); (2) rewritten SQL targets the canonical column so FK-supporting indexes can be used; (3) tests cover both reference-site presence gating (via `..._DocumentId`) and synthetic presence gating (via `..._Present`) once key unification is implemented.",
    "steps-to-verify": [
      "Locate the query compilation component that emits SQL predicates for relational storage and add unit tests for predicate rewrite under key unification.",
      "Run the relevant unit-test project(s) for query compilation once identified (and keep `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln` green)."
    ],
    "completed": false
  }
]

