[
  {
    "category": "Robustness",
    "description": "Fail fast on duplicate reference identity bindings instead of selecting a winner. `BuildReferenceIdentityColumns` currently de-dupes duplicate mappings by selecting the lexicographically smaller path/column, which can silently mask upstream ApiSchema issues. Acceptance: (1) If `documentPathsMapping.referenceJsonPaths` contains duplicate identityJsonPath entries for a single reference mapping, fail fast with an actionable message; (2) If derived `DocumentReferenceBinding.IdentityBindings` contains duplicates for the same referenceJsonPath, fail fast; (3) Add unit tests for these fail-fast conditions; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Update `ConstraintDerivationRelationalModelSetPass.BuildReferenceIdentityColumns` to throw on duplicates rather than selecting the smallest by string comparison.",
      "Add unit tests constructing ApiSchema fixtures with duplicate referenceJsonPaths entries and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Confirm whether the abstract-target `hasCompleteIdentity` branch is dead. In `ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraintsForResource`, `hasCompleteIdentity` is computed from `BuildReferenceIdentityColumns(...)` but `BuildReferenceIdentityColumns` currently throws when any target identity path is missing, which likely makes the `if (targetInfo.IsAbstract && !hasCompleteIdentity) continue;` path unreachable. Acceptance: (1) Prove via unit test(s) or reasoning + code change that this branch is unreachable; (2) If dead, remove the branch and simplify logic; (3) If not dead, add a unit test that exercises it and document why abstract targets are allowed to be partially mapped.",
    "steps-to-verify": [
      "Add or update a unit test that attempts to build an abstract reference with missing identity mapping and verify whether it throws before reaching the `hasCompleteIdentity` gate.",
      "If unreachable, remove the `hasCompleteIdentity` calculation and the `continue` branch; otherwise add test coverage and inline comment explaining the intended partial-mapping behavior.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Remove duplicated logic in relational model derivation: (1) scalar type resolution is duplicated verbatim in `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`; (2) canonical table ordering logic is duplicated between `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass`. Acceptance: (1) Extract shared helpers (e.g., `RelationalScalarTypeResolver` and `RelationalModelOrdering`) and replace duplicate implementations; (2) Ensure behavior is unchanged by covering both code paths with existing/new unit tests; (3) All unit tests pass.",
    "steps-to-verify": [
      "Extract scalar-type resolution helpers into a shared type and use it from both `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`.",
      "Extract table/constraint canonical ordering helpers and use it from both `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass` (or remove the local copy and call the canonical implementation).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Docs",
    "description": "Add a DMS-930 \u2192 DMS-931 naming handoff note to `reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md`. This should document what DMS-930 already implemented, what is intentionally provisional/placeholder behavior, and what remains for DMS-931 so future work doesn\u2019t accidentally rely on pre-naming identifiers. Acceptance: (1) The doc includes a clearly labeled section (e.g., \u201cHandoff from DMS-930\u201d) describing: current provisional identifier generation in DMS-930 (constraint/index/column/table names may exceed dialect limits), current placeholder `relational.nameOverrides` behavior (reference-only / fail-fast on non-reference keys), and current shortening behavior (collision detection exists but identifiers are not rewritten); (2) the doc lists the DMS-931 responsibilities: apply naming rules, apply full overrides, apply dialect shortening into the model, and ensure collisions are detected after rewriting; (3) the section references the relevant implementation passes/classes by name; (4) content is specific enough for a new contributor to understand the boundary between stories.",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md` to add a handoff section describing DMS-930 naming placeholders and DMS-931 responsibilities.",
      "Verify the doc references the relevant code locations (passes and key helpers) accurately and uses concrete examples (e.g., `UX_{table}_{col1}_{col2}_...` naming and dialect shortening limits)."
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Extract shared extension-resolution boilerplate from passes into a single helper. The 'resolve resource extension to base resource' pattern (BuildBaseResourceLookup → TryGetValue → count-check → error message) is copy-pasted in ReferenceBindingRelationalModelSetPass.Execute (lines 59-98), ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints (lines 116-158), and ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints (lines 231-267). If the matching logic or error wording changes, all three must be updated in lockstep. Acceptance: (1) A shared method (e.g., ResolveBaseResourceForExtension) exists in RelationalModelSetSchemaHelpers that takes a resource extension context and the base resource lookup and returns the single matching base entry, throwing on zero or multiple matches with the same error messages as today; (2) All three call sites use the shared method; (3) No private copies of the matching/error logic remain in individual pass files; (4) All unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Add ResolveBaseResourceForExtension<TEntry> to RelationalModelSetSchemaHelpers that accepts resourceName, resource (for error formatting), and the base resource lookup, returning the single TEntry.",
      "Replace the inline logic in ReferenceBindingRelationalModelSetPass.Execute with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints with a call to the shared helper.",
      "Grep pass files to confirm no private copies remain: grep -n 'baseEntries.Count != 1' src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/*Pass.cs",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": false
  },
  {
    "category": "Maintainability",
    "description": "Split ConstraintDerivationRelationalModelSetPass into focused passes. At ~1,625 lines, this class houses three independent concerns: (A) root identity unique constraints, (B) reference FK + all-or-none constraints, (C) array uniqueness constraints. Each sub-pass independently rebuilds resourcesByKey, baseResourcesByName, apiSchemaRootsByProjectEndpoint, and builderContextsByResource dictionaries. The ApplyReferenceConstraintsForResource method takes 11 parameters. Acceptance: (1) The class is split into 2-3 separate IRelationalModelSetPass implementations (e.g., RootIdentityConstraintPass, ReferenceConstraintPass, ArrayUniquenessConstraintPass — or at minimum separate the reference constraint logic from root/array); (2) Each new pass is registered in RelationalModelSetPasses.CreateDefault() in the correct order (root constraints before reference constraints before array uniqueness); (3) The ApplyReferenceConstraintsForResource 11-parameter signature is reduced by introducing a context record that bundles the shared lookup state; (4) All 194 unit tests pass with no behavioral change; (5) The authoritative golden test output is byte-identical.",
    "steps-to-verify": [
      "Extract root identity constraint derivation into its own IRelationalModelSetPass (or keep inline if trivial).",
      "Extract reference FK + all-or-none constraint derivation into its own IRelationalModelSetPass with a bundled context record replacing the 11-parameter method.",
      "Extract array uniqueness constraint derivation into its own IRelationalModelSetPass.",
      "Register new passes in RelationalModelSetPasses.CreateDefault() in correct order.",
      "Verify ApplyReferenceConstraintsForResource (or equivalent) parameter count is ≤ 5.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj",
      "Diff authoritative golden test output to confirm byte-identical results."
    ],
    "completed": false
  },
  {
    "category": "Correctness",
    "description": "Fix swallowed exception in TryResolveArrayUniquenessTable to preserve all failure diagnostics. In ConstraintDerivationRelationalModelSetPass.TryResolveArrayUniquenessTable (lines 530-548), when iterating candidates, failures from BuildArrayUniquenessColumns are caught and assigned to the 'failure' out parameter, but only the last failure is preserved — earlier diagnostic information is silently discarded. When zero candidates match (line 572, returns false) and the aligned-scope fallback also fails, the caller at line 410 throws the failure from the aligned attempt rather than the original, producing misleading diagnostics. Acceptance: (1) All candidate failures are collected (e.g., in a List<Exception>); (2) When no candidate matches, the out failure is an AggregateException (or a single exception with all candidate error messages concatenated) so no diagnostic context is lost; (3) The caller at line 410 prefers the original-scope failure over the aligned-scope failure when both fail (or includes both); (4) Unit test: construct a fixture where two candidates exist for the same scope and both fail with different errors — assert the thrown exception message contains diagnostic info from both failures; (5) All existing 194 unit tests pass.",
    "steps-to-verify": [
      "Change TryResolveArrayUniquenessTable to collect all candidate failures in a List<Exception> instead of overwriting a single 'failure' variable.",
      "When returning false with failures, set the out parameter to an AggregateException containing all collected failures (or a single exception with concatenated messages if only one).",
      "Update the caller in ApplyArrayUniquenessConstraint (around line 410) to prefer the original-scope failure when both original and aligned attempts fail, or wrap both in an AggregateException.",
      "Add a unit test with two candidates at the same scope that both fail for different reasons and assert the exception contains both error messages.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": false
  },
  {
    "category": "Determinism",
    "description": "Make array uniqueness constraint derivation independent of dictionary enumeration order. `ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraint` iterates `pathsByScope` (a Dictionary) directly, which can vary by runtime and violates the design rule that derivation must not depend on dictionary iteration order. Acceptance: (1) Scope groups are processed in `StringComparer.Ordinal` sorted order by canonical scope string; (2) When multiple scopes exist, derived constraints and thrown diagnostics are stable across runs; (3) No behavioral change to which tables/columns receive constraints; (4) All unit tests (including determinism/golden tests) pass.",
    "steps-to-verify": [
      "Update `ApplyArrayUniquenessConstraint` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to iterate `pathsByScope` in sorted order (e.g., `OrderBy(kvp => kvp.Key, StringComparer.Ordinal)`).",
      "If any exception messages include multiple scopes, ensure the scope list is emitted in sorted order for deterministic diagnostics.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Correctness",
    "description": "Remove nondeterministic `group.First()` selection when mapping identityJsonPaths to columns. `ConstraintDerivationRelationalModelSetPass.BuildRootIdentityColumns` and `BuildIdentityValueColumns` build a `SourceJsonPath -> ColumnName` map using `GroupBy(...).ToDictionary(... group => group.First().ColumnName)`, which becomes order-dependent if duplicates ever occur. Acceptance: (1) SourceJsonPath-to-column resolution is deterministic (e.g., select `OrderBy(ColumnName).First()`) and/or fails fast when a single JSONPath maps to multiple columns; (2) If failing fast, the error message includes resource, table, canonical path, and colliding column names; (3) Add a targeted unit test that constructs a table with duplicate `SourceJsonPath` values and asserts the deterministic selection or fail-fast behavior; (4) All unit tests pass.",
    "steps-to-verify": [
      "Introduce a shared helper (prefer `internal` so it can be unit tested) for building a deterministic `SourceJsonPath -> DbColumnName` lookup from a `DbTableModel`.",
      "Update `BuildRootIdentityColumns` and `BuildIdentityValueColumns` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to use the helper instead of `group.First()`.",
      "Add a unit test that creates a `DbTableModel` with two columns sharing the same `SourceJsonPath` and asserts the new deterministic behavior (or fail-fast message).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Performance",
    "description": "Share/cached per-resource `ExtractInputsStep` output across set-level passes and avoid repeated descriptor inference. Multiple set-level passes build their own `RelationalModelBuilderContext` caches and `RelationalModelSetSchemaHelpers.BuildResourceContext` runs `ExtractInputsStep` with default `DescriptorPathSource.InferFromSchema`, which can redo descriptor inference even though `RelationalModelSetBuilderContext` already computed descriptor path maps. Acceptance: (1) `RelationalModelSetBuilderContext` provides a shared `GetOrCreateResourceBuilderContext` cache keyed by `QualifiedResourceName`; (2) All passes use the shared cache (no per-pass duplicate `ExtractInputsStep` work); (3) Cached builder contexts used by passes are configured with `DescriptorPathSource.Precomputed` and `DescriptorPathsByJsonPath` populated from the set-level descriptor path map; (4) No behavior change; (5) All unit tests pass and `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln` succeeds.",
    "steps-to-verify": [
      "Add a `Dictionary<QualifiedResourceName, RelationalModelBuilderContext>` cache and `GetOrCreateResourceBuilderContext(...)` method to `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/RelationalModelSetBuilderContext.cs`.",
      "Ensure `GetOrCreateResourceBuilderContext(...)` sets `DescriptorPathSource=Precomputed` and provides `DescriptorPathsByJsonPath` from `RelationalModelSetBuilderContext.GetAllDescriptorPathsForResource(...)` before executing `ExtractInputsStep`.",
      "Refactor set-level passes that currently build local `builderContextsByResource` (e.g., `ReferenceBindingRelationalModelSetPass`, `ConstraintDerivationRelationalModelSetPass`, and any `BuildResourceContext` call sites) to use the shared cache.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": false
  },
  {
    "category": "Design",
    "description": "Reconcile default set-level pass ordering with the DMS-1033 design doc. `RelationalModelSetPasses.CreateDefault()` currently runs abstract identity table derivation before reference binding/constraint derivation, but `reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` suggests references/constraints before abstract artifacts. Acceptance: Update the design doc pass-order section to match the implemented dependency (with rationale)",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` to match the chosen pass order (and explain the dependency if abstract identity must precede reference constraints)."
    ],
    "completed": false
  }
]
