[
  {
    "category": "Robustness",
    "description": "Remove fallback levels 3-4 from ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraint (lines 336-468). Analysis: Level 1 (direct scope match) handles the standard case where constraint scope matches table JsonScope directly. Level 2 (strip _ext.{project} prefix) is required for the cross-boundary nested constraint pattern \u2014 e.g. the contacts extension has basePath=$._ext.sample.addresses[*] with paths=[$.periods[*].beginDate], which resolves to scope $._ext.sample.addresses[*].periods[*], but the actual table is the base ContactAddressPeriod with scope $.addresses[*].periods[*]; stripping _ext.sample makes this match. Levels 3-4 (brute-force scan across ALL tables) are not exercised by any real Ed-Fi schema (ds-5.2 or sample). They catch InvalidOperationException per-candidate and silently continue, meaning if a table happens to have columns with matching names at the wrong scope, the constraint lands on the wrong table \u2014 violating the story AC 'no silent omissions'. Recommendation: Remove levels 3-4 and fail fast after level 2 with a diagnostic error citing the unmatched scope. Add a code comment on level 2 documenting the cross-boundary pattern it handles.",
    "steps-to-verify": [
      "Remove the two TryResolveArrayUniquenessTable brute-force blocks (levels 3-4, approx lines 400-443) from ApplyArrayUniquenessConstraint.",
      "After level 2 fails, throw immediately with a diagnostic message citing the unmatched scope.",
      "Add a code comment on level 2 explaining the cross-boundary extension constraint pattern (contacts/addresses/periods example).",
      "Verify all existing tests still pass \u2014 no real schema exercises levels 3-4.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Remove the redundant Order property from IRelationalModelSetPass and all pass implementations. The canonical pass ordering is already determined by array position in RelationalModelSetPasses.CreatePasses(). The Order property is a second source of truth that can get out of sync. Acceptance: (1) Order property removed from the interface and all implementations; (2) no ordering validation needed since array position IS the order; (3) all unit tests pass.",
    "steps-to-verify": [
      "Remove Order from IRelationalModelSetPass interface.",
      "Remove Order property from all pass implementations (BaseTraversalAndDescriptorBindingRelationalModelSetPass, ExtensionTableDerivationRelationalModelSetPass, AbstractIdentityTableDerivationRelationalModelSetPass, ReferenceBindingRelationalModelSetPass, ConstraintDerivationRelationalModelSetPass).",
      "Remove any references to Order in pipeline runner or tests.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "Cache GetAllDescriptorPathsForResource in RelationalModelSetBuilderContext. The method builds a merged dictionary from base + extension descriptor paths on every call. During constraint derivation this may be called repeatedly for the same resource. Acceptance: (1) The merged result is cached per resource (similar to GetOrCreateBuilderContext); (2) no behavioral change \u2014 all unit tests pass; (3) cache is lazily populated and not invalidated (descriptor paths are immutable after extraction).",
    "steps-to-verify": [
      "Add a Dictionary<QualifiedResourceName, ...> cache field in RelationalModelSetBuilderContext and populate it lazily in GetAllDescriptorPathsForResource.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Standardize string comparison to Ordinal. ExtensionTableDerivationRelationalModelSetPass uses StringComparison.OrdinalIgnoreCase in some places but StringComparer.Ordinal elsewhere. The design docs specify PascalCase naming, so case-insensitive comparison could mask naming bugs (e.g., accepting 'school' where 'School' is expected). Acceptance: (1) All string comparisons in the relational model derivation passes use StringComparer.Ordinal / StringComparison.Ordinal unless there is a documented reason for case-insensitivity; (2) any intentional case-insensitive comparisons are annotated with a comment explaining why; (3) all unit tests pass.",
    "steps-to-verify": [
      "Grep for OrdinalIgnoreCase in all relational model pass files and evaluate each usage.",
      "Replace with Ordinal or add justification comment for each.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Move column collision detection from Build() to AddColumn() time in TableBuilder and ExtensionTableBuilder. Currently duplicate columns are only detected when Build() is called, meaning the error is reported far from the code that introduced the duplicate. Acceptance: (1) AddColumn (or equivalent) throws immediately when a duplicate column name is added, with context about the conflicting source; (2) Build() no longer needs separate collision detection; (3) all unit tests pass.",
    "steps-to-verify": [
      "Update AddColumn in both TableBuilder and ExtensionTableBuilder to throw on duplicate column names at insertion time.",
      "Remove redundant collision checks from Build().",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "Add identity nullability guardrails. Identity components (identityJsonPaths) should not map to nullable columns, otherwise the root UNIQUE constraint can be weakened by NULL semantics. For reference-sourced identity components, enforce that the reference is required (isRequired=true) so the corresponding `..._DocumentId` FK column is NOT NULL. Acceptance: (1) If an identityJsonPath maps to a nullable scalar/descriptor column, fail fast with an actionable error; (2) If a document reference contributes to identity but isRequired=false, fail fast; (3) Add unit tests proving these fail-fast rules; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Add/extend unit tests that define an identityJsonPath on an optional (or x-nullable) scalar property and assert compilation fails with a clear message.",
      "Add/extend unit tests that define a reference identity component (isPartOfIdentity=true) with isRequired=false and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Fail fast on duplicate reference identity bindings instead of selecting a winner. `BuildReferenceIdentityColumns` currently de-dupes duplicate mappings by selecting the lexicographically smaller path/column, which can silently mask upstream ApiSchema issues. Acceptance: (1) If `documentPathsMapping.referenceJsonPaths` contains duplicate identityJsonPath entries for a single reference mapping, fail fast with an actionable message; (2) If derived `DocumentReferenceBinding.IdentityBindings` contains duplicates for the same referenceJsonPath, fail fast; (3) Add unit tests for these fail-fast conditions; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Update `ConstraintDerivationRelationalModelSetPass.BuildReferenceIdentityColumns` to throw on duplicates rather than selecting the smallest by string comparison.",
      "Add unit tests constructing ApiSchema fixtures with duplicate referenceJsonPaths entries and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Confirm whether the abstract-target `hasCompleteIdentity` branch is dead. In `ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraintsForResource`, `hasCompleteIdentity` is computed from `BuildReferenceIdentityColumns(...)` but `BuildReferenceIdentityColumns` currently throws when any target identity path is missing, which likely makes the `if (targetInfo.IsAbstract && !hasCompleteIdentity) continue;` path unreachable. Acceptance: (1) Prove via unit test(s) or reasoning + code change that this branch is unreachable; (2) If dead, remove the branch and simplify logic; (3) If not dead, add a unit test that exercises it and document why abstract targets are allowed to be partially mapped.",
    "steps-to-verify": [
      "Add or update a unit test that attempts to build an abstract reference with missing identity mapping and verify whether it throws before reaching the `hasCompleteIdentity` gate.",
      "If unreachable, remove the `hasCompleteIdentity` calculation and the `continue` branch; otherwise add test coverage and inline comment explaining the intended partial-mapping behavior.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Remove duplicated logic in relational model derivation: (1) scalar type resolution is duplicated verbatim in `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`; (2) canonical table ordering logic is duplicated between `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass`. Acceptance: (1) Extract shared helpers (e.g., `RelationalScalarTypeResolver` and `RelationalModelOrdering`) and replace duplicate implementations; (2) Ensure behavior is unchanged by covering both code paths with existing/new unit tests; (3) All unit tests pass.",
    "steps-to-verify": [
      "Extract scalar-type resolution helpers into a shared type and use it from both `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`.",
      "Extract table/constraint canonical ordering helpers and use it from both `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass` (or remove the local copy and call the canonical implementation).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "Extract duplicated helper methods shared across passes into RelationalModelSetSchemaHelpers. The following methods are copy-pasted nearly verbatim across ReferenceBindingRelationalModelSetPass, ConstraintDerivationRelationalModelSetPass, ExtensionTableDerivationRelationalModelSetPass, and AbstractIdentityTableDerivationRelationalModelSetPass: IsResourceExtension(), GetApiSchemaRoot(), BuildBaseResourceLookup(), BuildResourceContext()/GetOrCreateBuilderContext(). Acceptance: (1) Each helper exists in exactly one location (RelationalModelSetSchemaHelpers or a new shared class); (2) All four passes call the shared implementation; (3) No private copies of these methods remain in individual pass files; (4) All 184 unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Move IsResourceExtension to RelationalModelSetSchemaHelpers and update all four pass files to use it.",
      "Move GetApiSchemaRoot to RelationalModelSetSchemaHelpers and update all callers.",
      "Move BuildBaseResourceLookup to RelationalModelSetSchemaHelpers and update all callers.",
      "Move BuildResourceContext / GetOrCreateBuilderContext to a shared location and update all callers.",
      "Grep the pass files to confirm no private copies remain: `grep -n 'IsResourceExtension\\|GetApiSchemaRoot\\|BuildBaseResourceLookup' src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/*Pass.cs`",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "Consolidate ConstraintDerivationRelationalModelSetPass.TableBuilder with the shared TableColumnAccumulator. ConstraintDerivationRelationalModelSetPass contains a private TableBuilder class (lines 1731-1791) that duplicates column-collision detection and constraint accumulation from the shared TableColumnAccumulator. Meanwhile ReferenceBindingRelationalModelSetPass uses TableColumnAccumulator directly. Acceptance: (1) The private TableBuilder is removed from ConstraintDerivationRelationalModelSetPass; (2) ResourceMutation wraps TableColumnAccumulator instead; (3) Column-collision detection logic exists in exactly one place; (4) All unit tests pass.",
    "steps-to-verify": [
      "Replace private TableBuilder in ConstraintDerivationRelationalModelSetPass with TableColumnAccumulator.",
      "Update ResourceMutation to use TableColumnAccumulator in its Dictionary<TableKey, ...>.",
      "Verify no private TableBuilder class remains in ConstraintDerivationRelationalModelSetPass.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "AbstractIdentityTableDerivationRelationalModelSetPass contains its own copy of scalar type resolution (ResolveScalarType, ResolveStringType, BuildStringType, ResolveIntegerType, ResolveDecimalType at lines 660-775) that duplicates the shared RelationalScalarTypeResolver added in this branch. Acceptance: (1) The private scalar resolution methods are removed from AbstractIdentityTableDerivationRelationalModelSetPass; (2) The pass uses RelationalScalarTypeResolver.ResolveScalarType instead; (3) If RelationalScalarTypeResolver needs a minor signature adjustment to accept ConcreteResourceMetadata's decimal infos, that is acceptable; (4) All unit tests pass.",
    "steps-to-verify": [
      "Remove ResolveScalarType, ResolveStringType, BuildStringType, ResolveIntegerType, ResolveDecimalType from AbstractIdentityTableDerivationRelationalModelSetPass.",
      "Update ResolveColumnSignature to call RelationalScalarTypeResolver.ResolveScalarType.",
      "Adjust RelationalScalarTypeResolver if needed to accept the decimal property validation infos from ConcreteResourceMetadata.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "Extract duplicated ResolveSchemaForPath JSON schema traversal. Both ReferenceBindingRelationalModelSetPass (lines 462-566) and AbstractIdentityTableDerivationRelationalModelSetPass (lines 369-468) contain nearly identical ResolveSchemaForPath methods that walk a JSON schema by path segments. Acceptance: (1) A single shared ResolveSchemaForPath exists (e.g., in RelationalModelSetSchemaHelpers or a new JsonSchemaNavigation utility); (2) Both passes call the shared method; (3) Error messages remain resource-specific (the shared method should accept a resource name for diagnostics); (4) All unit tests pass.",
    "steps-to-verify": [
      "Extract ResolveSchemaForPath to a shared location, parameterized by a resource identifier for error messages.",
      "Update both ReferenceBindingRelationalModelSetPass and AbstractIdentityTableDerivationRelationalModelSetPass to use the shared method.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "ReferenceBindingRelationalModelSetPass.BuildResourceContext creates a new RelationalModelBuilderContext and runs ExtractInputsStep().Execute() for every resource without caching. ConstraintDerivationRelationalModelSetPass correctly caches via GetOrCreateBuilderContext. Apply the same caching pattern to ReferenceBindingRelationalModelSetPass. Acceptance: (1) ReferenceBindingRelationalModelSetPass caches builder contexts per resource (identical to ConstraintDerivationRelationalModelSetPass.GetOrCreateBuilderContext pattern); (2) ExtractInputsStep is executed at most once per resource across the pass; (3) All unit tests pass.",
    "steps-to-verify": [
      "Add a Dictionary<QualifiedResourceName, RelationalModelBuilderContext> cache to the Execute method in ReferenceBindingRelationalModelSetPass.",
      "Replace direct BuildResourceContext calls with a GetOrCreateBuilderContext pattern.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Design",
    "description": "Investigate and document whether TablesInWriteDependencyOrder should differ from TablesInReadDependencyOrder. Both ReferenceBindingRelationalModelSetPass (line 286-288) and ConstraintDerivationRelationalModelSetPass (line 838-839) always set TablesInWriteDependencyOrder = TablesInReadDependencyOrder (same array). If they are always identical, remove TablesInWriteDependencyOrder from RelationalResourceModel to eliminate redundant state. If they are intended to diverge in a future story, add a code comment documenting the intent. Acceptance: (1) Either TablesInWriteDependencyOrder is removed (if always identical), OR a code comment on RelationalResourceModel documents when and why it will diverge; (2) No behavioral change; (3) All unit tests pass.",
    "steps-to-verify": [
      "Search all assignments to TablesInWriteDependencyOrder to confirm it always equals TablesInReadDependencyOrder.",
      "If always identical: remove TablesInWriteDependencyOrder from RelationalResourceModel and update all callers to use TablesInReadDependencyOrder.",
      "If future divergence planned: add a doc comment on the property explaining the planned distinction.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "ResolveOwningTableBuilder in ReferenceBindingRelationalModelSetPass silently picks the lexicographically-first scope when two table scopes match at the same segment depth (lines 334-341). This tiebreaking could mask genuine ambiguity (e.g., extension vs base table at same depth). Change to throw on ambiguous matches. Acceptance: (1) When two scopes match the reference path with the same segment count, the method throws an InvalidOperationException listing both candidates; (2) If there is a legitimate scenario requiring tiebreaking, document it with a comment and add a unit test; (3) All existing unit tests pass (confirming the ambiguous case does not occur in practice).",
    "steps-to-verify": [
      "Replace the tiebreak logic (lines 334-341) with a throw listing both candidate scopes.",
      "Run existing tests to confirm no legitimate ambiguity exists: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "If a test fails, investigate whether the tiebreak is needed and document it."
    ],
    "completed": true
  },
  {
    "category": "Tests",
    "description": "Add targeted unit tests for extension array uniqueness constraint alignment. The TryStripExtensionRootPrefix/StripExtensionRootPrefix fallback path in ConstraintDerivationRelationalModelSetPass (lines 371-396) handles extension schemas declaring array uniqueness under _ext.{project} when the owning table is in the base scope. This is only tested indirectly through golden tests. Acceptance: (1) A focused unit test creates a resource extension with arrayUniquenessConstraints scoped under _ext.{project} that must align to a base-scope table; (2) The test asserts the correct UNIQUE constraint appears on the correct base-scope child table; (3) A second test asserts that when alignment fails (no matching base table), the pass throws with a diagnostic message.",
    "steps-to-verify": [
      "Add tests in ConstraintDerivationRelationalModelSetPassTests.cs for the extension-to-base scope alignment path.",
      "One test: valid alignment produces correct UX constraint on the base child table.",
      "One test: invalid alignment (no matching base table) throws with diagnostic scope info.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Tests",
    "description": "Add unit tests for nested ArrayUniquenessConstraintInput recursion. The ArrayUniquenessConstraintInput record supports NestedConstraints, and ApplyArrayUniquenessConstraint handles them recursively (lines 409-421). There is no targeted test for multi-level nested collection uniqueness derivation. Acceptance: (1) A unit test builds a resource with a 2-level nested collection (e.g., addresses[*].periods[*]) where both levels have uniqueness constraints; (2) The test asserts both the parent and nested child tables receive the correct UNIQUE constraints; (3) Column ordering in each constraint is deterministic and matches the expected parent-key-parts + constraint-paths order.",
    "steps-to-verify": [
      "Add a test in ConstraintDerivationRelationalModelSetPassTests.cs with a fixture containing nested arrayUniquenessConstraints.",
      "Assert the parent collection table has a UX constraint with expected columns.",
      "Assert the nested child table has a UX constraint with expected columns (including parent ordinal).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "AbstractIdentityTableDerivationRelationalModelSetPass.BuildConcreteMetadata eagerly builds metadata (including JsonSchemaForInsert, DecimalPropertyValidationInfos, full RelationalResourceModel) for every concrete resource, even though only subclass members are used during identity column derivation. Acceptance: (1) Metadata is built lazily \u2014 only for resources that are actually members of an abstract resource; (2) Non-subclass resources do not have their JsonSchemaForInsert parsed or DecimalPropertyValidationInfos extracted; (3) All unit tests pass; (4) Behavior is unchanged for subclass resources.",
    "steps-to-verify": [
      "Refactor BuildConcreteMetadata to only build full metadata for resources where isSubclass=true, or switch to lazy resolution during BuildIdentityColumns.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Design",
    "description": "Update backend redesign design docs to state composite foreign keys for document references only use `ON UPDATE CASCADE` when the referenced target resource has `allowIdentityUpdates=true` (otherwise `ON UPDATE NO ACTION`). Align wording in `reference/design/backend-redesign/design-docs/data-model.md`, `reference/design/backend-redesign/design-docs/ddl-generation.md`, and `reference/design/backend-redesign/design-docs/flattening-reconstitution.md` with current behavior in `ConstraintDerivationRelationalModelSetPass`.",
    "steps-to-verify": [
      "Update the reference constraint sections in the listed design docs to describe `allowIdentityUpdates` gating for `ON UPDATE CASCADE` and the non-cascade behavior when it is false.",
      "Run: `rg -n \"ON UPDATE CASCADE\" reference/design/backend-redesign/design-docs` and confirm remaining mentions are conditional or explicitly scoped to `allowIdentityUpdates`-enabled targets.",
      "Sanity check: compare wording against `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` onUpdate selection logic."
    ],
    "completed": true
  },
  {
    "category": "Schema Inputs",
    "description": "Fail fast on unsupported `resourceSchema.relational.nameOverrides` keys and validate override JSONPath grammar. Today `ExtractReferenceNameOverrides` only checks for overrides on bound document reference object paths and silently ignores any other keys. This makes non-reference override keys a silent no-op until DMS-931 is implemented. Acceptance: (1) every key in `relational.nameOverrides` must compile as a valid JSONPath (throw with the invalid key and resource name when it does not); (2) until DMS-931, only document reference object path overrides are supported \u2014 any other override key causes compilation to fail, listing the unsupported keys and identifying the resource; (3) override matching uses canonical JSONPath strings (compile keys to canonical form before comparing) so valid overrides are not missed due to non-canonical input; (4) unit tests cover invalid JSONPath keys, unsupported non-reference keys, and a valid reference override key.",
    "steps-to-verify": [
      "Update `ExtractReferenceNameOverrides` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` to iterate all `relational.nameOverrides` entries, compile each key using `JsonPathExpressionCompiler.Compile`, and throw if the canonical key is not in the derived `referenceObjectPaths` set.",
      "Add tests in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/SchemaInputValidationTests.cs`: (a) invalid JSONPath override key throws; (b) non-reference override key throws and lists the key; (c) valid reference override key does not throw and is applied.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Refactor",
    "description": "Make abstract identity table inventory explicit and structurally consistent with concrete resource tables. Today `AbstractIdentityTableInfo` stores only `(Table, ColumnsInIdentityOrder, Constraints)` and assumes `DocumentId` exists implicitly via constraints. Change the contracts and builder so each abstract identity table is represented as a full `DbTableModel` (or equivalent table model type) that includes `Key` and `Columns`, with `DocumentId` explicitly modeled. Discriminator policy: v1 always includes `Discriminator` as `varchar(256)`/`nvarchar(256)` (`ScalarKind.String`, maxLength 256), NOT NULL, excluded from key/unique/FK columns. Acceptance: (1) `AbstractIdentityTableInfo` exposes a complete table model including `Key` and `Columns`; (2) the abstract identity table has `Key.Columns == [DocumentId]`; (3) `Columns` includes an explicit `DocumentId` `DbColumnModel` with `Kind=ParentKeyPart`, `ScalarKind.Int64`, `IsNullable=false`; (4) `Columns` includes the abstract identity columns in `identityJsonPaths` order, plus `Discriminator` as a trailing column; (5) derived constraints include FK `DocumentId -> dms.Document(DocumentId) ON DELETE CASCADE` and UNIQUE `(DocumentId, <identity columns...>)` with deterministic naming; (6) constraint derivation for abstract reference targets uses the new explicit table model shape to resolve identity columns; (7) golden/authoritative tests and collision detection are updated accordingly; (8) unit tests pass and the DMS solution builds.",
    "steps-to-verify": [
      "Update `./src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs` so `AbstractIdentityTableInfo` carries a full table model (prefer `DbTableModel`).",
      "Update `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/AbstractIdentityTableDerivationRelationalModelSetPass.cs` to build the abstract identity table as a `DbTableModel` with `Key=(DocumentId)` and `Columns` seeded with an explicit `DocumentId` key column (reuse key column conventions from `DeriveTableScopesAndKeysStep`).",
      "Update abstract-target identity resolution in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to read identity paths/columns from the new abstract identity table model shape.",
      "Update collision detection in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/RelationalModelSetBuilderContext.cs` to register columns/constraints from the new abstract identity table model shape.",
      "Update tests in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/AbstractIdentityTableDerivationTests.cs` to assert `DocumentId` is an explicit column and that `Key.Columns` is exactly `[DocumentId]`.",
      "Update golden/authoritative tests that serialize abstract identity tables (e.g., `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetAuthoritativeGoldenTests.cs`) to match the new explicit shape.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Schema Inputs",
    "description": "Fail fast on duplicate `identityJsonPaths` per resource/abstract resource. Today duplicates can slip through extraction, and later unique-constraint derivation de-dupes by column name, masking schema issues. Acceptance: (1) `identityJsonPaths` are compiled to canonical JSONPaths and must be unique per resource schema entry (both `projectSchema.resourceSchemas` and `projectSchema.abstractResources`); duplicates fail compilation with an exception that includes the resource name and the duplicate canonical path(s); (2) duplicate detection happens before any constraint/name generation; (3) unit tests cover duplicate detection for a concrete resource and for an abstract resource identity list; (4) all unit tests pass.",
    "steps-to-verify": [
      "Update `ExtractIdentityJsonPaths` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` to detect duplicate canonical JSONPaths and throw with an actionable message.",
      "Update abstract identity path extraction in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/AbstractIdentityTableDerivationRelationalModelSetPass.cs` to detect duplicate canonical JSONPaths and throw similarly.",
      "Add unit tests (concrete + abstract cases) asserting the fail-fast behavior and the exception message includes the duplicate canonical path(s).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Docs",
    "description": "Add a DMS-930 \u2192 DMS-931 naming handoff note to `reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md`. This should document what DMS-930 already implemented, what is intentionally provisional/placeholder behavior, and what remains for DMS-931 so future work doesn\u2019t accidentally rely on pre-naming identifiers. Acceptance: (1) The doc includes a clearly labeled section (e.g., \u201cHandoff from DMS-930\u201d) describing: current provisional identifier generation in DMS-930 (constraint/index/column/table names may exceed dialect limits), current placeholder `relational.nameOverrides` behavior (reference-only / fail-fast on non-reference keys), and current shortening behavior (collision detection exists but identifiers are not rewritten); (2) the doc lists the DMS-931 responsibilities: apply naming rules, apply full overrides, apply dialect shortening into the model, and ensure collisions are detected after rewriting; (3) the section references the relevant implementation passes/classes by name; (4) content is specific enough for a new contributor to understand the boundary between stories.",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md` to add a handoff section describing DMS-930 naming placeholders and DMS-931 responsibilities.",
      "Verify the doc references the relevant code locations (passes and key helpers) accurately and uses concrete examples (e.g., `UX_{table}_{col1}_{col2}_...` naming and dialect shortening limits)."
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Extract shared extension-resolution boilerplate from passes into a single helper. The 'resolve resource extension to base resource' pattern (BuildBaseResourceLookup → TryGetValue → count-check → error message) is copy-pasted in ReferenceBindingRelationalModelSetPass.Execute (lines 59-98), ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints (lines 116-158), and ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints (lines 231-267). If the matching logic or error wording changes, all three must be updated in lockstep. Acceptance: (1) A shared method (e.g., ResolveBaseResourceForExtension) exists in RelationalModelSetSchemaHelpers that takes a resource extension context and the base resource lookup and returns the single matching base entry, throwing on zero or multiple matches with the same error messages as today; (2) All three call sites use the shared method; (3) No private copies of the matching/error logic remain in individual pass files; (4) All unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Add ResolveBaseResourceForExtension<TEntry> to RelationalModelSetSchemaHelpers that accepts resourceName, resource (for error formatting), and the base resource lookup, returning the single TEntry.",
      "Replace the inline logic in ReferenceBindingRelationalModelSetPass.Execute with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints with a call to the shared helper.",
      "Grep pass files to confirm no private copies remain: grep -n 'baseEntries.Count != 1' src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/*Pass.cs",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": false
  },
  {
    "category": "Maintainability",
    "description": "Split ConstraintDerivationRelationalModelSetPass into focused passes. At ~1,625 lines, this class houses three independent concerns: (A) root identity unique constraints, (B) reference FK + all-or-none constraints, (C) array uniqueness constraints. Each sub-pass independently rebuilds resourcesByKey, baseResourcesByName, apiSchemaRootsByProjectEndpoint, and builderContextsByResource dictionaries. The ApplyReferenceConstraintsForResource method takes 11 parameters. Acceptance: (1) The class is split into 2-3 separate IRelationalModelSetPass implementations (e.g., RootIdentityConstraintPass, ReferenceConstraintPass, ArrayUniquenessConstraintPass — or at minimum separate the reference constraint logic from root/array); (2) Each new pass is registered in RelationalModelSetPasses.CreateDefault() in the correct order (root constraints before reference constraints before array uniqueness); (3) The ApplyReferenceConstraintsForResource 11-parameter signature is reduced by introducing a context record that bundles the shared lookup state; (4) All 194 unit tests pass with no behavioral change; (5) The authoritative golden test output is byte-identical.",
    "steps-to-verify": [
      "Extract root identity constraint derivation into its own IRelationalModelSetPass (or keep inline if trivial).",
      "Extract reference FK + all-or-none constraint derivation into its own IRelationalModelSetPass with a bundled context record replacing the 11-parameter method.",
      "Extract array uniqueness constraint derivation into its own IRelationalModelSetPass.",
      "Register new passes in RelationalModelSetPasses.CreateDefault() in correct order.",
      "Verify ApplyReferenceConstraintsForResource (or equivalent) parameter count is ≤ 5.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj",
      "Diff authoritative golden test output to confirm byte-identical results."
    ],
    "completed": false
  },
  {
    "category": "Correctness",
    "description": "Fix swallowed exception in TryResolveArrayUniquenessTable to preserve all failure diagnostics. In ConstraintDerivationRelationalModelSetPass.TryResolveArrayUniquenessTable (lines 530-548), when iterating candidates, failures from BuildArrayUniquenessColumns are caught and assigned to the 'failure' out parameter, but only the last failure is preserved — earlier diagnostic information is silently discarded. When zero candidates match (line 572, returns false) and the aligned-scope fallback also fails, the caller at line 410 throws the failure from the aligned attempt rather than the original, producing misleading diagnostics. Acceptance: (1) All candidate failures are collected (e.g., in a List<Exception>); (2) When no candidate matches, the out failure is an AggregateException (or a single exception with all candidate error messages concatenated) so no diagnostic context is lost; (3) The caller at line 410 prefers the original-scope failure over the aligned-scope failure when both fail (or includes both); (4) Unit test: construct a fixture where two candidates exist for the same scope and both fail with different errors — assert the thrown exception message contains diagnostic info from both failures; (5) All existing 194 unit tests pass.",
    "steps-to-verify": [
      "Change TryResolveArrayUniquenessTable to collect all candidate failures in a List<Exception> instead of overwriting a single 'failure' variable.",
      "When returning false with failures, set the out parameter to an AggregateException containing all collected failures (or a single exception with concatenated messages if only one).",
      "Update the caller in ApplyArrayUniquenessConstraint (around line 410) to prefer the original-scope failure when both original and aligned attempts fail, or wrap both in an AggregateException.",
      "Add a unit test with two candidates at the same scope that both fail for different reasons and assert the exception contains both error messages.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": false
  },
  {
    "category": "Determinism",
    "description": "Make array uniqueness constraint derivation independent of dictionary enumeration order. `ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraint` iterates `pathsByScope` (a Dictionary) directly, which can vary by runtime and violates the design rule that derivation must not depend on dictionary iteration order. Acceptance: (1) Scope groups are processed in `StringComparer.Ordinal` sorted order by canonical scope string; (2) When multiple scopes exist, derived constraints and thrown diagnostics are stable across runs; (3) No behavioral change to which tables/columns receive constraints; (4) All unit tests (including determinism/golden tests) pass.",
    "steps-to-verify": [
      "Update `ApplyArrayUniquenessConstraint` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to iterate `pathsByScope` in sorted order (e.g., `OrderBy(kvp => kvp.Key, StringComparer.Ordinal)`).",
      "If any exception messages include multiple scopes, ensure the scope list is emitted in sorted order for deterministic diagnostics.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Correctness",
    "description": "Remove nondeterministic `group.First()` selection when mapping identityJsonPaths to columns. `ConstraintDerivationRelationalModelSetPass.BuildRootIdentityColumns` and `BuildIdentityValueColumns` build a `SourceJsonPath -> ColumnName` map using `GroupBy(...).ToDictionary(... group => group.First().ColumnName)`, which becomes order-dependent if duplicates ever occur. Acceptance: (1) SourceJsonPath-to-column resolution is deterministic (e.g., select `OrderBy(ColumnName).First()`) and/or fails fast when a single JSONPath maps to multiple columns; (2) If failing fast, the error message includes resource, table, canonical path, and colliding column names; (3) Add a targeted unit test that constructs a table with duplicate `SourceJsonPath` values and asserts the deterministic selection or fail-fast behavior; (4) All unit tests pass.",
    "steps-to-verify": [
      "Introduce a shared helper (prefer `internal` so it can be unit tested) for building a deterministic `SourceJsonPath -> DbColumnName` lookup from a `DbTableModel`.",
      "Update `BuildRootIdentityColumns` and `BuildIdentityValueColumns` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to use the helper instead of `group.First()`.",
      "Add a unit test that creates a `DbTableModel` with two columns sharing the same `SourceJsonPath` and asserts the new deterministic behavior (or fail-fast message).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Performance",
    "description": "Share/cached per-resource `ExtractInputsStep` output across set-level passes and avoid repeated descriptor inference. Multiple set-level passes build their own `RelationalModelBuilderContext` caches and `RelationalModelSetSchemaHelpers.BuildResourceContext` runs `ExtractInputsStep` with default `DescriptorPathSource.InferFromSchema`, which can redo descriptor inference even though `RelationalModelSetBuilderContext` already computed descriptor path maps. Acceptance: (1) `RelationalModelSetBuilderContext` provides a shared `GetOrCreateResourceBuilderContext` cache keyed by `QualifiedResourceName`; (2) All passes use the shared cache (no per-pass duplicate `ExtractInputsStep` work); (3) Cached builder contexts used by passes are configured with `DescriptorPathSource.Precomputed` and `DescriptorPathsByJsonPath` populated from the set-level descriptor path map; (4) No behavior change; (5) All unit tests pass and `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln` succeeds.",
    "steps-to-verify": [
      "Add a `Dictionary<QualifiedResourceName, RelationalModelBuilderContext>` cache and `GetOrCreateResourceBuilderContext(...)` method to `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/RelationalModelSetBuilderContext.cs`.",
      "Ensure `GetOrCreateResourceBuilderContext(...)` sets `DescriptorPathSource=Precomputed` and provides `DescriptorPathsByJsonPath` from `RelationalModelSetBuilderContext.GetAllDescriptorPathsForResource(...)` before executing `ExtractInputsStep`.",
      "Refactor set-level passes that currently build local `builderContextsByResource` (e.g., `ReferenceBindingRelationalModelSetPass`, `ConstraintDerivationRelationalModelSetPass`, and any `BuildResourceContext` call sites) to use the shared cache.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": false
  },
  {
    "category": "Design",
    "description": "Reconcile default set-level pass ordering with the DMS-1033 design doc. `RelationalModelSetPasses.CreateDefault()` currently runs abstract identity table derivation before reference binding/constraint derivation, but `reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` suggests references/constraints before abstract artifacts. Acceptance: Update the design doc pass-order section to match the implemented dependency (with rationale)",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` to match the chosen pass order (and explain the dependency if abstract identity must precede reference constraints)."
    ],
    "completed": false
  }
]
