[
  {
    "category": "Constraints",
    "description": "Fail fast on incomplete abstract identity mappings: `ConstraintDerivationRelationalModelSetPass` currently skips abstract-target reference constraints when the reference mapping does not include all abstract identity parts (it `continue`s). Change behavior to throw with missing identity parts. Acceptance: (1) For abstract targets, if the reference mapping is missing any identityJsonPath required by `{Abstract}Identity`, compilation fails with an exception that lists the missing identityJsonPaths and identifies the source resource + mapping key; (2) no silent omissions for abstract reference constraints; (3) a unit test covers this failure case deterministically.",
    "steps-to-verify": [
      "Change abstract-target handling in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` so incomplete identity results in an exception (include missing identity paths in the message).",
      "Add a unit test that builds an abstract target reference mapping with missing identity part(s) and asserts the fail-fast exception message includes the missing identity path(s).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Constraints",
    "description": "Fail fast on missing target identityJsonPaths for concrete reference mappings: reference identity completeness is currently optional because missing target identity paths are silently skipped when building composite FK columns. Update derivation/validation so a document reference mapping must bind every target identityJsonPath to a local column for concrete targets. Acceptance: (1) For concrete targets, if `documentPathsMapping.referenceJsonPaths[*].identityJsonPath` does not cover the full target `identityJsonPaths` set, compilation fails with an error listing missing target identityJsonPaths; (2) FK column order remains deterministic and matches target identity order; (3) a unit test covers the missing-identity failure case.",
    "steps-to-verify": [
      "Update `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` (or set-level validation) to detect missing target identityJsonPaths for concrete references and throw with a list of missing paths.",
      "Add a unit test that creates a concrete target with multiple identityJsonPaths but supplies only a subset in `referenceJsonPaths`, and assert the fail-fast exception includes the missing identity path(s).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Schema Inputs",
    "description": "Make `isPartOfIdentity` validation bi-directional: currently validation fails only when identityJsonPaths includes a mapping path but `isPartOfIdentity` is explicitly false; it should also fail when `isPartOfIdentity` is true but the mapping path is not present in identityJsonPaths. Acceptance: (1) `isPartOfIdentity=true` must imply the mapping path (or at least one referenceJsonPath for a reference mapping) is present in `identityJsonPaths`; otherwise throw with an actionable message; (2) existing validation (identityJsonPaths present but isPartOfIdentity=false) continues to fail fast; (3) unit tests cover both directions for scalar/descriptor mappings and for reference mappings.",
    "steps-to-verify": [
      "Update `ResolveIsPartOfIdentity` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` to throw when `isPartOfIdentity=true` but `identityJsonPaths` does not include the relevant path(s).",
      "Add unit tests in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/SchemaInputValidationTests.cs` for the new failure direction (both non-reference and reference cases).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Tests",
    "description": "Add a focused unit test asserting `TableConstraint.AllOrNoneNullability` is derived correctly for a reference group. Acceptance: (1) The derived table contains exactly one `AllOrNoneNullability` constraint per reference group (where identity columns are present); (2) `Name` matches `CK_{TableName}_{FkColumn}_AllOrNone`; (3) `FkColumn` matches the reference `..._DocumentId` column; (4) `DependentColumns` equals the propagated identity columns for that reference (correct names and deterministic order).",
    "steps-to-verify": [
      "Add a new test fixture (or extend existing) in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/ConstraintDerivationRelationalModelSetPassTests.cs` that asserts the `AllOrNoneNullability` constraint for a known reference (e.g., `SchoolReference`) has the expected `FkColumn` and dependent identity columns.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "Tighten reference binding complexity by carrying an index map: `ReferenceBindingRelationalModelSetPass` currently does a list scan (`FindIndex`) to update concrete models. Refactor to precompute a `Dictionary<QualifiedResourceName, int>` (resource -> index) like the constraint pass does, and use it for updates. Acceptance: (1) No `FindIndex` usage remains in the pass; (2) behavior is unchanged for base resources and resource extensions; (3) reference binding remains deterministic and all unit tests pass.",
    "steps-to-verify": [
      "Refactor `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ReferenceBindingRelationalModelSetPass.cs` to use a resource->index map for updates.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Refactor",
    "description": "Review and remove helper duplication: `IsPrefixOf` exists in multiple passes (e.g., `ReferenceBindingRelationalModelSetPass` and `ConstraintDerivationRelationalModelSetPass`). Consolidate into a single shared helper (e.g., in `RelationalModelSetSchemaHelpers`) and update callers. Acceptance: (1) only one implementation exists in the codebase for JSONPath prefix checks; (2) callers use the shared helper; (3) behavior remains identical (all unit tests pass); (4) no new ordering/determinism regressions are introduced.",
    "steps-to-verify": [
      "Move/merge prefix-check logic into a shared helper and update call sites in both passes.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Refactor",
    "description": "Extract a shared WalkSchema context record to eliminate the 17-parameter explosion in ExtensionTableDerivationRelationalModelSetPass.WalkSchema. Bundle stable per-walk parameters (extensionProject, baseRootBaseName, extensionRootBaseName, baseTablesByScope, identityPaths, referenceIdentityPaths, referenceObjectPaths) into a `readonly record struct ExtensionWalkContext`. Pass one context object + the per-call mutation targets. Acceptance: (1) WalkSchema, WalkObjectSchema, and WalkArraySchema each accept <= 10 parameters; (2) no behavioral change \u2014 all existing unit tests pass; (3) the context record is immutable (readonly record struct or sealed record with init-only properties).",
    "steps-to-verify": [
      "Introduce `ExtensionWalkContext` in ExtensionTableDerivationRelationalModelSetPass.cs and refactor WalkSchema/WalkObjectSchema/WalkArraySchema to use it.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Refactor",
    "description": "Consolidate duplicate TableBuilder and ExtensionTableBuilder into a single shared builder. ReferenceBindingRelationalModelSetPass.TableBuilder and ExtensionTableDerivationRelationalModelSetPass.ExtensionTableBuilder contain nearly identical column-collision detection and constraint accumulation logic. Extract a shared `TableColumnAccumulator` (or make one compose/inherit the other). Acceptance: (1) Only one implementation of column-collision detection exists; (2) both passes use the shared builder; (3) all unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Extract shared builder and update both ReferenceBindingRelationalModelSetPass and ExtensionTableDerivationRelationalModelSetPass to use it.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Remove fallback levels 3-4 from ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraint (lines 336-468). Analysis: Level 1 (direct scope match) handles the standard case where constraint scope matches table JsonScope directly. Level 2 (strip _ext.{project} prefix) is required for the cross-boundary nested constraint pattern \u2014 e.g. the contacts extension has basePath=$._ext.sample.addresses[*] with paths=[$.periods[*].beginDate], which resolves to scope $._ext.sample.addresses[*].periods[*], but the actual table is the base ContactAddressPeriod with scope $.addresses[*].periods[*]; stripping _ext.sample makes this match. Levels 3-4 (brute-force scan across ALL tables) are not exercised by any real Ed-Fi schema (ds-5.2 or sample). They catch InvalidOperationException per-candidate and silently continue, meaning if a table happens to have columns with matching names at the wrong scope, the constraint lands on the wrong table \u2014 violating the story AC 'no silent omissions'. Recommendation: Remove levels 3-4 and fail fast after level 2 with a diagnostic error citing the unmatched scope. Add a code comment on level 2 documenting the cross-boundary pattern it handles.",
    "steps-to-verify": [
      "Remove the two TryResolveArrayUniquenessTable brute-force blocks (levels 3-4, approx lines 400-443) from ApplyArrayUniquenessConstraint.",
      "After level 2 fails, throw immediately with a diagnostic message citing the unmatched scope.",
      "Add a code comment on level 2 explaining the cross-boundary extension constraint pattern (contacts/addresses/periods example).",
      "Verify all existing tests still pass \u2014 no real schema exercises levels 3-4.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Remove the redundant Order property from IRelationalModelSetPass and all pass implementations. The canonical pass ordering is already determined by array position in RelationalModelSetPasses.CreatePasses(). The Order property is a second source of truth that can get out of sync. Acceptance: (1) Order property removed from the interface and all implementations; (2) no ordering validation needed since array position IS the order; (3) all unit tests pass.",
    "steps-to-verify": [
      "Remove Order from IRelationalModelSetPass interface.",
      "Remove Order property from all pass implementations (BaseTraversalAndDescriptorBindingRelationalModelSetPass, ExtensionTableDerivationRelationalModelSetPass, AbstractIdentityTableDerivationRelationalModelSetPass, ReferenceBindingRelationalModelSetPass, ConstraintDerivationRelationalModelSetPass).",
      "Remove any references to Order in pipeline runner or tests.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "Cache GetAllDescriptorPathsForResource in RelationalModelSetBuilderContext. The method builds a merged dictionary from base + extension descriptor paths on every call. During constraint derivation this may be called repeatedly for the same resource. Acceptance: (1) The merged result is cached per resource (similar to GetOrCreateBuilderContext); (2) no behavioral change \u2014 all unit tests pass; (3) cache is lazily populated and not invalidated (descriptor paths are immutable after extraction).",
    "steps-to-verify": [
      "Add a Dictionary<QualifiedResourceName, ...> cache field in RelationalModelSetBuilderContext and populate it lazily in GetAllDescriptorPathsForResource.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Standardize string comparison to Ordinal. ExtensionTableDerivationRelationalModelSetPass uses StringComparison.OrdinalIgnoreCase in some places but StringComparer.Ordinal elsewhere. The design docs specify PascalCase naming, so case-insensitive comparison could mask naming bugs (e.g., accepting 'school' where 'School' is expected). Acceptance: (1) All string comparisons in the relational model derivation passes use StringComparer.Ordinal / StringComparison.Ordinal unless there is a documented reason for case-insensitivity; (2) any intentional case-insensitive comparisons are annotated with a comment explaining why; (3) all unit tests pass.",
    "steps-to-verify": [
      "Grep for OrdinalIgnoreCase in all relational model pass files and evaluate each usage.",
      "Replace with Ordinal or add justification comment for each.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Move column collision detection from Build() to AddColumn() time in TableBuilder and ExtensionTableBuilder. Currently duplicate columns are only detected when Build() is called, meaning the error is reported far from the code that introduced the duplicate. Acceptance: (1) AddColumn (or equivalent) throws immediately when a duplicate column name is added, with context about the conflicting source; (2) Build() no longer needs separate collision detection; (3) all unit tests pass.",
    "steps-to-verify": [
      "Update AddColumn in both TableBuilder and ExtensionTableBuilder to throw on duplicate column names at insertion time.",
      "Remove redundant collision checks from Build().",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "Add identity nullability guardrails. Identity components (identityJsonPaths) should not map to nullable columns, otherwise the root UNIQUE constraint can be weakened by NULL semantics. For reference-sourced identity components, enforce that the reference is required (isRequired=true) so the corresponding `..._DocumentId` FK column is NOT NULL. Acceptance: (1) If an identityJsonPath maps to a nullable scalar/descriptor column, fail fast with an actionable error; (2) If a document reference contributes to identity but isRequired=false, fail fast; (3) Add unit tests proving these fail-fast rules; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Add/extend unit tests that define an identityJsonPath on an optional (or x-nullable) scalar property and assert compilation fails with a clear message.",
      "Add/extend unit tests that define a reference identity component (isPartOfIdentity=true) with isRequired=false and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Fail fast on duplicate reference identity bindings instead of selecting a winner. `BuildReferenceIdentityColumns` currently de-dupes duplicate mappings by selecting the lexicographically smaller path/column, which can silently mask upstream ApiSchema issues. Acceptance: (1) If `documentPathsMapping.referenceJsonPaths` contains duplicate identityJsonPath entries for a single reference mapping, fail fast with an actionable message; (2) If derived `DocumentReferenceBinding.IdentityBindings` contains duplicates for the same referenceJsonPath, fail fast; (3) Add unit tests for these fail-fast conditions; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Update `ConstraintDerivationRelationalModelSetPass.BuildReferenceIdentityColumns` to throw on duplicates rather than selecting the smallest by string comparison.",
      "Add unit tests constructing ApiSchema fixtures with duplicate referenceJsonPaths entries and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Confirm whether the abstract-target `hasCompleteIdentity` branch is dead. In `ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraintsForResource`, `hasCompleteIdentity` is computed from `BuildReferenceIdentityColumns(...)` but `BuildReferenceIdentityColumns` currently throws when any target identity path is missing, which likely makes the `if (targetInfo.IsAbstract && !hasCompleteIdentity) continue;` path unreachable. Acceptance: (1) Prove via unit test(s) or reasoning + code change that this branch is unreachable; (2) If dead, remove the branch and simplify logic; (3) If not dead, add a unit test that exercises it and document why abstract targets are allowed to be partially mapped.",
    "steps-to-verify": [
      "Add or update a unit test that attempts to build an abstract reference with missing identity mapping and verify whether it throws before reaching the `hasCompleteIdentity` gate.",
      "If unreachable, remove the `hasCompleteIdentity` calculation and the `continue` branch; otherwise add test coverage and inline comment explaining the intended partial-mapping behavior.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Remove duplicated logic in relational model derivation: (1) scalar type resolution is duplicated verbatim in `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`; (2) canonical table ordering logic is duplicated between `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass`. Acceptance: (1) Extract shared helpers (e.g., `RelationalScalarTypeResolver` and `RelationalModelOrdering`) and replace duplicate implementations; (2) Ensure behavior is unchanged by covering both code paths with existing/new unit tests; (3) All unit tests pass.",
    "steps-to-verify": [
      "Extract scalar-type resolution helpers into a shared type and use it from both `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`.",
      "Extract table/constraint canonical ordering helpers and use it from both `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass` (or remove the local copy and call the canonical implementation).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "Extract duplicated helper methods shared across passes into RelationalModelSetSchemaHelpers. The following methods are copy-pasted nearly verbatim across ReferenceBindingRelationalModelSetPass, ConstraintDerivationRelationalModelSetPass, ExtensionTableDerivationRelationalModelSetPass, and AbstractIdentityTableDerivationRelationalModelSetPass: IsResourceExtension(), GetApiSchemaRoot(), BuildBaseResourceLookup(), BuildResourceContext()/GetOrCreateBuilderContext(). Acceptance: (1) Each helper exists in exactly one location (RelationalModelSetSchemaHelpers or a new shared class); (2) All four passes call the shared implementation; (3) No private copies of these methods remain in individual pass files; (4) All 184 unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Move IsResourceExtension to RelationalModelSetSchemaHelpers and update all four pass files to use it.",
      "Move GetApiSchemaRoot to RelationalModelSetSchemaHelpers and update all callers.",
      "Move BuildBaseResourceLookup to RelationalModelSetSchemaHelpers and update all callers.",
      "Move BuildResourceContext / GetOrCreateBuilderContext to a shared location and update all callers.",
      "Grep the pass files to confirm no private copies remain: `grep -n 'IsResourceExtension\\|GetApiSchemaRoot\\|BuildBaseResourceLookup' src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/*Pass.cs`",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "Consolidate ConstraintDerivationRelationalModelSetPass.TableBuilder with the shared TableColumnAccumulator. ConstraintDerivationRelationalModelSetPass contains a private TableBuilder class (lines 1731-1791) that duplicates column-collision detection and constraint accumulation from the shared TableColumnAccumulator. Meanwhile ReferenceBindingRelationalModelSetPass uses TableColumnAccumulator directly. Acceptance: (1) The private TableBuilder is removed from ConstraintDerivationRelationalModelSetPass; (2) ResourceMutation wraps TableColumnAccumulator instead; (3) Column-collision detection logic exists in exactly one place; (4) All unit tests pass.",
    "steps-to-verify": [
      "Replace private TableBuilder in ConstraintDerivationRelationalModelSetPass with TableColumnAccumulator.",
      "Update ResourceMutation to use TableColumnAccumulator in its Dictionary<TableKey, ...>.",
      "Verify no private TableBuilder class remains in ConstraintDerivationRelationalModelSetPass.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Duplication",
    "description": "AbstractIdentityTableDerivationRelationalModelSetPass contains its own copy of scalar type resolution (ResolveScalarType, ResolveStringType, BuildStringType, ResolveIntegerType, ResolveDecimalType at lines 660-775) that duplicates the shared RelationalScalarTypeResolver added in this branch. Acceptance: (1) The private scalar resolution methods are removed from AbstractIdentityTableDerivationRelationalModelSetPass; (2) The pass uses RelationalScalarTypeResolver.ResolveScalarType instead; (3) If RelationalScalarTypeResolver needs a minor signature adjustment to accept ConcreteResourceMetadata's decimal infos, that is acceptable; (4) All unit tests pass.",
    "steps-to-verify": [
      "Remove ResolveScalarType, ResolveStringType, BuildStringType, ResolveIntegerType, ResolveDecimalType from AbstractIdentityTableDerivationRelationalModelSetPass.",
      "Update ResolveColumnSignature to call RelationalScalarTypeResolver.ResolveScalarType.",
      "Adjust RelationalScalarTypeResolver if needed to accept the decimal property validation infos from ConcreteResourceMetadata.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Duplication",
    "description": "Extract duplicated ResolveSchemaForPath JSON schema traversal. Both ReferenceBindingRelationalModelSetPass (lines 462-566) and AbstractIdentityTableDerivationRelationalModelSetPass (lines 369-468) contain nearly identical ResolveSchemaForPath methods that walk a JSON schema by path segments. Acceptance: (1) A single shared ResolveSchemaForPath exists (e.g., in RelationalModelSetSchemaHelpers or a new JsonSchemaNavigation utility); (2) Both passes call the shared method; (3) Error messages remain resource-specific (the shared method should accept a resource name for diagnostics); (4) All unit tests pass.",
    "steps-to-verify": [
      "Extract ResolveSchemaForPath to a shared location, parameterized by a resource identifier for error messages.",
      "Update both ReferenceBindingRelationalModelSetPass and AbstractIdentityTableDerivationRelationalModelSetPass to use the shared method.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "ReferenceBindingRelationalModelSetPass.BuildResourceContext creates a new RelationalModelBuilderContext and runs ExtractInputsStep().Execute() for every resource without caching. ConstraintDerivationRelationalModelSetPass correctly caches via GetOrCreateBuilderContext. Apply the same caching pattern to ReferenceBindingRelationalModelSetPass. Acceptance: (1) ReferenceBindingRelationalModelSetPass caches builder contexts per resource (identical to ConstraintDerivationRelationalModelSetPass.GetOrCreateBuilderContext pattern); (2) ExtractInputsStep is executed at most once per resource across the pass; (3) All unit tests pass.",
    "steps-to-verify": [
      "Add a Dictionary<QualifiedResourceName, RelationalModelBuilderContext> cache to the Execute method in ReferenceBindingRelationalModelSetPass.",
      "Replace direct BuildResourceContext calls with a GetOrCreateBuilderContext pattern.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Design",
    "description": "Investigate and document whether TablesInWriteDependencyOrder should differ from TablesInReadDependencyOrder. Both ReferenceBindingRelationalModelSetPass (line 286-288) and ConstraintDerivationRelationalModelSetPass (line 838-839) always set TablesInWriteDependencyOrder = TablesInReadDependencyOrder (same array). If they are always identical, remove TablesInWriteDependencyOrder from RelationalResourceModel to eliminate redundant state. If they are intended to diverge in a future story, add a code comment documenting the intent. Acceptance: (1) Either TablesInWriteDependencyOrder is removed (if always identical), OR a code comment on RelationalResourceModel documents when and why it will diverge; (2) No behavioral change; (3) All unit tests pass.",
    "steps-to-verify": [
      "Search all assignments to TablesInWriteDependencyOrder to confirm it always equals TablesInReadDependencyOrder.",
      "If always identical: remove TablesInWriteDependencyOrder from RelationalResourceModel and update all callers to use TablesInReadDependencyOrder.",
      "If future divergence planned: add a doc comment on the property explaining the planned distinction.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "ResolveOwningTableBuilder in ReferenceBindingRelationalModelSetPass silently picks the lexicographically-first scope when two table scopes match at the same segment depth (lines 334-341). This tiebreaking could mask genuine ambiguity (e.g., extension vs base table at same depth). Change to throw on ambiguous matches. Acceptance: (1) When two scopes match the reference path with the same segment count, the method throws an InvalidOperationException listing both candidates; (2) If there is a legitimate scenario requiring tiebreaking, document it with a comment and add a unit test; (3) All existing unit tests pass (confirming the ambiguous case does not occur in practice).",
    "steps-to-verify": [
      "Replace the tiebreak logic (lines 334-341) with a throw listing both candidate scopes.",
      "Run existing tests to confirm no legitimate ambiguity exists: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "If a test fails, investigate whether the tiebreak is needed and document it."
    ],
    "completed": false
  },
  {
    "category": "Tests",
    "description": "Add targeted unit tests for extension array uniqueness constraint alignment. The TryStripExtensionRootPrefix/StripExtensionRootPrefix fallback path in ConstraintDerivationRelationalModelSetPass (lines 371-396) handles extension schemas declaring array uniqueness under _ext.{project} when the owning table is in the base scope. This is only tested indirectly through golden tests. Acceptance: (1) A focused unit test creates a resource extension with arrayUniquenessConstraints scoped under _ext.{project} that must align to a base-scope table; (2) The test asserts the correct UNIQUE constraint appears on the correct base-scope child table; (3) A second test asserts that when alignment fails (no matching base table), the pass throws with a diagnostic message.",
    "steps-to-verify": [
      "Add tests in ConstraintDerivationRelationalModelSetPassTests.cs for the extension-to-base scope alignment path.",
      "One test: valid alignment produces correct UX constraint on the base child table.",
      "One test: invalid alignment (no matching base table) throws with diagnostic scope info.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Tests",
    "description": "Add unit tests for nested ArrayUniquenessConstraintInput recursion. The ArrayUniquenessConstraintInput record supports NestedConstraints, and ApplyArrayUniquenessConstraint handles them recursively (lines 409-421). There is no targeted test for multi-level nested collection uniqueness derivation. Acceptance: (1) A unit test builds a resource with a 2-level nested collection (e.g., addresses[*].periods[*]) where both levels have uniqueness constraints; (2) The test asserts both the parent and nested child tables receive the correct UNIQUE constraints; (3) Column ordering in each constraint is deterministic and matches the expected parent-key-parts + constraint-paths order.",
    "steps-to-verify": [
      "Add a test in ConstraintDerivationRelationalModelSetPassTests.cs with a fixture containing nested arrayUniquenessConstraints.",
      "Assert the parent collection table has a UX constraint with expected columns.",
      "Assert the nested child table has a UX constraint with expected columns (including parent ordinal).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Performance",
    "description": "AbstractIdentityTableDerivationRelationalModelSetPass.BuildConcreteMetadata eagerly builds metadata (including JsonSchemaForInsert, DecimalPropertyValidationInfos, full RelationalResourceModel) for every concrete resource, even though only subclass members are used during identity column derivation. Acceptance: (1) Metadata is built lazily \u2014 only for resources that are actually members of an abstract resource; (2) Non-subclass resources do not have their JsonSchemaForInsert parsed or DecimalPropertyValidationInfos extracted; (3) All unit tests pass; (4) Behavior is unchanged for subclass resources.",
    "steps-to-verify": [
      "Refactor BuildConcreteMetadata to only build full metadata for resources where isSubclass=true, or switch to lazy resolution during BuildIdentityColumns.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Design",
    "description": "Update backend redesign design docs to state composite foreign keys for document references only use `ON UPDATE CASCADE` when the referenced target resource has `allowIdentityUpdates=true` (otherwise `ON UPDATE NO ACTION`). Align wording in `reference/design/backend-redesign/design-docs/data-model.md`, `reference/design/backend-redesign/design-docs/ddl-generation.md`, and `reference/design/backend-redesign/design-docs/flattening-reconstitution.md` with current behavior in `ConstraintDerivationRelationalModelSetPass`.",
    "steps-to-verify": [
      "Update the reference constraint sections in the listed design docs to describe `allowIdentityUpdates` gating for `ON UPDATE CASCADE` and the non-cascade behavior when it is false.",
      "Run: `rg -n \"ON UPDATE CASCADE\" reference/design/backend-redesign/design-docs` and confirm remaining mentions are conditional or explicitly scoped to `allowIdentityUpdates`-enabled targets.",
      "Sanity check: compare wording against `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` onUpdate selection logic."
    ],
    "completed": false
  },
  {
    "category": "Schema Inputs",
    "description": "Fail fast on unsupported `resourceSchema.relational.nameOverrides` keys and validate override JSONPath grammar. Today `ExtractReferenceNameOverrides` only checks for overrides on bound document reference object paths and silently ignores any other keys. This makes non-reference override keys a silent no-op until DMS-931 is implemented. Acceptance: (1) every key in `relational.nameOverrides` must compile as a valid JSONPath (throw with the invalid key and resource name when it does not); (2) until DMS-931, only document reference object path overrides are supported \u2014 any other override key causes compilation to fail, listing the unsupported keys and identifying the resource; (3) override matching uses canonical JSONPath strings (compile keys to canonical form before comparing) so valid overrides are not missed due to non-canonical input; (4) unit tests cover invalid JSONPath keys, unsupported non-reference keys, and a valid reference override key.",
    "steps-to-verify": [
      "Update `ExtractReferenceNameOverrides` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` to iterate all `relational.nameOverrides` entries, compile each key using `JsonPathExpressionCompiler.Compile`, and throw if the canonical key is not in the derived `referenceObjectPaths` set.",
      "Add tests in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/SchemaInputValidationTests.cs`: (a) invalid JSONPath override key throws; (b) non-reference override key throws and lists the key; (c) valid reference override key does not throw and is applied.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": false
  },
  {
    "category": "Refactor",
    "description": "Make abstract identity table inventory explicit and structurally consistent with concrete resource tables. Today `AbstractIdentityTableInfo` stores only `(Table, ColumnsInIdentityOrder, Constraints)` and assumes `DocumentId` exists implicitly via constraints. Change the contracts and builder so each abstract identity table is represented as a full `DbTableModel` (or equivalent table model type) that includes `Key` and `Columns`, with `DocumentId` explicitly modeled. Discriminator policy: v1 always includes `Discriminator` as `varchar(256)`/`nvarchar(256)` (`ScalarKind.String`, maxLength 256), NOT NULL, excluded from key/unique/FK columns. Acceptance: (1) `AbstractIdentityTableInfo` exposes a complete table model including `Key` and `Columns`; (2) the abstract identity table has `Key.Columns == [DocumentId]`; (3) `Columns` includes an explicit `DocumentId` `DbColumnModel` with `Kind=ParentKeyPart`, `ScalarKind.Int64`, `IsNullable=false`; (4) `Columns` includes the abstract identity columns in `identityJsonPaths` order, plus `Discriminator` as a trailing column; (5) derived constraints include FK `DocumentId -> dms.Document(DocumentId) ON DELETE CASCADE` and UNIQUE `(DocumentId, <identity columns...>)` with deterministic naming; (6) constraint derivation for abstract reference targets uses the new explicit table model shape to resolve identity columns; (7) golden/authoritative tests and collision detection are updated accordingly; (8) unit tests pass and the DMS solution builds.",
    "steps-to-verify": [
      "Update `./src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs` so `AbstractIdentityTableInfo` carries a full table model (prefer `DbTableModel`).",
      "Update `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/AbstractIdentityTableDerivationRelationalModelSetPass.cs` to build the abstract identity table as a `DbTableModel` with `Key=(DocumentId)` and `Columns` seeded with an explicit `DocumentId` key column (reuse key column conventions from `DeriveTableScopesAndKeysStep`).",
      "Update abstract-target identity resolution in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to read identity paths/columns from the new abstract identity table model shape.",
      "Update collision detection in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/RelationalModelSetBuilderContext.cs` to register columns/constraints from the new abstract identity table model shape.",
      "Update tests in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/AbstractIdentityTableDerivationTests.cs` to assert `DocumentId` is an explicit column and that `Key.Columns` is exactly `[DocumentId]`.",
      "Update golden/authoritative tests that serialize abstract identity tables (e.g., `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetAuthoritativeGoldenTests.cs`) to match the new explicit shape.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Schema Inputs",
    "description": "Fail fast on duplicate `identityJsonPaths` per resource/abstract resource. Today duplicates can slip through extraction, and later unique-constraint derivation de-dupes by column name, masking schema issues. Acceptance: (1) `identityJsonPaths` are compiled to canonical JSONPaths and must be unique per resource schema entry (both `projectSchema.resourceSchemas` and `projectSchema.abstractResources`); duplicates fail compilation with an exception that includes the resource name and the duplicate canonical path(s); (2) duplicate detection happens before any constraint/name generation; (3) unit tests cover duplicate detection for a concrete resource and for an abstract resource identity list; (4) all unit tests pass.",
    "steps-to-verify": [
      "Update `ExtractIdentityJsonPaths` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` to detect duplicate canonical JSONPaths and throw with an actionable message.",
      "Update abstract identity path extraction in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/AbstractIdentityTableDerivationRelationalModelSetPass.cs` to detect duplicate canonical JSONPaths and throw similarly.",
      "Add unit tests (concrete + abstract cases) asserting the fail-fast behavior and the exception message includes the duplicate canonical path(s).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Docs",
    "description": "Add a DMS-930 \u2192 DMS-931 naming handoff note to `reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md`. This should document what DMS-930 already implemented, what is intentionally provisional/placeholder behavior, and what remains for DMS-931 so future work doesn\u2019t accidentally rely on pre-naming identifiers. Acceptance: (1) The doc includes a clearly labeled section (e.g., \u201cHandoff from DMS-930\u201d) describing: current provisional identifier generation in DMS-930 (constraint/index/column/table names may exceed dialect limits), current placeholder `relational.nameOverrides` behavior (reference-only / fail-fast on non-reference keys), and current shortening behavior (collision detection exists but identifiers are not rewritten); (2) the doc lists the DMS-931 responsibilities: apply naming rules, apply full overrides, apply dialect shortening into the model, and ensure collisions are detected after rewriting; (3) the section references the relevant implementation passes/classes by name; (4) content is specific enough for a new contributor to understand the boundary between stories.",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md` to add a handoff section describing DMS-930 naming placeholders and DMS-931 responsibilities.",
      "Verify the doc references the relevant code locations (passes and key helpers) accurately and uses concrete examples (e.g., `UX_{table}_{col1}_{col2}_...` naming and dialect shortening limits)."
    ],
    "completed": false
  }
]
