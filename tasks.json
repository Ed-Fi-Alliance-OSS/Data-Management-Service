[
  {
    "category": "Robustness",
    "description": "Fail fast on duplicate reference identity bindings instead of selecting a winner. `BuildReferenceIdentityColumns` currently de-dupes duplicate mappings by selecting the lexicographically smaller path/column, which can silently mask upstream ApiSchema issues. Acceptance: (1) If `documentPathsMapping.referenceJsonPaths` contains duplicate identityJsonPath entries for a single reference mapping, fail fast with an actionable message; (2) If derived `DocumentReferenceBinding.IdentityBindings` contains duplicates for the same referenceJsonPath, fail fast; (3) Add unit tests for these fail-fast conditions; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Update `ConstraintDerivationRelationalModelSetPass.BuildReferenceIdentityColumns` to throw on duplicates rather than selecting the smallest by string comparison.",
      "Add unit tests constructing ApiSchema fixtures with duplicate referenceJsonPaths entries and assert compilation fails with a clear message.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Robustness",
    "description": "Confirm whether the abstract-target `hasCompleteIdentity` branch is dead. In `ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraintsForResource`, `hasCompleteIdentity` is computed from `BuildReferenceIdentityColumns(...)` but `BuildReferenceIdentityColumns` currently throws when any target identity path is missing, which likely makes the `if (targetInfo.IsAbstract && !hasCompleteIdentity) continue;` path unreachable. Acceptance: (1) Prove via unit test(s) or reasoning + code change that this branch is unreachable; (2) If dead, remove the branch and simplify logic; (3) If not dead, add a unit test that exercises it and document why abstract targets are allowed to be partially mapped.",
    "steps-to-verify": [
      "Add or update a unit test that attempts to build an abstract reference with missing identity mapping and verify whether it throws before reaching the `hasCompleteIdentity` gate.",
      "If unreachable, remove the `hasCompleteIdentity` calculation and the `continue` branch; otherwise add test coverage and inline comment explaining the intended partial-mapping behavior.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Remove duplicated logic in relational model derivation: (1) scalar type resolution is duplicated verbatim in `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`; (2) canonical table ordering logic is duplicated between `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass`. Acceptance: (1) Extract shared helpers (e.g., `RelationalScalarTypeResolver` and `RelationalModelOrdering`) and replace duplicate implementations; (2) Ensure behavior is unchanged by covering both code paths with existing/new unit tests; (3) All unit tests pass.",
    "steps-to-verify": [
      "Extract scalar-type resolution helpers into a shared type and use it from both `DeriveColumnsAndBindDescriptorEdgesStep` and `ReferenceBindingRelationalModelSetPass`.",
      "Extract table/constraint canonical ordering helpers and use it from both `CanonicalizeOrderingStep` and `ConstraintDerivationRelationalModelSetPass` (or remove the local copy and call the canonical implementation).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Docs",
    "description": "Add a DMS-930 \u2192 DMS-931 naming handoff note to `reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md`. This should document what DMS-930 already implemented, what is intentionally provisional/placeholder behavior, and what remains for DMS-931 so future work doesn\u2019t accidentally rely on pre-naming identifiers. Acceptance: (1) The doc includes a clearly labeled section (e.g., \u201cHandoff from DMS-930\u201d) describing: current provisional identifier generation in DMS-930 (constraint/index/column/table names may exceed dialect limits), current placeholder `relational.nameOverrides` behavior (reference-only / fail-fast on non-reference keys), and current shortening behavior (collision detection exists but identifiers are not rewritten); (2) the doc lists the DMS-931 responsibilities: apply naming rules, apply full overrides, apply dialect shortening into the model, and ensure collisions are detected after rewriting; (3) the section references the relevant implementation passes/classes by name; (4) content is specific enough for a new contributor to understand the boundary between stories.",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/02-naming-and-overrides.md` to add a handoff section describing DMS-930 naming placeholders and DMS-931 responsibilities.",
      "Verify the doc references the relevant code locations (passes and key helpers) accurately and uses concrete examples (e.g., `UX_{table}_{col1}_{col2}_...` naming and dialect shortening limits)."
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Extract shared extension-resolution boilerplate from passes into a single helper. The 'resolve resource extension to base resource' pattern (BuildBaseResourceLookup \u2192 TryGetValue \u2192 count-check \u2192 error message) is copy-pasted in ReferenceBindingRelationalModelSetPass.Execute (lines 59-98), ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints (lines 116-158), and ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints (lines 231-267). If the matching logic or error wording changes, all three must be updated in lockstep. Acceptance: (1) A shared method (e.g., ResolveBaseResourceForExtension) exists in RelationalModelSetSchemaHelpers that takes a resource extension context and the base resource lookup and returns the single matching base entry, throwing on zero or multiple matches with the same error messages as today; (2) All three call sites use the shared method; (3) No private copies of the matching/error logic remain in individual pass files; (4) All unit tests pass with no behavioral change.",
    "steps-to-verify": [
      "Add ResolveBaseResourceForExtension<TEntry> to RelationalModelSetSchemaHelpers that accepts resourceName, resource (for error formatting), and the base resource lookup, returning the single TEntry.",
      "Replace the inline logic in ReferenceBindingRelationalModelSetPass.Execute with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyReferenceConstraints with a call to the shared helper.",
      "Replace the inline logic in ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraints with a call to the shared helper.",
      "Grep pass files to confirm no private copies remain: grep -n 'baseEntries.Count != 1' src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/*Pass.cs",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Split ConstraintDerivationRelationalModelSetPass into focused passes. At ~1,625 lines, this class houses three independent concerns: (A) root identity unique constraints, (B) reference FK + all-or-none constraints, (C) array uniqueness constraints. Each sub-pass independently rebuilds resourcesByKey, baseResourcesByName, apiSchemaRootsByProjectEndpoint, and builderContextsByResource dictionaries. The ApplyReferenceConstraintsForResource method takes 11 parameters. Acceptance: (1) The class is split into 2-3 separate IRelationalModelSetPass implementations (e.g., RootIdentityConstraintPass, ReferenceConstraintPass, ArrayUniquenessConstraintPass \u2014 or at minimum separate the reference constraint logic from root/array); (2) Each new pass is registered in RelationalModelSetPasses.CreateDefault() in the correct order (root constraints before reference constraints before array uniqueness); (3) The ApplyReferenceConstraintsForResource 11-parameter signature is reduced by introducing a context record that bundles the shared lookup state; (4) All 194 unit tests pass with no behavioral change; (5) The authoritative golden test output is byte-identical.",
    "steps-to-verify": [
      "Extract root identity constraint derivation into its own IRelationalModelSetPass (or keep inline if trivial).",
      "Extract reference FK + all-or-none constraint derivation into its own IRelationalModelSetPass with a bundled context record replacing the 11-parameter method.",
      "Extract array uniqueness constraint derivation into its own IRelationalModelSetPass.",
      "Register new passes in RelationalModelSetPasses.CreateDefault() in correct order.",
      "Verify ApplyReferenceConstraintsForResource (or equivalent) parameter count is \u2264 5.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj",
      "Diff authoritative golden test output to confirm byte-identical results."
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "Fix swallowed exception in TryResolveArrayUniquenessTable to preserve all failure diagnostics. In ConstraintDerivationRelationalModelSetPass.TryResolveArrayUniquenessTable (lines 530-548), when iterating candidates, failures from BuildArrayUniquenessColumns are caught and assigned to the 'failure' out parameter, but only the last failure is preserved \u2014 earlier diagnostic information is silently discarded. When zero candidates match (line 572, returns false) and the aligned-scope fallback also fails, the caller at line 410 throws the failure from the aligned attempt rather than the original, producing misleading diagnostics. Acceptance: (1) All candidate failures are collected (e.g., in a List<Exception>); (2) When no candidate matches, the out failure is an AggregateException (or a single exception with all candidate error messages concatenated) so no diagnostic context is lost; (3) The caller at line 410 prefers the original-scope failure over the aligned-scope failure when both fail (or includes both); (4) Unit test: construct a fixture where two candidates exist for the same scope and both fail with different errors \u2014 assert the thrown exception message contains diagnostic info from both failures; (5) All existing 194 unit tests pass.",
    "steps-to-verify": [
      "Change TryResolveArrayUniquenessTable to collect all candidate failures in a List<Exception> instead of overwriting a single 'failure' variable.",
      "When returning false with failures, set the out parameter to an AggregateException containing all collected failures (or a single exception with concatenated messages if only one).",
      "Update the caller in ApplyArrayUniquenessConstraint (around line 410) to prefer the original-scope failure when both original and aligned attempts fail, or wrap both in an AggregateException.",
      "Add a unit test with two candidates at the same scope that both fail for different reasons and assert the exception contains both error messages.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj"
    ],
    "completed": true
  },
  {
    "category": "Determinism",
    "description": "Make array uniqueness constraint derivation independent of dictionary enumeration order. `ConstraintDerivationRelationalModelSetPass.ApplyArrayUniquenessConstraint` iterates `pathsByScope` (a Dictionary) directly, which can vary by runtime and violates the design rule that derivation must not depend on dictionary iteration order. Acceptance: (1) Scope groups are processed in `StringComparer.Ordinal` sorted order by canonical scope string; (2) When multiple scopes exist, derived constraints and thrown diagnostics are stable across runs; (3) No behavioral change to which tables/columns receive constraints; (4) All unit tests (including determinism/golden tests) pass.",
    "steps-to-verify": [
      "Update `ApplyArrayUniquenessConstraint` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to iterate `pathsByScope` in sorted order (e.g., `OrderBy(kvp => kvp.Key, StringComparer.Ordinal)`).",
      "If any exception messages include multiple scopes, ensure the scope list is emitted in sorted order for deterministic diagnostics.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "Remove nondeterministic `group.First()` selection when mapping identityJsonPaths to columns. `ConstraintDerivationRelationalModelSetPass.BuildRootIdentityColumns` and `BuildIdentityValueColumns` build a `SourceJsonPath -> ColumnName` map using `GroupBy(...).ToDictionary(... group => group.First().ColumnName)`, which becomes order-dependent if duplicates ever occur. Acceptance: (1) SourceJsonPath-to-column resolution is deterministic (e.g., select `OrderBy(ColumnName).First()`) and/or fails fast when a single JSONPath maps to multiple columns; (2) If failing fast, the error message includes resource, table, canonical path, and colliding column names; (3) Add a targeted unit test that constructs a table with duplicate `SourceJsonPath` values and asserts the deterministic selection or fail-fast behavior; (4) All unit tests pass.",
    "steps-to-verify": [
      "Introduce a shared helper (prefer `internal` so it can be unit tested) for building a deterministic `SourceJsonPath -> DbColumnName` lookup from a `DbTableModel`.",
      "Update `BuildRootIdentityColumns` and `BuildIdentityValueColumns` in `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ConstraintDerivationRelationalModelSetPass.cs` to use the helper instead of `group.First()`.",
      "Add a unit test that creates a `DbTableModel` with two columns sharing the same `SourceJsonPath` and asserts the new deterministic behavior (or fail-fast message).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "Share/cached per-resource `ExtractInputsStep` output across set-level passes and avoid repeated descriptor inference. Multiple set-level passes build their own `RelationalModelBuilderContext` caches and `RelationalModelSetSchemaHelpers.BuildResourceContext` runs `ExtractInputsStep` with default `DescriptorPathSource.InferFromSchema`, which can redo descriptor inference even though `RelationalModelSetBuilderContext` already computed descriptor path maps. Acceptance: (1) `RelationalModelSetBuilderContext` provides a shared `GetOrCreateResourceBuilderContext` cache keyed by `QualifiedResourceName`; (2) All passes use the shared cache (no per-pass duplicate `ExtractInputsStep` work); (3) Cached builder contexts used by passes are configured with `DescriptorPathSource.Precomputed` and `DescriptorPathsByJsonPath` populated from the set-level descriptor path map; (4) No behavior change; (5) All unit tests pass and `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln` succeeds.",
    "steps-to-verify": [
      "Add a `Dictionary<QualifiedResourceName, RelationalModelBuilderContext>` cache and `GetOrCreateResourceBuilderContext(...)` method to `./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/RelationalModelSetBuilderContext.cs`.",
      "Ensure `GetOrCreateResourceBuilderContext(...)` sets `DescriptorPathSource=Precomputed` and provides `DescriptorPathsByJsonPath` from `RelationalModelSetBuilderContext.GetAllDescriptorPathsForResource(...)` before executing `ExtractInputsStep`.",
      "Refactor set-level passes that currently build local `builderContextsByResource` (e.g., `ReferenceBindingRelationalModelSetPass`, `ConstraintDerivationRelationalModelSetPass`, and any `BuildResourceContext` call sites) to use the shared cache.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`",
      "Run: `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`"
    ],
    "completed": true
  },
  {
    "category": "Design",
    "description": "Reconcile default set-level pass ordering with the DMS-1033 design doc. `RelationalModelSetPasses.CreateDefault()` currently runs abstract identity table derivation before reference binding/constraint derivation, but `reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` suggests references/constraints before abstract artifacts. Acceptance: Update the design doc pass-order section to match the implemented dependency (with rationale)",
    "steps-to-verify": [
      "Update `./reference/design/backend-redesign/epics/01-relational-model/08-derived-relational-model-set-builder.md` to match the chosen pass order (and explain the dependency if abstract identity must precede reference constraints)."
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "BuildColumnNameLookupBySourceJsonPath silently picks first column on SourceJsonPath collisions. In ConstraintDerivationHelpers.cs:86-98, when multiple columns share the same SourceJsonPath, the method silently picks the first by ordinal column name via GroupBy + OrderBy + First(). This could mask a real bug where two distinct columns (e.g., a scalar column and a reference identity propagation column added by different passes) collide on the same source path, causing a constraint to reference the wrong column. Acceptance: (1) When two columns with different ColumnKind values share the same SourceJsonPath, the method throws with a message identifying the table, path, and both column names; (2) When two columns with the same ColumnKind share the same SourceJsonPath (legitimate dedup), the method deterministically selects the first by ordinal column name (current behavior); (3) Add a unit test constructing a DbTableModel with two columns of different ColumnKind sharing a SourceJsonPath and assert it throws; (4) Add a unit test with same-kind duplicates asserting deterministic selection; (5) All existing unit tests pass.",
    "steps-to-verify": [
      "Update BuildColumnNameLookupBySourceJsonPath in ConstraintDerivationHelpers.cs to detect mixed-kind duplicates and throw.",
      "Add unit test: two columns (Scalar + DocumentFk) sharing the same SourceJsonPath -> assert InvalidOperationException with diagnostic message.",
      "Add unit test: two Scalar columns sharing the same SourceJsonPath -> assert deterministic selection by ordinal name.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/"
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "EnsureTargetUnique cross-resource mutation needs explicit test coverage and documentation. ReferenceConstraintRelationalModelSetPass.EnsureTargetUnique (lines 314-352) modifies the target resource's model by adding a (DocumentId, IdentityParts...) unique constraint needed for composite FK targets. This mutation happens as a side effect when processing a *different* resource's references, and is batched/applied at the end of the pass (lines 96-108). The final target model's constraint list depends on which other resources reference it. This ordering dependency is fragile and undocumented. Acceptance: (1) Add a dedicated unit test that constructs two resources A and B where A references B, and verifies that after the ReferenceConstraintRelationalModelSetPass runs, resource B's root table contains the (DocumentId, IdentityColumn) unique constraint even though B itself has no references; (2) Add a second test where two resources C and D both reference B with the same identity projection, and verify the constraint is added exactly once (idempotent); (3) Add an inline comment on EnsureTargetUnique documenting this cross-resource mutation contract; (4) All existing tests pass.",
    "steps-to-verify": [
      "Add test: resource A references resource B -> verify B's root table gains UX_(B)_DocumentId_(identity) constraint.",
      "Add test: resources C and D both reference B with same identity -> verify constraint appears exactly once on B.",
      "Add inline doc comment on EnsureTargetUnique explaining the cross-resource side-effect contract.",
      "Run: dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/"
    ],
    "completed": true
  },
  {
    "category": "Determinism",
    "description": "Canonicalize ordering after set-level reference binding/constraint passes. Today, `CanonicalizeOrderingStep` canonicalizes tables + edges within the per-resource pipeline, but `ReferenceBindingRelationalModelSetPass` appends `DocumentReferenceBindings`/`DescriptorEdgeSources` without applying the same ordering rules. This creates hidden coupling to `documentPathsMapping` key order and can cause drift between pipelines/passes. Acceptance: (1) Introduce a set-level canonicalization pass that, for every concrete resource model, applies the same canonical ordering rules as `CanonicalizeOrderingStep` for: `TablesInReadDependencyOrder`, `DocumentReferenceBindings`, and `DescriptorEdgeSources`; (2) Ensure all tables are canonicalized via `RelationalModelOrdering.CanonicalizeTable` regardless of whether later passes touched the table; (3) Add/extend a unit test fixture where `documentPathsMapping` entries are intentionally out-of-order relative to `ReferenceObjectPath` and assert the resulting `DocumentReferenceBindings` and `DescriptorEdgeSources` are in canonical order; (4) Existing determinism and authoritative golden tests still pass.",
    "steps-to-verify": [
      "Add `CanonicalizeOrderingRelationalModelSetPass` (or equivalent) that reorders `TablesInReadDependencyOrder`, `DocumentReferenceBindings`, and `DescriptorEdgeSources` for each concrete resource after reference binding/constraint derivation.",
      "Add/extend unit test(s) asserting `DocumentReferenceBindings` ordering matches the rules in `CanonicalizeOrderingStep` (by `ReferenceObjectPath`, then table/schema/name, FK column, target resource, identity flag).",
      "Add/extend unit test(s) asserting `DescriptorEdgeSources` ordering matches the rules in `CanonicalizeOrderingStep` (by table/schema/name, descriptor path, FK column, descriptor resource, identity flag).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Docs",
    "description": "Document two implicit contracts currently enforced by DMS-930 implementation: (1) identity-component document references must be required (`isRequired=true`) when they participate in `identityJsonPaths`; (2) when `arrayUniquenessConstraints` paths point to reference identity fields, the derived unique constraint uses the reference `..._DocumentId` column (stable key) rather than the propagated identity columns. Acceptance: (1) Update `reference/design/backend-redesign/epics/01-relational-model/01-reference-and-constraints.md` to explicitly state both rules and their rationale; (2) Add a short note pointing to the enforcement points in code (`ExtractInputsStep` requiredness check and `ArrayUniquenessConstraintRelationalModelSetPass` reference-path resolution); (3) Ensure doc wording matches the implementation behavior (no ambiguity about which column is used).",
    "steps-to-verify": [
      "Update `reference/design/backend-redesign/epics/01-relational-model/01-reference-and-constraints.md` to include explicit bullets for: identity references must be required; array uniqueness reference identity paths map to the reference FK column.",
      "Verify the doc references the concrete enforcement points: `src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ExtractInputsStep.cs` and `src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/ArrayUniquenessConstraintRelationalModelSetPass.cs`.",
      "Confirm the doc still aligns with `reference/design/backend-redesign/design-docs/flattening-reconstitution.md` semantics."
    ],
    "completed": true
  },
  {
    "category": "Performance",
    "description": "Reduce duplicate schema-input extraction work across passes. `ExtractInputsStep` runs during base traversal per-resource pipelines, and then runs again when later set-level passes call `RelationalModelSetBuilderContext.GetOrCreateResourceBuilderContext`. This duplicates JSON parsing/path compilation for the same resource. Acceptance: (1) Refactor set-level derivation so `ExtractInputsStep` executes at most once per concrete resource per `DerivedRelationalModelSetBuilder.Build` run (excluding resource-extension schemas if they require separate inputs); (2) Add a unit test using a counting/wrapping `ExtractInputsStep` (or an injectable extractor) to assert call counts are exactly 1 per resource; (3) All existing unit tests pass and derived manifests are unchanged.",
    "steps-to-verify": [
      "Introduce a shared per-resource extracted-input cache in `RelationalModelSetBuilderContext` and populate it during base traversal so later passes reuse it instead of re-running `ExtractInputsStep`.",
      "Add unit test that builds a small effective schema set with N resources and asserts the extractor is invoked exactly N times per build (not 2N).",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Correctness",
    "description": "Validate that any constraint path set that includes reference-identity fields is complete before collapsing to `..._DocumentId`. Today, root identity and array uniqueness derivation collapse reference identity paths to the reference FK column (stable key). This is only semantics-preserving when the constraint includes the full referenced identity. Acceptance: (1) If a `documentPathsMapping` reference entry is part of identity (via `identityJsonPaths` / `isPartOfIdentity`), then `identityJsonPaths` must include *all* `referenceJsonPaths[*].referenceJsonPath` for that entry; otherwise fail fast with an error that includes the mapping key, reference object path, and the missing canonical JSONPaths; (2) For each `arrayUniquenessConstraints` scope group, if any path is a reference identity path under a reference object, then that scope's uniqueness path set must include *all* identity paths for that same reference object; otherwise fail fast with an error that includes the scope/basePath (including extension-aligned variants), reference object path, and missing canonical JSONPaths; (3) Add unit tests covering partial reference identity in `identityJsonPaths` and partial reference identity in `arrayUniquenessConstraints` (including a nested constraint case); (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Add a validation step (likely during inputs extraction/validation) that enforces full reference-identity coverage for identity-bearing references (`identityJsonPaths` contains all `referenceJsonPaths[*].referenceJsonPath` for that mapping).",
      "Add a validation step that enforces full reference-identity coverage for each `arrayUniquenessConstraints` scope group when any reference identity path is present (consider nested constraints and extension-aligned `_ext.{project}` paths).",
      "Add failing unit tests demonstrating: (a) identityJsonPaths includes only one identity field under a reference object; (b) arrayUniquenessConstraints includes only one identity field under a reference object; (c) nestedConstraints partial mapping.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  },
  {
    "category": "Maintainability",
    "description": "Refactor `ReferenceConstraintRelationalModelSetPass.BuildReferenceIdentityColumns` to be order-independent. The current implementation assumes `DocumentReferenceMapping.ReferenceJsonPaths` and `DocumentReferenceBinding.IdentityBindings` are aligned by index; this is brittle if bindings are ever canonicalized/sorted independently. Acceptance: (1) Join mapping/reference bindings by canonical `referenceJsonPath` (and/or canonical identity path keys) rather than list index; (2) Fail fast with actionable errors if the mapping and binding sets disagree (missing/extra paths), without relying on list ordering; (3) Add a unit test that exercises a binding list in a different order than the mapping (or otherwise proves ordering is irrelevant) while still producing the same derived FK column sets ordered by target identity order; (4) All existing unit tests pass.",
    "steps-to-verify": [
      "Update `BuildReferenceIdentityColumns` to build a dictionary keyed by `ReferenceJsonPath.Canonical` from `DocumentReferenceBinding.IdentityBindings`, then resolve each `DocumentReferenceMapping.ReferenceJsonPaths` entry via that lookup (no index coupling).",
      "Add a unit test that constructs a resource model with `DocumentReferenceBinding.IdentityBindings` in a different order than the source mapping (e.g., by mutating the binding in a test or by building the model directly) and asserts `ReferenceConstraintRelationalModelSetPass` still derives the correct composite FK column ordering (target identity order) and all-or-none constraint behavior.",
      "Run: `dotnet test --no-restore ./src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit.csproj`"
    ],
    "completed": true
  }
]
