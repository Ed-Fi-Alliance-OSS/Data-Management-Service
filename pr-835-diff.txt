diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/DdlEmissionGoldenTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/DdlEmissionGoldenTests.cs
new file mode 100644
index 000000000..31e035aa6
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/DdlEmissionGoldenTests.cs
@@ -0,0 +1,1406 @@
+// SPDX-License-Identifier: Apache-2.0
+// Licensed to the Ed-Fi Alliance under one or more agreements.
+// The Ed-Fi Alliance licenses this file to you under the Apache License, Version 2.0.
+// See the LICENSE and NOTICES files in the project root for more information.
+
+using System.Diagnostics;
+using EdFi.DataManagementService.Backend.External;
+using FluentAssertions;
+using NUnit.Framework;
+
+namespace EdFi.DataManagementService.Backend.Ddl.Tests.Unit;
+
+/// <summary>
+/// Base class for DDL emission golden file tests.
+/// </summary>
+public abstract class DdlEmissionGoldenTestBase
+{
+    /// <summary>
+    /// Find project root by looking for the .csproj file.
+    /// </summary>
+    protected static string FindProjectRoot(string startDirectory)
+    {
+        var directory = new DirectoryInfo(startDirectory);
+
+        while (directory is not null)
+        {
+            var candidate = Path.Combine(
+                directory.FullName,
+                "EdFi.DataManagementService.Backend.Ddl.Tests.Unit.csproj"
+            );
+            if (File.Exists(candidate))
+            {
+                return directory.FullName;
+            }
+
+            directory = directory.Parent;
+        }
+
+        throw new DirectoryNotFoundException(
+            "Unable to locate EdFi.DataManagementService.Backend.Ddl.Tests.Unit.csproj in parent directories."
+        );
+    }
+
+    /// <summary>
+    /// Run git diff between expected and actual files.
+    /// </summary>
+    protected static string RunGitDiff(string expectedPath, string actualPath)
+    {
+        var startInfo = new ProcessStartInfo("git")
+        {
+            RedirectStandardOutput = true,
+            RedirectStandardError = true,
+            UseShellExecute = false,
+        };
+
+        startInfo.ArgumentList.Add("diff");
+        startInfo.ArgumentList.Add("--no-index");
+        startInfo.ArgumentList.Add("--ignore-space-at-eol");
+        startInfo.ArgumentList.Add("--ignore-cr-at-eol");
+        startInfo.ArgumentList.Add("--");
+        startInfo.ArgumentList.Add(expectedPath);
+        startInfo.ArgumentList.Add(actualPath);
+
+        using var process = new Process { StartInfo = startInfo };
+        process.Start();
+        var outputTask = process.StandardOutput.ReadToEndAsync();
+        var errorTask = process.StandardError.ReadToEndAsync();
+        var output = outputTask.GetAwaiter().GetResult();
+        var error = errorTask.GetAwaiter().GetResult();
+
+        if (!process.WaitForExit(30_000))
+        {
+            process.Kill();
+            return "git diff timed out after 30 seconds";
+        }
+
+        if (process.ExitCode == 0)
+        {
+            return string.Empty;
+        }
+
+        if (process.ExitCode == 1)
+        {
+            return output;
+        }
+
+        return string.IsNullOrWhiteSpace(error) ? output : $"{error}\n{output}".Trim();
+    }
+
+    /// <summary>
+    /// Check if UPDATE_GOLDENS environment variable is set.
+    /// </summary>
+    protected static bool ShouldUpdateGoldens()
+    {
+        var update = Environment.GetEnvironmentVariable("UPDATE_GOLDENS");
+
+        return string.Equals(update, "1", StringComparison.OrdinalIgnoreCase)
+            || string.Equals(update, "true", StringComparison.OrdinalIgnoreCase);
+    }
+
+    /// <summary>
+    /// Emits DDL and writes the actual output file. Call this in SetUp (arrange + act).
+    /// </summary>
+    protected static GoldenTestPaths EmitDdl(
+        string fixtureName,
+        SqlDialect dialect,
+        DerivedRelationalModelSet modelSet
+    )
+    {
+        var projectRoot = FindProjectRoot(TestContext.CurrentContext.TestDirectory);
+        var fixtureRoot = Path.Combine(projectRoot, "Fixtures", "ddl-emission");
+        var dialectName = dialect switch
+        {
+            SqlDialect.Pgsql => "pgsql",
+            SqlDialect.Mssql => "mssql",
+            _ => throw new ArgumentOutOfRangeException(nameof(dialect), dialect, "Unsupported dialect."),
+        };
+        var expectedPath = Path.Combine(fixtureRoot, "expected", dialectName, $"{fixtureName}.sql");
+        var actualPath = Path.Combine(
+            TestContext.CurrentContext.WorkDirectory,
+            "ddl-emission",
+            dialectName,
+            $"{fixtureName}.sql"
+        );
+
+        var dialectRules =
+            dialect == SqlDialect.Pgsql ? (ISqlDialectRules)new PgsqlDialectRules() : new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var ddl = emitter.Emit(modelSet);
+
+        Directory.CreateDirectory(Path.GetDirectoryName(actualPath)!);
+        File.WriteAllText(actualPath, ddl);
+
+        if (ShouldUpdateGoldens())
+        {
+            Directory.CreateDirectory(Path.GetDirectoryName(expectedPath)!);
+            File.WriteAllText(expectedPath, ddl);
+        }
+
+        return new GoldenTestPaths(expectedPath, actualPath);
+    }
+
+    /// <summary>
+    /// Asserts that the emitted DDL matches the golden file. Call this in the test method.
+    /// </summary>
+    protected static void AssertGoldenMatch(GoldenTestPaths paths)
+    {
+        File.Exists(paths.ExpectedPath)
+            .Should()
+            .BeTrue($"Golden file missing at {paths.ExpectedPath}. Set UPDATE_GOLDENS=1 to generate.");
+
+        var diffOutput = RunGitDiff(paths.ExpectedPath, paths.ActualPath);
+
+        if (!string.IsNullOrWhiteSpace(diffOutput))
+        {
+            Assert.Fail(
+                $"DDL output does not match golden file.\n\n"
+                    + $"Expected: {paths.ExpectedPath}\n"
+                    + $"Actual: {paths.ActualPath}\n\n"
+                    + $"Diff:\n{diffOutput}"
+            );
+        }
+    }
+
+    protected record GoldenTestPaths(string ExpectedPath, string ActualPath);
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Golden File Tests - Nested Collections
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_DdlEmitter_With_NestedCollections_For_Pgsql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = NestedCollectionsFixture.Build(SqlDialect.Pgsql);
+        _paths = EmitDdl("nested-collections", SqlDialect.Pgsql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+[TestFixture]
+public class Given_DdlEmitter_With_NestedCollections_For_Mssql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = NestedCollectionsFixture.Build(SqlDialect.Mssql);
+        _paths = EmitDdl("nested-collections", SqlDialect.Mssql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Golden File Tests - Polymorphic Abstract Views
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_DdlEmitter_With_PolymorphicAbstract_For_Pgsql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = PolymorphicAbstractFixture.Build(SqlDialect.Pgsql);
+        _paths = EmitDdl("polymorphic-abstract", SqlDialect.Pgsql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+[TestFixture]
+public class Given_DdlEmitter_With_PolymorphicAbstract_For_Mssql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = PolymorphicAbstractFixture.Build(SqlDialect.Mssql);
+        _paths = EmitDdl("polymorphic-abstract", SqlDialect.Mssql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Golden File Tests - Identity Propagation
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_DdlEmitter_With_IdentityPropagation_For_Pgsql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = IdentityPropagationFixture.Build(SqlDialect.Pgsql);
+        _paths = EmitDdl("identity-propagation", SqlDialect.Pgsql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+[TestFixture]
+public class Given_DdlEmitter_With_IdentityPropagation_For_Mssql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = IdentityPropagationFixture.Build(SqlDialect.Mssql);
+        _paths = EmitDdl("identity-propagation", SqlDialect.Mssql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Golden File Tests - Extension Mapping
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_DdlEmitter_With_ExtensionMapping_For_Pgsql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = ExtensionMappingFixture.Build(SqlDialect.Pgsql);
+        _paths = EmitDdl("extension-mapping", SqlDialect.Pgsql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+[TestFixture]
+public class Given_DdlEmitter_With_ExtensionMapping_For_Mssql : DdlEmissionGoldenTestBase
+{
+    private GoldenTestPaths _paths = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var modelSet = ExtensionMappingFixture.Build(SqlDialect.Mssql);
+        _paths = EmitDdl("extension-mapping", SqlDialect.Mssql, modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_ddl_matching_golden_file()
+    {
+        AssertGoldenMatch(_paths);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Fixture Builders
+// ═══════════════════════════════════════════════════════════════════
+
+/// <summary>
+/// Fixture for nested collections scenario:
+/// School → SchoolAddress → SchoolAddressPhoneNumber
+/// </summary>
+internal static class NestedCollectionsFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
+        // Column names
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var schoolIdColumn = new DbColumnName("SchoolId");
+        var addressOrdinalColumn = new DbColumnName("AddressOrdinal");
+        var streetColumn = new DbColumnName("Street");
+        var phoneOrdinalColumn = new DbColumnName("PhoneNumberOrdinal");
+        var phoneNumberColumn = new DbColumnName("PhoneNumber");
+
+        // Root table: School
+        var schoolTableName = new DbTableName(schema, "School");
+        var schoolTable = new DbTableModel(
+            schoolTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        // Child collection: SchoolAddress
+        var addressTableName = new DbTableName(schema, "SchoolAddress");
+        var addressTable = new DbTableModel(
+            addressTableName,
+            new JsonPathExpression("$.addresses[*]", []),
+            new TableKey(
+                "PK_SchoolAddress",
+                [
+                    new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(addressOrdinalColumn, ColumnKind.Scalar),
+                ]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    addressOrdinalColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    streetColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 100),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolAddress_School",
+                    [documentIdColumn],
+                    schoolTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        // Nested collection: SchoolAddressPhoneNumber
+        var phoneTableName = new DbTableName(schema, "SchoolAddressPhoneNumber");
+        var phoneTable = new DbTableModel(
+            phoneTableName,
+            new JsonPathExpression("$.addresses[*].phoneNumbers[*]", []),
+            new TableKey(
+                "PK_SchoolAddressPhoneNumber",
+                [
+                    new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(addressOrdinalColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(phoneOrdinalColumn, ColumnKind.Scalar),
+                ]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    addressOrdinalColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    phoneOrdinalColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    phoneNumberColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 20),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolAddressPhoneNumber_SchoolAddress",
+                    [documentIdColumn, addressOrdinalColumn],
+                    addressTableName,
+                    [documentIdColumn, addressOrdinalColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            schoolTable,
+            [schoolTable, addressTable, phoneTable],
+            [],
+            []
+        );
+
+        // Triggers
+        List<DbTriggerInfo> triggers =
+        [
+            // DocumentStamping on root table (with identity projection column SchoolId)
+            new(
+                new DbTriggerName("TR_School_Stamp"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // DocumentStamping on child table SchoolAddress (no identity projection)
+            new(
+                new DbTriggerName("TR_SchoolAddress_Stamp"),
+                addressTableName,
+                [documentIdColumn],
+                [],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // DocumentStamping on nested child table (no identity projection)
+            new(
+                new DbTriggerName("TR_SchoolAddressPhoneNumber_Stamp"),
+                phoneTableName,
+                [documentIdColumn],
+                [],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // ReferentialIdentityMaintenance on root table
+            new(
+                new DbTriggerName("TR_School_ReferentialIdentity"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    1,
+                    "Ed-Fi",
+                    "School",
+                    [new IdentityElementMapping(schoolIdColumn, "$.schoolId")]
+                )
+            ),
+        ];
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            triggers
+        );
+    }
+}
+
+/// <summary>
+/// Fixture for polymorphic abstract views scenario:
+/// EducationOrganization (abstract) with School + LEA concrete types
+/// </summary>
+internal static class PolymorphicAbstractFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var discriminatorColumn = new DbColumnName("Discriminator");
+        var organizationIdColumn = new DbColumnName("EducationOrganizationId");
+
+        // Abstract resource
+        var abstractResource = new QualifiedResourceName("Ed-Fi", "EducationOrganization");
+        var abstractResourceKey = new ResourceKeyEntry(1, abstractResource, "1.0.0", true);
+
+        // Concrete resources
+        var schoolResource = new QualifiedResourceName("Ed-Fi", "School");
+        var schoolResourceKey = new ResourceKeyEntry(2, schoolResource, "1.0.0", false);
+
+        var leaResource = new QualifiedResourceName("Ed-Fi", "LocalEducationAgency");
+        var leaResourceKey = new ResourceKeyEntry(3, leaResource, "1.0.0", false);
+
+        // Identity table for abstract type
+        var identityTableName = new DbTableName(schema, "EducationOrganizationIdentity");
+        var identityTable = new DbTableModel(
+            identityTableName,
+            new JsonPathExpression("$", []),
+            new TableKey(
+                "PK_EducationOrganizationIdentity",
+                [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    organizationIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    discriminatorColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 50),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        // School concrete table
+        var schoolTableName = new DbTableName(schema, "School");
+        var schoolTable = new DbTableModel(
+            schoolTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    organizationIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_School_EducationOrganizationIdentity",
+                    [documentIdColumn],
+                    identityTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        // LEA concrete table
+        var leaTableName = new DbTableName(schema, "LocalEducationAgency");
+        var leaTable = new DbTableModel(
+            leaTableName,
+            new JsonPathExpression("$", []),
+            new TableKey(
+                "PK_LocalEducationAgency",
+                [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    organizationIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_LocalEducationAgency_EducationOrganizationIdentity",
+                    [documentIdColumn],
+                    identityTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        // Abstract union view
+        var viewName = new DbTableName(schema, "EducationOrganization");
+        List<AbstractUnionViewOutputColumn> outputColumns =
+        [
+            new(documentIdColumn, new RelationalScalarType(ScalarKind.Int64), null, null),
+            new(organizationIdColumn, new RelationalScalarType(ScalarKind.Int32), null, null),
+            new(discriminatorColumn, new RelationalScalarType(ScalarKind.String, MaxLength: 50), null, null),
+        ];
+
+        var schoolArm = new AbstractUnionViewArm(
+            schoolResourceKey,
+            schoolTableName,
+            [
+                new AbstractUnionViewProjectionExpression.SourceColumn(documentIdColumn),
+                new AbstractUnionViewProjectionExpression.SourceColumn(organizationIdColumn),
+                new AbstractUnionViewProjectionExpression.StringLiteral("School"),
+            ]
+        );
+
+        var leaArm = new AbstractUnionViewArm(
+            leaResourceKey,
+            leaTableName,
+            [
+                new AbstractUnionViewProjectionExpression.SourceColumn(documentIdColumn),
+                new AbstractUnionViewProjectionExpression.SourceColumn(organizationIdColumn),
+                new AbstractUnionViewProjectionExpression.StringLiteral("LocalEducationAgency"),
+            ]
+        );
+
+        var unionView = new AbstractUnionViewInfo(
+            abstractResourceKey,
+            viewName,
+            outputColumns,
+            [schoolArm, leaArm]
+        );
+
+        var abstractIdentityTable = new AbstractIdentityTableInfo(abstractResourceKey, identityTable);
+
+        var schoolRelationalModel = new RelationalResourceModel(
+            schoolResource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            schoolTable,
+            [schoolTable],
+            [],
+            []
+        );
+
+        var leaRelationalModel = new RelationalResourceModel(
+            leaResource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            leaTable,
+            [leaTable],
+            [],
+            []
+        );
+
+        // Triggers
+        var superclassAlias = new SuperclassAliasInfo(
+            1,
+            "Ed-Fi",
+            "EducationOrganization",
+            [new IdentityElementMapping(organizationIdColumn, "$.educationOrganizationId")]
+        );
+
+        List<DbTriggerInfo> triggers =
+        [
+            // DocumentStamping on LEA root (with identity projection)
+            new(
+                new DbTriggerName("TR_LocalEducationAgency_Stamp"),
+                leaTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // AbstractIdentityMaintenance on LEA → EducationOrganizationIdentity
+            new(
+                new DbTriggerName("TR_LocalEducationAgency_AbstractIdentity"),
+                leaTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.AbstractIdentityMaintenance(
+                    identityTableName,
+                    [new TriggerColumnMapping(organizationIdColumn, organizationIdColumn)],
+                    "Ed-Fi:LocalEducationAgency"
+                )
+            ),
+            // ReferentialIdentityMaintenance on LEA
+            new(
+                new DbTriggerName("TR_LocalEducationAgency_ReferentialIdentity"),
+                leaTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    3,
+                    "Ed-Fi",
+                    "LocalEducationAgency",
+                    [new IdentityElementMapping(organizationIdColumn, "$.educationOrganizationId")],
+                    superclassAlias
+                )
+            ),
+            // DocumentStamping on School root (with identity projection)
+            new(
+                new DbTriggerName("TR_School_Stamp"),
+                schoolTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // AbstractIdentityMaintenance on School → EducationOrganizationIdentity
+            new(
+                new DbTriggerName("TR_School_AbstractIdentity"),
+                schoolTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.AbstractIdentityMaintenance(
+                    identityTableName,
+                    [new TriggerColumnMapping(organizationIdColumn, organizationIdColumn)],
+                    "Ed-Fi:School"
+                )
+            ),
+            // ReferentialIdentityMaintenance on School
+            new(
+                new DbTriggerName("TR_School_ReferentialIdentity"),
+                schoolTableName,
+                [documentIdColumn],
+                [organizationIdColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    2,
+                    "Ed-Fi",
+                    "School",
+                    [new IdentityElementMapping(organizationIdColumn, "$.educationOrganizationId")],
+                    superclassAlias
+                )
+            ),
+        ];
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                3,
+                [0x01, 0x02, 0x03],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [abstractResourceKey, schoolResourceKey, leaResourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [
+                new ConcreteResourceModel(
+                    schoolResourceKey,
+                    ResourceStorageKind.RelationalTables,
+                    schoolRelationalModel
+                ),
+                new ConcreteResourceModel(
+                    leaResourceKey,
+                    ResourceStorageKind.RelationalTables,
+                    leaRelationalModel
+                ),
+            ],
+            [abstractIdentityTable],
+            [unionView],
+            [],
+            triggers
+        );
+    }
+}
+
+/// <summary>
+/// Fixture for extension mapping scenario:
+/// School (core) with Sample extension at root and nested collection levels
+/// </summary>
+internal static class ExtensionMappingFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var edfiSchema = new DbSchemaName("edfi");
+        var sampleSchema = new DbSchemaName("sample");
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
+        // Column names
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var schoolIdColumn = new DbColumnName("SchoolId");
+        var addressOrdinalColumn = new DbColumnName("AddressOrdinal");
+        var streetColumn = new DbColumnName("Street");
+        var extensionDataColumn = new DbColumnName("ExtensionData");
+        var addressExtDataColumn = new DbColumnName("AddressExtensionData");
+
+        // Core table: School
+        var schoolTableName = new DbTableName(edfiSchema, "School");
+        var schoolTable = new DbTableModel(
+            schoolTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        // Core collection: SchoolAddress
+        var addressTableName = new DbTableName(edfiSchema, "SchoolAddress");
+        var addressTable = new DbTableModel(
+            addressTableName,
+            new JsonPathExpression("$.addresses[*]", []),
+            new TableKey(
+                "PK_SchoolAddress",
+                [
+                    new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(addressOrdinalColumn, ColumnKind.Scalar),
+                ]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    addressOrdinalColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    streetColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 100),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolAddress_School",
+                    [documentIdColumn],
+                    schoolTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        // Root extension: SchoolExtension
+        var schoolExtTableName = new DbTableName(sampleSchema, "SchoolExtension");
+        var schoolExtTable = new DbTableModel(
+            schoolExtTableName,
+            new JsonPathExpression("$._ext.sample", []),
+            new TableKey("PK_SchoolExtension", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    extensionDataColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 200),
+                    IsNullable: true,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolExtension_School",
+                    [documentIdColumn],
+                    schoolTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        // Nested extension: SchoolAddressExtension
+        var addressExtTableName = new DbTableName(sampleSchema, "SchoolAddressExtension");
+        var addressExtTable = new DbTableModel(
+            addressExtTableName,
+            new JsonPathExpression("$.addresses[*]._ext.sample", []),
+            new TableKey(
+                "PK_SchoolAddressExtension",
+                [
+                    new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(addressOrdinalColumn, ColumnKind.ParentKeyPart),
+                ]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    addressOrdinalColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    addressExtDataColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 100),
+                    IsNullable: true,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolAddressExtension_SchoolAddress",
+                    [documentIdColumn, addressOrdinalColumn],
+                    addressTableName,
+                    [documentIdColumn, addressOrdinalColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            edfiSchema,
+            ResourceStorageKind.RelationalTables,
+            schoolTable,
+            [schoolTable, addressTable, schoolExtTable, addressExtTable],
+            [],
+            []
+        );
+
+        // Triggers
+        List<DbTriggerInfo> triggers =
+        [
+            // DocumentStamping on root table (with identity projection column SchoolId)
+            new(
+                new DbTriggerName("TR_School_Stamp"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // DocumentStamping on child table SchoolAddress (no identity projection)
+            new(
+                new DbTriggerName("TR_SchoolAddress_Stamp"),
+                addressTableName,
+                [documentIdColumn],
+                [],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // DocumentStamping on extension table SchoolAddressExtension (no identity projection)
+            new(
+                new DbTriggerName("TR_SchoolAddressExtension_Stamp"),
+                addressExtTableName,
+                [documentIdColumn],
+                [],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // DocumentStamping on extension table SchoolExtension (no identity projection)
+            new(
+                new DbTriggerName("TR_SchoolExtension_Stamp"),
+                schoolExtTableName,
+                [documentIdColumn],
+                [],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // ReferentialIdentityMaintenance on root table
+            new(
+                new DbTriggerName("TR_School_ReferentialIdentity"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    1,
+                    "Ed-Fi",
+                    "School",
+                    [new IdentityElementMapping(schoolIdColumn, "$.schoolId")]
+                )
+            ),
+        ];
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                    new SchemaComponentInfo(
+                        "sample",
+                        "Sample",
+                        "1.0.0",
+                        false,
+                        "aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [
+                new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, edfiSchema),
+                new ProjectSchemaInfo("sample", "Sample", "1.0.0", false, sampleSchema),
+            ],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            triggers
+        );
+    }
+}
+
+/// <summary>
+/// Fixture for identity propagation fallback scenario (MSSQL only):
+/// StudentSchoolAssociation references School via SchoolId FK.
+/// On MSSQL, an IdentityPropagationFallback trigger on StudentSchoolAssociation
+/// propagates SchoolId changes to the School root table (replacing ON UPDATE CASCADE).
+/// On PostgreSQL, only DocumentStamping and ReferentialIdentityMaintenance are emitted.
+/// </summary>
+internal static class IdentityPropagationFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var schoolIdColumn = new DbColumnName("SchoolId");
+        var studentIdColumn = new DbColumnName("StudentUniqueId");
+        var entryDateColumn = new DbColumnName("EntryDate");
+
+        // School resource
+        var schoolResource = new QualifiedResourceName("Ed-Fi", "School");
+        var schoolResourceKey = new ResourceKeyEntry(1, schoolResource, "1.0.0", false);
+
+        var schoolTableName = new DbTableName(schema, "School");
+        var schoolTable = new DbTableModel(
+            schoolTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        // StudentSchoolAssociation resource
+        var assocResource = new QualifiedResourceName("Ed-Fi", "StudentSchoolAssociation");
+        var assocResourceKey = new ResourceKeyEntry(2, assocResource, "1.0.0", false);
+
+        var assocTableName = new DbTableName(schema, "StudentSchoolAssociation");
+        var assocTable = new DbTableModel(
+            assocTableName,
+            new JsonPathExpression("$", []),
+            new TableKey(
+                "PK_StudentSchoolAssociation",
+                [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    studentIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    entryDateColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Date),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_StudentSchoolAssociation_School",
+                    [schoolIdColumn],
+                    schoolTableName,
+                    [schoolIdColumn],
+                    ReferentialAction.NoAction,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        var schoolRelationalModel = new RelationalResourceModel(
+            schoolResource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            schoolTable,
+            [schoolTable],
+            [],
+            []
+        );
+
+        var assocRelationalModel = new RelationalResourceModel(
+            assocResource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            assocTable,
+            [assocTable],
+            [],
+            []
+        );
+
+        // Triggers
+        List<DbTriggerInfo> triggers =
+        [
+            // DocumentStamping on School root
+            new(
+                new DbTriggerName("TR_School_Stamp"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // ReferentialIdentityMaintenance on School
+            new(
+                new DbTriggerName("TR_School_ReferentialIdentity"),
+                schoolTableName,
+                [documentIdColumn],
+                [schoolIdColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    1,
+                    "Ed-Fi",
+                    "School",
+                    [new IdentityElementMapping(schoolIdColumn, "$.schoolId")]
+                )
+            ),
+            // DocumentStamping on StudentSchoolAssociation root
+            new(
+                new DbTriggerName("TR_StudentSchoolAssociation_Stamp"),
+                assocTableName,
+                [documentIdColumn],
+                [schoolIdColumn, studentIdColumn, entryDateColumn],
+                new TriggerKindParameters.DocumentStamping()
+            ),
+            // ReferentialIdentityMaintenance on StudentSchoolAssociation
+            new(
+                new DbTriggerName("TR_StudentSchoolAssociation_ReferentialIdentity"),
+                assocTableName,
+                [documentIdColumn],
+                [schoolIdColumn, studentIdColumn, entryDateColumn],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    2,
+                    "Ed-Fi",
+                    "StudentSchoolAssociation",
+                    [
+                        new IdentityElementMapping(schoolIdColumn, "$.schoolReference.schoolId"),
+                        new IdentityElementMapping(studentIdColumn, "$.studentReference.studentUniqueId"),
+                        new IdentityElementMapping(entryDateColumn, "$.entryDate"),
+                    ]
+                )
+            ),
+        ];
+
+        // IdentityPropagationFallback — MSSQL only
+        if (dialect == SqlDialect.Mssql)
+        {
+            triggers.Add(
+                new DbTriggerInfo(
+                    new DbTriggerName("TR_StudentSchoolAssociation_Propagation_School"),
+                    assocTableName,
+                    [schoolIdColumn],
+                    [schoolIdColumn],
+                    new TriggerKindParameters.IdentityPropagationFallback(
+                        schoolTableName,
+                        [new TriggerColumnMapping(schoolIdColumn, schoolIdColumn)]
+                    )
+                )
+            );
+        }
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                2,
+                [0x01, 0x02],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [schoolResourceKey, assocResourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [
+                new ConcreteResourceModel(
+                    schoolResourceKey,
+                    ResourceStorageKind.RelationalTables,
+                    schoolRelationalModel
+                ),
+                new ConcreteResourceModel(
+                    assocResourceKey,
+                    ResourceStorageKind.RelationalTables,
+                    assocRelationalModel
+                ),
+            ],
+            [],
+            [],
+            [],
+            triggers
+        );
+    }
+}
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/extension-mapping.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/extension-mapping.sql
new file mode 100644
index 000000000..dc85bdd1e
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/extension-mapping.sql
@@ -0,0 +1,110 @@
+CREATE SCHEMA [edfi];
+CREATE SCHEMA [sample];
+
+CREATE TABLE [edfi].[School] (
+    [DocumentId] bigint NOT NULL,
+    [SchoolId] int NOT NULL,
+    CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [edfi].[SchoolAddress] (
+    [DocumentId] bigint NOT NULL,
+    [AddressOrdinal] int NOT NULL,
+    [Street] nvarchar(100) NOT NULL,
+    CONSTRAINT [PK_SchoolAddress] PRIMARY KEY ([DocumentId], [AddressOrdinal])
+);
+
+CREATE TABLE [sample].[SchoolExtension] (
+    [DocumentId] bigint NOT NULL,
+    [ExtensionData] nvarchar(200) NULL,
+    CONSTRAINT [PK_SchoolExtension] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [sample].[SchoolAddressExtension] (
+    [DocumentId] bigint NOT NULL,
+    [AddressOrdinal] int NOT NULL,
+    [AddressExtensionData] nvarchar(100) NULL,
+    CONSTRAINT [PK_SchoolAddressExtension] PRIMARY KEY ([DocumentId], [AddressOrdinal])
+);
+
+ALTER TABLE [edfi].[SchoolAddress] ADD CONSTRAINT [FK_SchoolAddress_School] FOREIGN KEY ([DocumentId]) REFERENCES [edfi].[School] ([DocumentId]) ON DELETE CASCADE;
+
+ALTER TABLE [sample].[SchoolExtension] ADD CONSTRAINT [FK_SchoolExtension_School] FOREIGN KEY ([DocumentId]) REFERENCES [edfi].[School] ([DocumentId]) ON DELETE CASCADE;
+
+ALTER TABLE [sample].[SchoolAddressExtension] ADD CONSTRAINT [FK_SchoolAddressExtension_SchoolAddress] FOREIGN KEY ([DocumentId], [AddressOrdinal]) REFERENCES [edfi].[SchoolAddress] ([DocumentId], [AddressOrdinal]) ON DELETE CASCADE;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_Stamp]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([SchoolId]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[SchoolId] <> del.[SchoolId] OR (i.[SchoolId] IS NULL AND del.[SchoolId] IS NOT NULL) OR (i.[SchoolId] IS NOT NULL AND del.[SchoolId] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_SchoolAddress_Stamp]
+ON [edfi].[SchoolAddress]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+END;
+
+GO
+CREATE OR ALTER TRIGGER [sample].[TR_SchoolAddressExtension_Stamp]
+ON [sample].[SchoolAddressExtension]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+END;
+
+GO
+CREATE OR ALTER TRIGGER [sample].[TR_SchoolExtension_Stamp]
+ON [sample].[SchoolExtension]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_ReferentialIdentity]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 1;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiSchool' + N'$$.schoolId=' + CAST(i.[SchoolId] AS nvarchar(max))), i.[DocumentId], 1
+    FROM inserted i;
+END;
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/identity-propagation.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/identity-propagation.sql
new file mode 100644
index 000000000..02fd7b22b
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/identity-propagation.sql
@@ -0,0 +1,105 @@
+CREATE SCHEMA [edfi];
+
+CREATE TABLE [edfi].[School] (
+    [DocumentId] bigint NOT NULL,
+    [SchoolId] int NOT NULL,
+    CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [edfi].[StudentSchoolAssociation] (
+    [DocumentId] bigint NOT NULL,
+    [SchoolId] int NOT NULL,
+    [StudentUniqueId] nvarchar(32) NOT NULL,
+    [EntryDate] date NOT NULL,
+    CONSTRAINT [PK_StudentSchoolAssociation] PRIMARY KEY ([DocumentId])
+);
+
+ALTER TABLE [edfi].[StudentSchoolAssociation] ADD CONSTRAINT [FK_StudentSchoolAssociation_School] FOREIGN KEY ([SchoolId]) REFERENCES [edfi].[School] ([SchoolId]);
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_Stamp]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([SchoolId]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[SchoolId] <> del.[SchoolId] OR (i.[SchoolId] IS NULL AND del.[SchoolId] IS NOT NULL) OR (i.[SchoolId] IS NOT NULL AND del.[SchoolId] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_ReferentialIdentity]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 1;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiSchool' + N'$$.schoolId=' + CAST(i.[SchoolId] AS nvarchar(max))), i.[DocumentId], 1
+    FROM inserted i;
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_StudentSchoolAssociation_Stamp]
+ON [edfi].[StudentSchoolAssociation]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([SchoolId]) OR UPDATE([StudentUniqueId]) OR UPDATE([EntryDate]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[SchoolId] <> del.[SchoolId] OR (i.[SchoolId] IS NULL AND del.[SchoolId] IS NOT NULL) OR (i.[SchoolId] IS NOT NULL AND del.[SchoolId] IS NULL)) OR (i.[StudentUniqueId] <> del.[StudentUniqueId] OR (i.[StudentUniqueId] IS NULL AND del.[StudentUniqueId] IS NOT NULL) OR (i.[StudentUniqueId] IS NOT NULL AND del.[StudentUniqueId] IS NULL)) OR (i.[EntryDate] <> del.[EntryDate] OR (i.[EntryDate] IS NULL AND del.[EntryDate] IS NOT NULL) OR (i.[EntryDate] IS NOT NULL AND del.[EntryDate] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_StudentSchoolAssociation_ReferentialIdentity]
+ON [edfi].[StudentSchoolAssociation]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 2;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiStudentSchoolAssociation' + N'$$.schoolReference.schoolId=' + CAST(i.[SchoolId] AS nvarchar(max)) + N'#' + N'$$.studentReference.studentUniqueId=' + CAST(i.[StudentUniqueId] AS nvarchar(max)) + N'#' + N'$$.entryDate=' + CAST(i.[EntryDate] AS nvarchar(max))), i.[DocumentId], 2
+    FROM inserted i;
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_StudentSchoolAssociation_Propagation_School]
+ON [edfi].[StudentSchoolAssociation]
+AFTER UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE t
+    SET t.[SchoolId] = i.[SchoolId]
+    FROM [edfi].[School] t
+    INNER JOIN deleted d ON t.[SchoolId] = d.[SchoolId]
+    INNER JOIN inserted i ON i.[DocumentId] = d.[DocumentId]
+    WHERE (i.[SchoolId] <> d.[SchoolId] OR (i.[SchoolId] IS NULL AND d.[SchoolId] IS NOT NULL) OR (i.[SchoolId] IS NOT NULL AND d.[SchoolId] IS NULL));
+END;
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/nested-collections.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/nested-collections.sql
new file mode 100644
index 000000000..baf29ca4e
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/nested-collections.sql
@@ -0,0 +1,89 @@
+CREATE SCHEMA [edfi];
+
+CREATE TABLE [edfi].[School] (
+    [DocumentId] bigint NOT NULL,
+    [SchoolId] int NOT NULL,
+    CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [edfi].[SchoolAddress] (
+    [DocumentId] bigint NOT NULL,
+    [AddressOrdinal] int NOT NULL,
+    [Street] nvarchar(100) NOT NULL,
+    CONSTRAINT [PK_SchoolAddress] PRIMARY KEY ([DocumentId], [AddressOrdinal])
+);
+
+CREATE TABLE [edfi].[SchoolAddressPhoneNumber] (
+    [DocumentId] bigint NOT NULL,
+    [AddressOrdinal] int NOT NULL,
+    [PhoneNumberOrdinal] int NOT NULL,
+    [PhoneNumber] nvarchar(20) NOT NULL,
+    CONSTRAINT [PK_SchoolAddressPhoneNumber] PRIMARY KEY ([DocumentId], [AddressOrdinal], [PhoneNumberOrdinal])
+);
+
+ALTER TABLE [edfi].[SchoolAddress] ADD CONSTRAINT [FK_SchoolAddress_School] FOREIGN KEY ([DocumentId]) REFERENCES [edfi].[School] ([DocumentId]) ON DELETE CASCADE;
+
+ALTER TABLE [edfi].[SchoolAddressPhoneNumber] ADD CONSTRAINT [FK_SchoolAddressPhoneNumber_SchoolAddress] FOREIGN KEY ([DocumentId], [AddressOrdinal]) REFERENCES [edfi].[SchoolAddress] ([DocumentId], [AddressOrdinal]) ON DELETE CASCADE;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_Stamp]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([SchoolId]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[SchoolId] <> del.[SchoolId] OR (i.[SchoolId] IS NULL AND del.[SchoolId] IS NOT NULL) OR (i.[SchoolId] IS NOT NULL AND del.[SchoolId] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_SchoolAddress_Stamp]
+ON [edfi].[SchoolAddress]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_SchoolAddressPhoneNumber_Stamp]
+ON [edfi].[SchoolAddressPhoneNumber]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_ReferentialIdentity]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 1;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiSchool' + N'$$.schoolId=' + CAST(i.[SchoolId] AS nvarchar(max))), i.[DocumentId], 1
+    FROM inserted i;
+END;
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/polymorphic-abstract.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/polymorphic-abstract.sql
new file mode 100644
index 000000000..e2c43d2f6
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/mssql/polymorphic-abstract.sql
@@ -0,0 +1,144 @@
+CREATE SCHEMA [edfi];
+
+CREATE TABLE [edfi].[School] (
+    [DocumentId] bigint NOT NULL,
+    [EducationOrganizationId] int NOT NULL,
+    CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [edfi].[LocalEducationAgency] (
+    [DocumentId] bigint NOT NULL,
+    [EducationOrganizationId] int NOT NULL,
+    CONSTRAINT [PK_LocalEducationAgency] PRIMARY KEY ([DocumentId])
+);
+
+CREATE TABLE [edfi].[EducationOrganizationIdentity] (
+    [DocumentId] bigint NOT NULL,
+    [EducationOrganizationId] int NOT NULL,
+    [Discriminator] nvarchar(50) NOT NULL,
+    CONSTRAINT [PK_EducationOrganizationIdentity] PRIMARY KEY ([DocumentId])
+);
+
+ALTER TABLE [edfi].[School] ADD CONSTRAINT [FK_School_EducationOrganizationIdentity] FOREIGN KEY ([DocumentId]) REFERENCES [edfi].[EducationOrganizationIdentity] ([DocumentId]) ON DELETE CASCADE;
+
+ALTER TABLE [edfi].[LocalEducationAgency] ADD CONSTRAINT [FK_LocalEducationAgency_EducationOrganizationIdentity] FOREIGN KEY ([DocumentId]) REFERENCES [edfi].[EducationOrganizationIdentity] ([DocumentId]) ON DELETE CASCADE;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_LocalEducationAgency_Stamp]
+ON [edfi].[LocalEducationAgency]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([EducationOrganizationId]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[EducationOrganizationId] <> del.[EducationOrganizationId] OR (i.[EducationOrganizationId] IS NULL AND del.[EducationOrganizationId] IS NOT NULL) OR (i.[EducationOrganizationId] IS NOT NULL AND del.[EducationOrganizationId] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_LocalEducationAgency_AbstractIdentity]
+ON [edfi].[LocalEducationAgency]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    MERGE [edfi].[EducationOrganizationIdentity] AS t
+    USING inserted AS s ON t.[DocumentId] = s.[DocumentId]
+    WHEN MATCHED THEN UPDATE SET t.[EducationOrganizationId] = s.[EducationOrganizationId]
+    WHEN NOT MATCHED THEN INSERT ([DocumentId], [EducationOrganizationId], [Discriminator])
+    VALUES (s.[DocumentId], s.[EducationOrganizationId], N'Ed-Fi:LocalEducationAgency');
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_LocalEducationAgency_ReferentialIdentity]
+ON [edfi].[LocalEducationAgency]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 3;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiLocalEducationAgency' + N'$$.educationOrganizationId=' + CAST(i.[EducationOrganizationId] AS nvarchar(max))), i.[DocumentId], 3
+    FROM inserted i;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 1;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiEducationOrganization' + N'$$.educationOrganizationId=' + CAST(i.[EducationOrganizationId] AS nvarchar(max))), i.[DocumentId], 1
+    FROM inserted i;
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_Stamp]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    UPDATE d
+    SET d.[ContentVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[ContentLastModifiedAt] = sysutcdatetime()
+    FROM [dms].[Document] d
+    INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId];
+    IF EXISTS (SELECT 1 FROM deleted) AND (UPDATE([EducationOrganizationId]))
+    BEGIN
+        UPDATE d
+        SET d.[IdentityVersion] = NEXT VALUE FOR [dms].[ChangeVersionSequence], d.[IdentityLastModifiedAt] = sysutcdatetime()
+        FROM [dms].[Document] d
+        INNER JOIN inserted i ON d.[DocumentId] = i.[DocumentId]
+        INNER JOIN deleted del ON del.[DocumentId] = i.[DocumentId]
+        WHERE (i.[EducationOrganizationId] <> del.[EducationOrganizationId] OR (i.[EducationOrganizationId] IS NULL AND del.[EducationOrganizationId] IS NOT NULL) OR (i.[EducationOrganizationId] IS NOT NULL AND del.[EducationOrganizationId] IS NULL));
+    END
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_AbstractIdentity]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    MERGE [edfi].[EducationOrganizationIdentity] AS t
+    USING inserted AS s ON t.[DocumentId] = s.[DocumentId]
+    WHEN MATCHED THEN UPDATE SET t.[EducationOrganizationId] = s.[EducationOrganizationId]
+    WHEN NOT MATCHED THEN INSERT ([DocumentId], [EducationOrganizationId], [Discriminator])
+    VALUES (s.[DocumentId], s.[EducationOrganizationId], N'Ed-Fi:School');
+END;
+
+GO
+CREATE OR ALTER TRIGGER [edfi].[TR_School_ReferentialIdentity]
+ON [edfi].[School]
+AFTER INSERT, UPDATE
+AS
+BEGIN
+    SET NOCOUNT ON;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 2;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiSchool' + N'$$.educationOrganizationId=' + CAST(i.[EducationOrganizationId] AS nvarchar(max))), i.[DocumentId], 2
+    FROM inserted i;
+    DELETE FROM [dms].[ReferentialIdentity]
+    WHERE [DocumentId] IN (SELECT [DocumentId] FROM inserted) AND [ResourceKeyId] = 1;
+    INSERT INTO [dms].[ReferentialIdentity] ([ReferentialId], [DocumentId], [ResourceKeyId])
+    SELECT [dms].[uuidv5]('edf1edf1-3df1-3df1-3df1-3df1edf1edf1', N'Ed-FiEducationOrganization' + N'$$.educationOrganizationId=' + CAST(i.[EducationOrganizationId] AS nvarchar(max))), i.[DocumentId], 1
+    FROM inserted i;
+END;
+
+GO
+CREATE OR ALTER VIEW [edfi].[EducationOrganization] AS
+SELECT [DocumentId] AS [DocumentId], [EducationOrganizationId] AS [EducationOrganizationId], CAST(N'School' AS nvarchar(50)) AS [Discriminator]
+FROM [edfi].[School]
+UNION ALL
+SELECT [DocumentId] AS [DocumentId], [EducationOrganizationId] AS [EducationOrganizationId], CAST(N'LocalEducationAgency' AS nvarchar(50)) AS [Discriminator]
+FROM [edfi].[LocalEducationAgency]
+;
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/extension-mapping.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/extension-mapping.sql
new file mode 100644
index 000000000..85ca03733
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/extension-mapping.sql
@@ -0,0 +1,116 @@
+CREATE SCHEMA "edfi";
+CREATE SCHEMA "sample";
+
+CREATE TABLE "edfi"."School" (
+    "DocumentId" bigint NOT NULL,
+    "SchoolId" integer NOT NULL,
+    CONSTRAINT "PK_School" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "edfi"."SchoolAddress" (
+    "DocumentId" bigint NOT NULL,
+    "AddressOrdinal" integer NOT NULL,
+    "Street" varchar(100) NOT NULL,
+    CONSTRAINT "PK_SchoolAddress" PRIMARY KEY ("DocumentId", "AddressOrdinal")
+);
+
+CREATE TABLE "sample"."SchoolExtension" (
+    "DocumentId" bigint NOT NULL,
+    "ExtensionData" varchar(200) NULL,
+    CONSTRAINT "PK_SchoolExtension" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "sample"."SchoolAddressExtension" (
+    "DocumentId" bigint NOT NULL,
+    "AddressOrdinal" integer NOT NULL,
+    "AddressExtensionData" varchar(100) NULL,
+    CONSTRAINT "PK_SchoolAddressExtension" PRIMARY KEY ("DocumentId", "AddressOrdinal")
+);
+
+ALTER TABLE "edfi"."SchoolAddress" ADD CONSTRAINT "FK_SchoolAddress_School" FOREIGN KEY ("DocumentId") REFERENCES "edfi"."School" ("DocumentId") ON DELETE CASCADE;
+
+ALTER TABLE "sample"."SchoolExtension" ADD CONSTRAINT "FK_SchoolExtension_School" FOREIGN KEY ("DocumentId") REFERENCES "edfi"."School" ("DocumentId") ON DELETE CASCADE;
+
+ALTER TABLE "sample"."SchoolAddressExtension" ADD CONSTRAINT "FK_SchoolAddressExtension_SchoolAddress" FOREIGN KEY ("DocumentId", "AddressOrdinal") REFERENCES "edfi"."SchoolAddress" ("DocumentId", "AddressOrdinal") ON DELETE CASCADE;
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."SchoolId" IS DISTINCT FROM NEW."SchoolId") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_SchoolAddress_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_SchoolAddress_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."SchoolAddress"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_SchoolAddress_Stamp"();
+
+CREATE OR REPLACE FUNCTION "sample"."TF_TR_SchoolAddressExtension_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_SchoolAddressExtension_Stamp"
+BEFORE INSERT OR UPDATE ON "sample"."SchoolAddressExtension"
+FOR EACH ROW
+EXECUTE FUNCTION "sample"."TF_TR_SchoolAddressExtension_Stamp"();
+
+CREATE OR REPLACE FUNCTION "sample"."TF_TR_SchoolExtension_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_SchoolExtension_Stamp"
+BEFORE INSERT OR UPDATE ON "sample"."SchoolExtension"
+FOR EACH ROW
+EXECUTE FUNCTION "sample"."TF_TR_SchoolExtension_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 1;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiSchool' || '$$.schoolId=' || NEW."SchoolId"::text), NEW."DocumentId", 1);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"();
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/identity-propagation.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/identity-propagation.sql
new file mode 100644
index 000000000..a1b5abdd9
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/identity-propagation.sql
@@ -0,0 +1,90 @@
+CREATE SCHEMA "edfi";
+
+CREATE TABLE "edfi"."School" (
+    "DocumentId" bigint NOT NULL,
+    "SchoolId" integer NOT NULL,
+    CONSTRAINT "PK_School" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "edfi"."StudentSchoolAssociation" (
+    "DocumentId" bigint NOT NULL,
+    "SchoolId" integer NOT NULL,
+    "StudentUniqueId" varchar(32) NOT NULL,
+    "EntryDate" date NOT NULL,
+    CONSTRAINT "PK_StudentSchoolAssociation" PRIMARY KEY ("DocumentId")
+);
+
+ALTER TABLE "edfi"."StudentSchoolAssociation" ADD CONSTRAINT "FK_StudentSchoolAssociation_School" FOREIGN KEY ("SchoolId") REFERENCES "edfi"."School" ("SchoolId");
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."SchoolId" IS DISTINCT FROM NEW."SchoolId") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 1;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiSchool' || '$$.schoolId=' || NEW."SchoolId"::text), NEW."DocumentId", 1);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_StudentSchoolAssociation_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."SchoolId" IS DISTINCT FROM NEW."SchoolId" OR OLD."StudentUniqueId" IS DISTINCT FROM NEW."StudentUniqueId" OR OLD."EntryDate" IS DISTINCT FROM NEW."EntryDate") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_StudentSchoolAssociation_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."StudentSchoolAssociation"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_StudentSchoolAssociation_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_StudentSchoolAssociation_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 2;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiStudentSchoolAssociation' || '$$.schoolReference.schoolId=' || NEW."SchoolId"::text || '#' || '$$.studentReference.studentUniqueId=' || NEW."StudentUniqueId"::text || '#' || '$$.entryDate=' || NEW."EntryDate"::text), NEW."DocumentId", 2);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_StudentSchoolAssociation_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."StudentSchoolAssociation"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_StudentSchoolAssociation_ReferentialIdentity"();
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/nested-collections.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/nested-collections.sql
new file mode 100644
index 000000000..e344e73e0
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/nested-collections.sql
@@ -0,0 +1,93 @@
+CREATE SCHEMA "edfi";
+
+CREATE TABLE "edfi"."School" (
+    "DocumentId" bigint NOT NULL,
+    "SchoolId" integer NOT NULL,
+    CONSTRAINT "PK_School" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "edfi"."SchoolAddress" (
+    "DocumentId" bigint NOT NULL,
+    "AddressOrdinal" integer NOT NULL,
+    "Street" varchar(100) NOT NULL,
+    CONSTRAINT "PK_SchoolAddress" PRIMARY KEY ("DocumentId", "AddressOrdinal")
+);
+
+CREATE TABLE "edfi"."SchoolAddressPhoneNumber" (
+    "DocumentId" bigint NOT NULL,
+    "AddressOrdinal" integer NOT NULL,
+    "PhoneNumberOrdinal" integer NOT NULL,
+    "PhoneNumber" varchar(20) NOT NULL,
+    CONSTRAINT "PK_SchoolAddressPhoneNumber" PRIMARY KEY ("DocumentId", "AddressOrdinal", "PhoneNumberOrdinal")
+);
+
+ALTER TABLE "edfi"."SchoolAddress" ADD CONSTRAINT "FK_SchoolAddress_School" FOREIGN KEY ("DocumentId") REFERENCES "edfi"."School" ("DocumentId") ON DELETE CASCADE;
+
+ALTER TABLE "edfi"."SchoolAddressPhoneNumber" ADD CONSTRAINT "FK_SchoolAddressPhoneNumber_SchoolAddress" FOREIGN KEY ("DocumentId", "AddressOrdinal") REFERENCES "edfi"."SchoolAddress" ("DocumentId", "AddressOrdinal") ON DELETE CASCADE;
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."SchoolId" IS DISTINCT FROM NEW."SchoolId") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_SchoolAddress_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_SchoolAddress_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."SchoolAddress"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_SchoolAddress_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_SchoolAddressPhoneNumber_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_SchoolAddressPhoneNumber_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."SchoolAddressPhoneNumber"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_SchoolAddressPhoneNumber_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 1;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiSchool' || '$$.schoolId=' || NEW."SchoolId"::text), NEW."DocumentId", 1);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"();
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/polymorphic-abstract.sql b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/polymorphic-abstract.sql
new file mode 100644
index 000000000..776c9441c
--- /dev/null
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/Fixtures/ddl-emission/expected/pgsql/polymorphic-abstract.sql
@@ -0,0 +1,145 @@
+CREATE SCHEMA "edfi";
+
+CREATE TABLE "edfi"."School" (
+    "DocumentId" bigint NOT NULL,
+    "EducationOrganizationId" integer NOT NULL,
+    CONSTRAINT "PK_School" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "edfi"."LocalEducationAgency" (
+    "DocumentId" bigint NOT NULL,
+    "EducationOrganizationId" integer NOT NULL,
+    CONSTRAINT "PK_LocalEducationAgency" PRIMARY KEY ("DocumentId")
+);
+
+CREATE TABLE "edfi"."EducationOrganizationIdentity" (
+    "DocumentId" bigint NOT NULL,
+    "EducationOrganizationId" integer NOT NULL,
+    "Discriminator" varchar(50) NOT NULL,
+    CONSTRAINT "PK_EducationOrganizationIdentity" PRIMARY KEY ("DocumentId")
+);
+
+ALTER TABLE "edfi"."School" ADD CONSTRAINT "FK_School_EducationOrganizationIdentity" FOREIGN KEY ("DocumentId") REFERENCES "edfi"."EducationOrganizationIdentity" ("DocumentId") ON DELETE CASCADE;
+
+ALTER TABLE "edfi"."LocalEducationAgency" ADD CONSTRAINT "FK_LocalEducationAgency_EducationOrganizationIdentity" FOREIGN KEY ("DocumentId") REFERENCES "edfi"."EducationOrganizationIdentity" ("DocumentId") ON DELETE CASCADE;
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_LocalEducationAgency_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."EducationOrganizationId" IS DISTINCT FROM NEW."EducationOrganizationId") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_LocalEducationAgency_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."LocalEducationAgency"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_LocalEducationAgency_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_LocalEducationAgency_AbstractIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    INSERT INTO "edfi"."EducationOrganizationIdentity" ("DocumentId", "EducationOrganizationId", "Discriminator")
+    VALUES (NEW."DocumentId", NEW."EducationOrganizationId", 'Ed-Fi:LocalEducationAgency')
+    ON CONFLICT ("DocumentId")
+    DO UPDATE SET "EducationOrganizationId" = EXCLUDED."EducationOrganizationId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_LocalEducationAgency_AbstractIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."LocalEducationAgency"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_LocalEducationAgency_AbstractIdentity"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_LocalEducationAgency_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 3;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiLocalEducationAgency' || '$$.educationOrganizationId=' || NEW."EducationOrganizationId"::text), NEW."DocumentId", 3);
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 1;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiEducationOrganization' || '$$.educationOrganizationId=' || NEW."EducationOrganizationId"::text), NEW."DocumentId", 1);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_LocalEducationAgency_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."LocalEducationAgency"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_LocalEducationAgency_ReferentialIdentity"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_Stamp"()
+RETURNS TRIGGER AS $$
+BEGIN
+    UPDATE "dms"."Document"
+    SET "ContentVersion" = nextval('"dms"."ChangeVersionSequence"'), "ContentLastModifiedAt" = now()
+    WHERE "DocumentId" = NEW."DocumentId";
+    IF TG_OP = 'UPDATE' AND (OLD."EducationOrganizationId" IS DISTINCT FROM NEW."EducationOrganizationId") THEN
+        UPDATE "dms"."Document"
+        SET "IdentityVersion" = nextval('"dms"."ChangeVersionSequence"'), "IdentityLastModifiedAt" = now()
+        WHERE "DocumentId" = NEW."DocumentId";
+    END IF;
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_Stamp"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_Stamp"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_AbstractIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    INSERT INTO "edfi"."EducationOrganizationIdentity" ("DocumentId", "EducationOrganizationId", "Discriminator")
+    VALUES (NEW."DocumentId", NEW."EducationOrganizationId", 'Ed-Fi:School')
+    ON CONFLICT ("DocumentId")
+    DO UPDATE SET "EducationOrganizationId" = EXCLUDED."EducationOrganizationId";
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_AbstractIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_AbstractIdentity"();
+
+CREATE OR REPLACE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"()
+RETURNS TRIGGER AS $$
+BEGIN
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 2;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiSchool' || '$$.educationOrganizationId=' || NEW."EducationOrganizationId"::text), NEW."DocumentId", 2);
+    DELETE FROM "dms"."ReferentialIdentity"
+    WHERE "DocumentId" = NEW."DocumentId" AND "ResourceKeyId" = 1;
+    INSERT INTO "dms"."ReferentialIdentity" ("ReferentialId", "DocumentId", "ResourceKeyId")
+    VALUES ("dms"."uuidv5"('edf1edf1-3df1-3df1-3df1-3df1edf1edf1'::uuid, 'Ed-FiEducationOrganization' || '$$.educationOrganizationId=' || NEW."EducationOrganizationId"::text), NEW."DocumentId", 1);
+    RETURN NEW;
+END;
+$$ LANGUAGE plpgsql;
+
+CREATE OR REPLACE TRIGGER "TR_School_ReferentialIdentity"
+BEFORE INSERT OR UPDATE ON "edfi"."School"
+FOR EACH ROW
+EXECUTE FUNCTION "edfi"."TF_TR_School_ReferentialIdentity"();
+
+CREATE OR REPLACE VIEW "edfi"."EducationOrganization" AS
+SELECT "DocumentId" AS "DocumentId", "EducationOrganizationId" AS "EducationOrganizationId", 'School'::varchar(50) AS "Discriminator"
+FROM "edfi"."School"
+UNION ALL
+SELECT "DocumentId" AS "DocumentId", "EducationOrganizationId" AS "EducationOrganizationId", 'LocalEducationAgency'::varchar(50) AS "Discriminator"
+FROM "edfi"."LocalEducationAgency"
+;
+
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/RelationalModelDdlEmitterTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/RelationalModelDdlEmitterTests.cs
index 7e601c9ec..4dbb4950a 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/RelationalModelDdlEmitterTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/RelationalModelDdlEmitterTests.cs
@@ -9,85 +9,1190 @@
 
 namespace EdFi.DataManagementService.Backend.Ddl.Tests.Unit;
 
+// ═══════════════════════════════════════════════════════════════════
+// Phase Ordering Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Foreign_Keys
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = ForeignKeyFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_schemas_first()
+    {
+        _ddl.Should().Contain("CREATE SCHEMA");
+    }
+
+    [Test]
+    public void It_should_emit_foreign_keys_after_tables()
+    {
+        var schemaIndex = _ddl.IndexOf("CREATE SCHEMA");
+        var tableIndex = _ddl.IndexOf("CREATE TABLE");
+        var fkIndex = _ddl.IndexOf("ALTER TABLE");
+
+        schemaIndex.Should().BeLessThan(tableIndex);
+        tableIndex.Should().BeLessThan(fkIndex);
+    }
+
+    [Test]
+    public void It_should_not_include_foreign_keys_in_create_table()
+    {
+        var createTableEndIndex = _ddl.IndexOf(");", _ddl.IndexOf("CREATE TABLE"));
+        var firstFkIndex = _ddl.IndexOf("FOREIGN KEY");
+
+        firstFkIndex.Should().BeGreaterOrEqualTo(0, "expected at least one FOREIGN KEY in emitted DDL");
+        firstFkIndex.Should().BeGreaterThan(createTableEndIndex);
+    }
+
+    [Test]
+    public void It_should_emit_foreign_keys_with_alter_table()
+    {
+        _ddl.Should().Contain("ALTER TABLE");
+        _ddl.Should().Contain("ADD CONSTRAINT");
+        _ddl.Should().Contain("FOREIGN KEY");
+        _ddl.Should().Contain("REFERENCES");
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Foreign_Keys
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = ForeignKeyFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_foreign_keys_after_tables()
+    {
+        var tableIndex = _ddl.IndexOf("CREATE TABLE");
+        var fkIndex = _ddl.IndexOf("ALTER TABLE");
+
+        tableIndex.Should().BeLessThan(fkIndex);
+    }
+
+    [Test]
+    public void It_should_not_include_foreign_keys_in_create_table()
+    {
+        var createTableEndIndex = _ddl.IndexOf(");", _ddl.IndexOf("CREATE TABLE"));
+        var firstFkIndex = _ddl.IndexOf("FOREIGN KEY");
+
+        firstFkIndex.Should().BeGreaterOrEqualTo(0, "expected at least one FOREIGN KEY in emitted DDL");
+        firstFkIndex.Should().BeGreaterThan(createTableEndIndex);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Unbounded String Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Unbounded_String
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = UnboundedStringFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_varchar_without_max_suffix()
+    {
+        _ddl.Should().Contain("\"UnboundedColumn\" varchar NOT NULL");
+    }
+
+    [Test]
+    public void It_should_not_emit_varchar_max_for_postgresql()
+    {
+        _ddl.Should().NotContain("varchar(max)");
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Unbounded_String
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = UnboundedStringFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_nvarchar_max_for_unbounded_string()
+    {
+        _ddl.Should().Contain("[UnboundedColumn] nvarchar(max) NOT NULL");
+    }
+
+    [Test]
+    public void It_should_not_emit_bare_nvarchar()
+    {
+        _ddl.Should().NotContain("nvarchar NOT NULL");
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Abstract Identity Table Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Abstract_Identity_Table
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = AbstractIdentityTableFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_abstract_identity_table()
+    {
+        _ddl.Should().Contain("CREATE TABLE \"edfi\".\"EducationOrganizationIdentity\"");
+    }
+
+    [Test]
+    public void It_should_include_discriminator_column()
+    {
+        _ddl.Should().Contain("\"Discriminator\"");
+    }
+
+    [Test]
+    public void It_should_include_primary_key()
+    {
+        _ddl.Should().Contain("PRIMARY KEY");
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Abstract_Identity_Table
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = AbstractIdentityTableFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_abstract_identity_table()
+    {
+        _ddl.Should().Contain("CREATE TABLE [edfi].[EducationOrganizationIdentity]");
+    }
+
+    [Test]
+    public void It_should_include_discriminator_column()
+    {
+        _ddl.Should().Contain("[Discriminator]");
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Abstract Union View Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Abstract_Union_View
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = AbstractUnionViewFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_create_or_replace_view()
+    {
+        _ddl.Should().Contain("CREATE OR REPLACE VIEW");
+    }
+
+    [Test]
+    public void It_should_include_union_all()
+    {
+        _ddl.Should().Contain("UNION ALL");
+    }
+
+    [Test]
+    public void It_should_emit_views_after_tables_and_indexes()
+    {
+        var tableIndex = _ddl.IndexOf("CREATE TABLE");
+        var viewIndex = _ddl.IndexOf("CREATE OR REPLACE VIEW");
+
+        viewIndex.Should().BeGreaterThan(tableIndex);
+    }
+
+    [Test]
+    public void It_should_emit_discriminator_literal_with_postgresql_cast()
+    {
+        _ddl.Should().Contain("'School'::varchar");
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Abstract_Union_View
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = AbstractUnionViewFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_create_or_alter_view()
+    {
+        _ddl.Should().Contain("CREATE OR ALTER VIEW");
+    }
+
+    [Test]
+    public void It_should_include_union_all()
+    {
+        _ddl.Should().Contain("UNION ALL");
+    }
+
+    [Test]
+    public void It_should_emit_discriminator_literal_with_sql_server_cast()
+    {
+        _ddl.Should().Contain("CAST(N'School' AS nvarchar(");
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Trigger Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Triggers
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = TriggerFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_trigger_function()
+    {
+        _ddl.Should().Contain("CREATE OR REPLACE FUNCTION");
+        _ddl.Should().Contain("RETURNS TRIGGER");
+    }
+
+    [Test]
+    public void It_should_emit_trigger()
+    {
+        _ddl.Should().Contain("CREATE OR REPLACE TRIGGER");
+        _ddl.Should().Contain("EXECUTE FUNCTION");
+    }
+
+    [Test]
+    public void It_should_emit_plpgsql_language()
+    {
+        _ddl.Should().Contain("$$ LANGUAGE plpgsql");
+    }
+
+    [Test]
+    public void It_should_emit_return_new()
+    {
+        _ddl.Should().Contain("RETURN NEW;");
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Triggers
+{
+    private string _ddl = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = TriggerFixture.Build(dialectRules.Dialect);
+
+        _ddl = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_create_or_alter_trigger()
+    {
+        _ddl.Should().Contain("CREATE OR ALTER TRIGGER");
+    }
+
+    [Test]
+    public void It_should_emit_after_insert_update()
+    {
+        _ddl.Should().Contain("AFTER INSERT, UPDATE");
+    }
+
+    [Test]
+    public void It_should_emit_set_nocount_on()
+    {
+        _ddl.Should().Contain("SET NOCOUNT ON;");
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Determinism Tests
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Pgsql_Emitting_Twice
+{
+    private string _first = default!;
+    private string _second = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = ForeignKeyFixture.Build(dialectRules.Dialect);
+
+        _first = emitter.Emit(modelSet);
+        _second = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_produce_byte_for_byte_identical_output()
+    {
+        _first.Should().Be(_second);
+    }
+}
+
+[TestFixture]
+public class Given_RelationalModelDdlEmitter_With_Mssql_Emitting_Twice
+{
+    private string _first = default!;
+    private string _second = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = ForeignKeyFixture.Build(dialectRules.Dialect);
+
+        _first = emitter.Emit(modelSet);
+        _second = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_produce_byte_for_byte_identical_output()
+    {
+        _first.Should().Be(_second);
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Basic Tests (existing)
+// ═══════════════════════════════════════════════════════════════════
+
+[TestFixture]
+public class Given_Pgsql_Ddl_Emitter_With_Primary_Key_Constraint_Name
+{
+    private string _sql = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new PgsqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = PrimaryKeyFixture.Build(dialectRules.Dialect, "PK_School");
+
+        _sql = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_named_primary_key_constraint()
+    {
+        _sql.Should().Contain("CONSTRAINT \"PK_School\" PRIMARY KEY (\"DocumentId\")");
+    }
+}
+
+[TestFixture]
+public class Given_Mssql_Ddl_Emitter_With_Primary_Key_Constraint_Name
+{
+    private string _sql = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        var dialectRules = new MssqlDialectRules();
+        var emitter = new RelationalModelDdlEmitter(dialectRules);
+        var modelSet = PrimaryKeyFixture.Build(dialectRules.Dialect, "PK_School");
+
+        _sql = emitter.Emit(modelSet);
+    }
+
+    [Test]
+    public void It_should_emit_named_primary_key_constraint()
+    {
+        _sql.Should().Contain("CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])");
+    }
+}
+
+internal static class PrimaryKeyFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect, string primaryKeyName)
+    {
+        var schema = new DbSchemaName("edfi");
+        var tableName = new DbTableName(schema, "School");
+        var columnName = new DbColumnName("DocumentId");
+        var keyColumn = new DbKeyColumn(columnName, ColumnKind.ParentKeyPart);
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+        var table = new DbTableModel(
+            tableName,
+            new JsonPathExpression("$", []),
+            new TableKey(primaryKeyName, [keyColumn]),
+            [
+                new DbColumnModel(
+                    columnName,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            table,
+            [table],
+            [],
+            []
+        );
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            []
+        );
+    }
+}
+
+internal static class ForeignKeyFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var parentTableName = new DbTableName(schema, "School");
+        var childTableName = new DbTableName(schema, "SchoolAddress");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var schoolIdColumn = new DbColumnName("SchoolId");
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
+        var parentTable = new DbTableModel(
+            parentTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        var childTable = new DbTableModel(
+            childTableName,
+            new JsonPathExpression("$.addresses[*]", []),
+            new TableKey(
+                "PK_SchoolAddress",
+                [
+                    new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart),
+                    new DbKeyColumn(new DbColumnName("AddressTypeId"), ColumnKind.Scalar),
+                ]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    new DbColumnName("AddressTypeId"),
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolAddress_School",
+                    [documentIdColumn],
+                    parentTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            parentTable,
+            [parentTable, childTable],
+            [],
+            []
+        );
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            []
+        );
+    }
+}
+
+internal static class UnboundedStringFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var tableName = new DbTableName(schema, "School");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var unboundedColumn = new DbColumnName("UnboundedColumn");
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
+        var table = new DbTableModel(
+            tableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    unboundedColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: null), // Unbounded
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            schema,
+            ResourceStorageKind.RelationalTables,
+            table,
+            [table],
+            [],
+            []
+        );
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            []
+        );
+    }
+}
+
+internal static class AbstractIdentityTableFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var identityTableName = new DbTableName(schema, "EducationOrganizationIdentity");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var discriminatorColumn = new DbColumnName("Discriminator");
+        var resource = new QualifiedResourceName("Ed-Fi", "EducationOrganization");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", true); // Abstract
+
+        var identityTable = new DbTableModel(
+            identityTableName,
+            new JsonPathExpression("$", []),
+            new TableKey(
+                "PK_EducationOrganizationIdentity",
+                [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    discriminatorColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 50),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        var abstractIdentityTable = new AbstractIdentityTableInfo(resourceKey, identityTable);
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [],
+            [abstractIdentityTable],
+            [],
+            [],
+            []
+        );
+    }
+}
+
+internal static class AbstractUnionViewFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var schema = new DbSchemaName("edfi");
+        var schoolTableName = new DbTableName(schema, "School");
+        var districtTableName = new DbTableName(schema, "LocalEducationAgency");
+        var viewName = new DbTableName(schema, "EducationOrganization");
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var discriminatorColumn = new DbColumnName("Discriminator");
+
+        var abstractResource = new QualifiedResourceName("Ed-Fi", "EducationOrganization");
+        var schoolResource = new QualifiedResourceName("Ed-Fi", "School");
+        var districtResource = new QualifiedResourceName("Ed-Fi", "LocalEducationAgency");
+        var abstractResourceKey = new ResourceKeyEntry(1, abstractResource, "1.0.0", true);
+        var schoolResourceKey = new ResourceKeyEntry(2, schoolResource, "1.0.0", false);
+        var districtResourceKey = new ResourceKeyEntry(3, districtResource, "1.0.0", false);
+
+        List<AbstractUnionViewOutputColumn> outputColumns =
+        [
+            new(documentIdColumn, new RelationalScalarType(ScalarKind.Int64), null, null),
+            new(discriminatorColumn, new RelationalScalarType(ScalarKind.String, MaxLength: 50), null, null),
+        ];
+
+        var schoolArm = new AbstractUnionViewArm(
+            schoolResourceKey,
+            schoolTableName,
+            [
+                new AbstractUnionViewProjectionExpression.SourceColumn(documentIdColumn),
+                new AbstractUnionViewProjectionExpression.StringLiteral("School"),
+            ]
+        );
+
+        var districtArm = new AbstractUnionViewArm(
+            districtResourceKey,
+            districtTableName,
+            [
+                new AbstractUnionViewProjectionExpression.SourceColumn(documentIdColumn),
+                new AbstractUnionViewProjectionExpression.StringLiteral("LocalEducationAgency"),
+            ]
+        );
+
+        var unionView = new AbstractUnionViewInfo(
+            abstractResourceKey,
+            viewName,
+            outputColumns,
+            [schoolArm, districtArm]
+        );
+
+        // Create identity table
+        var identityTable = new DbTableModel(
+            new DbTableName(schema, "EducationOrganizationIdentity"),
+            new JsonPathExpression("$", []),
+            new TableKey(
+                "PK_EducationOrganizationIdentity",
+                [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]
+            ),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    discriminatorColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 50),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        var abstractIdentityTable = new AbstractIdentityTableInfo(abstractResourceKey, identityTable);
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                3,
+                [0x01, 0x02, 0x03],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                ],
+                [abstractResourceKey, schoolResourceKey, districtResourceKey]
+            ),
+            dialect,
+            [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
+            [],
+            [abstractIdentityTable],
+            [unionView],
+            [],
+            []
+        );
+    }
+}
+
+// ═══════════════════════════════════════════════════════════════════
+// Extension Table Tests
+// ═══════════════════════════════════════════════════════════════════
+
 [TestFixture]
-public class Given_Pgsql_Ddl_Emitter_With_Primary_Key_Constraint_Name
+public class Given_RelationalModelDdlEmitter_With_Pgsql_And_Extension_Tables
 {
-    private string _sql = default!;
+    private string _ddl = default!;
 
     [SetUp]
     public void Setup()
     {
         var dialectRules = new PgsqlDialectRules();
         var emitter = new RelationalModelDdlEmitter(dialectRules);
-        var modelSet = PrimaryKeyFixture.Build(dialectRules.Dialect, "PK_School");
+        var modelSet = ExtensionTableFixture.Build(dialectRules.Dialect);
 
-        _sql = emitter.Emit(modelSet);
+        _ddl = emitter.Emit(modelSet);
     }
 
     [Test]
-    public void It_should_emit_named_primary_key_constraint()
+    public void It_should_create_core_schema()
     {
-        _sql.Should().Contain("CONSTRAINT \"PK_School\" PRIMARY KEY (\"DocumentId\")");
+        _ddl.Should().Contain("CREATE SCHEMA \"edfi\"");
+    }
+
+    [Test]
+    public void It_should_create_extension_schema()
+    {
+        _ddl.Should().Contain("CREATE SCHEMA \"sample\"");
+    }
+
+    [Test]
+    public void It_should_create_extension_table_in_extension_schema()
+    {
+        _ddl.Should().Contain("CREATE TABLE \"sample\".\"SchoolExtension\"");
+    }
+
+    [Test]
+    public void It_should_create_cascade_fk_to_base_table()
+    {
+        _ddl.Should().Contain("\"FK_SchoolExtension_School\"");
+        _ddl.Should().Contain("REFERENCES \"edfi\".\"School\"");
+        _ddl.Should().Contain("ON DELETE CASCADE");
+    }
+
+    [Test]
+    public void It_should_emit_extension_schema_before_extension_tables()
+    {
+        var sampleSchemaIndex = _ddl.IndexOf("CREATE SCHEMA \"sample\"");
+        var extensionTableIndex = _ddl.IndexOf("CREATE TABLE \"sample\".\"SchoolExtension\"");
+
+        sampleSchemaIndex.Should().BeLessThan(extensionTableIndex);
+    }
+
+    [Test]
+    public void It_should_emit_base_table_before_extension_table()
+    {
+        var baseTableIndex = _ddl.IndexOf("CREATE TABLE \"edfi\".\"School\"");
+        var extensionTableIndex = _ddl.IndexOf("CREATE TABLE \"sample\".\"SchoolExtension\"");
+
+        baseTableIndex.Should().BeLessThan(extensionTableIndex);
     }
 }
 
 [TestFixture]
-public class Given_Mssql_Ddl_Emitter_With_Primary_Key_Constraint_Name
+public class Given_RelationalModelDdlEmitter_With_Mssql_And_Extension_Tables
 {
-    private string _sql = default!;
+    private string _ddl = default!;
 
     [SetUp]
     public void Setup()
     {
         var dialectRules = new MssqlDialectRules();
         var emitter = new RelationalModelDdlEmitter(dialectRules);
-        var modelSet = PrimaryKeyFixture.Build(dialectRules.Dialect, "PK_School");
+        var modelSet = ExtensionTableFixture.Build(dialectRules.Dialect);
 
-        _sql = emitter.Emit(modelSet);
+        _ddl = emitter.Emit(modelSet);
     }
 
     [Test]
-    public void It_should_emit_named_primary_key_constraint()
+    public void It_should_create_extension_table_in_extension_schema()
     {
-        _sql.Should().Contain("CONSTRAINT [PK_School] PRIMARY KEY ([DocumentId])");
+        _ddl.Should().Contain("CREATE TABLE [sample].[SchoolExtension]");
+    }
+
+    [Test]
+    public void It_should_create_cascade_fk_to_base_table()
+    {
+        _ddl.Should().Contain("[FK_SchoolExtension_School]");
+        _ddl.Should().Contain("REFERENCES [edfi].[School]");
+        _ddl.Should().Contain("ON DELETE CASCADE");
+    }
+
+    [Test]
+    public void It_should_emit_base_table_before_extension_table()
+    {
+        var baseTableIndex = _ddl.IndexOf("CREATE TABLE [edfi].[School]");
+        var extensionTableIndex = _ddl.IndexOf("CREATE TABLE [sample].[SchoolExtension]");
+
+        baseTableIndex.Should().BeLessThan(extensionTableIndex);
     }
 }
 
-internal static class PrimaryKeyFixture
+internal static class ExtensionTableFixture
 {
-    internal static DerivedRelationalModelSet Build(SqlDialect dialect, string primaryKeyName)
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
+    {
+        var edfiSchema = new DbSchemaName("edfi");
+        var sampleSchema = new DbSchemaName("sample");
+        var resource = new QualifiedResourceName("Ed-Fi", "School");
+        var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
+        var documentIdColumn = new DbColumnName("DocumentId");
+        var schoolIdColumn = new DbColumnName("SchoolId");
+        var extensionDataColumn = new DbColumnName("ExtensionData");
+
+        // Core table: School
+        var schoolTableName = new DbTableName(edfiSchema, "School");
+        var schoolTable = new DbTableModel(
+            schoolTableName,
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    schoolIdColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.Int32),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            []
+        );
+
+        // Extension table: SchoolExtension
+        var schoolExtTableName = new DbTableName(sampleSchema, "SchoolExtension");
+        var schoolExtTable = new DbTableModel(
+            schoolExtTableName,
+            new JsonPathExpression("$._ext.sample", []),
+            new TableKey("PK_SchoolExtension", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
+                new DbColumnModel(
+                    documentIdColumn,
+                    ColumnKind.ParentKeyPart,
+                    new RelationalScalarType(ScalarKind.Int64),
+                    IsNullable: false,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+                new DbColumnModel(
+                    extensionDataColumn,
+                    ColumnKind.Scalar,
+                    new RelationalScalarType(ScalarKind.String, MaxLength: 200),
+                    IsNullable: true,
+                    SourceJsonPath: null,
+                    TargetResource: null
+                ),
+            ],
+            [
+                new TableConstraint.ForeignKey(
+                    "FK_SchoolExtension_School",
+                    [documentIdColumn],
+                    schoolTableName,
+                    [documentIdColumn],
+                    ReferentialAction.Cascade,
+                    ReferentialAction.NoAction
+                ),
+            ]
+        );
+
+        var relationalModel = new RelationalResourceModel(
+            resource,
+            edfiSchema,
+            ResourceStorageKind.RelationalTables,
+            schoolTable,
+            [schoolTable, schoolExtTable],
+            [],
+            []
+        );
+
+        return new DerivedRelationalModelSet(
+            new EffectiveSchemaInfo(
+                "1.0.0",
+                "1.0.0",
+                "hash",
+                1,
+                [0x01],
+                [
+                    new SchemaComponentInfo(
+                        "ed-fi",
+                        "Ed-Fi",
+                        "1.0.0",
+                        false,
+                        "edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1edf1"
+                    ),
+                    new SchemaComponentInfo(
+                        "sample",
+                        "Sample",
+                        "1.0.0",
+                        false,
+                        "aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000aaaa0000"
+                    ),
+                ],
+                [resourceKey]
+            ),
+            dialect,
+            [
+                new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, edfiSchema),
+                new ProjectSchemaInfo("sample", "Sample", "1.0.0", false, sampleSchema),
+            ],
+            [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
+            [],
+            [],
+            [],
+            []
+        );
+    }
+}
+
+internal static class TriggerFixture
+{
+    internal static DerivedRelationalModelSet Build(SqlDialect dialect)
     {
         var schema = new DbSchemaName("edfi");
         var tableName = new DbTableName(schema, "School");
-        var columnName = new DbColumnName("DocumentId");
-        var keyColumn = new DbKeyColumn(columnName, ColumnKind.ParentKeyPart);
+        var documentIdColumn = new DbColumnName("DocumentId");
         var resource = new QualifiedResourceName("Ed-Fi", "School");
         var resourceKey = new ResourceKeyEntry(1, resource, "1.0.0", false);
+
         var table = new DbTableModel(
             tableName,
-            new JsonPathExpression("$", Array.Empty<JsonPathSegment>()),
-            new TableKey(primaryKeyName, [keyColumn]),
-            new[]
-            {
+            new JsonPathExpression("$", []),
+            new TableKey("PK_School", [new DbKeyColumn(documentIdColumn, ColumnKind.ParentKeyPart)]),
+            [
                 new DbColumnModel(
-                    columnName,
+                    documentIdColumn,
                     ColumnKind.ParentKeyPart,
                     new RelationalScalarType(ScalarKind.Int64),
                     IsNullable: false,
                     SourceJsonPath: null,
                     TargetResource: null
                 ),
-            },
-            Array.Empty<TableConstraint>()
+            ],
+            []
         );
+
         var relationalModel = new RelationalResourceModel(
             resource,
             schema,
             ResourceStorageKind.RelationalTables,
             table,
             [table],
-            Array.Empty<DocumentReferenceBinding>(),
-            Array.Empty<DescriptorEdgeSource>()
+            [],
+            []
+        );
+
+        var trigger = new DbTriggerInfo(
+            new DbTriggerName("TR_School_DocumentStamping"),
+            tableName,
+            [documentIdColumn],
+            [],
+            new TriggerKindParameters.DocumentStamping()
         );
 
         return new DerivedRelationalModelSet(
@@ -111,10 +1216,34 @@ internal static DerivedRelationalModelSet Build(SqlDialect dialect, string prima
             dialect,
             [new ProjectSchemaInfo("ed-fi", "Ed-Fi", "1.0.0", false, schema)],
             [new ConcreteResourceModel(resourceKey, ResourceStorageKind.RelationalTables, relationalModel)],
-            Array.Empty<AbstractIdentityTableInfo>(),
-            Array.Empty<AbstractUnionViewInfo>(),
-            Array.Empty<DbIndexInfo>(),
-            Array.Empty<DbTriggerInfo>()
+            [],
+            [],
+            [],
+            [trigger]
         );
     }
 }
+
+// ═══════════════════════════════════════════════════════════════════
+// UUIDv5 Namespace Guard Test
+// ═══════════════════════════════════════════════════════════════════
+
+/// <summary>
+/// Guard test ensuring the DDL emitter's embedded UUIDv5 namespace stays in sync with
+/// <c>ReferentialIdCalculator.EdFiUuidv5Namespace</c> in <c>EdFi.DataManagementService.Core</c>.
+/// If this test fails, either the emitter or the calculator has been changed independently,
+/// which would cause emitted triggers to compute referential IDs that don't match runtime.
+/// </summary>
+[TestFixture]
+public class Given_Uuidv5Namespace_Constant
+{
+    [Test]
+    public void It_should_match_the_canonical_EdFi_UUIDv5_namespace()
+    {
+        // This value must match ReferentialIdCalculator.EdFiUuidv5Namespace in
+        // EdFi.DataManagementService.Core.Extraction.
+        const string expected = "edf1edf1-3df1-3df1-3df1-3df1edf1edf1";
+
+        RelationalModelDdlEmitter.Uuidv5Namespace.Should().Be(expected);
+    }
+}
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/DmsTableNames.cs b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/DmsTableNames.cs
index 76d5c2036..fe277fa5d 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/DmsTableNames.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/DmsTableNames.cs
@@ -15,7 +15,11 @@ internal static class DmsTableNames
 {
     private static readonly DbSchemaName _dmsSchema = new("dms");
 
+    public static readonly DbTableName Document = new(_dmsSchema, "Document");
     public static readonly DbTableName EffectiveSchema = new(_dmsSchema, "EffectiveSchema");
+    public static readonly DbTableName ReferentialIdentity = new(_dmsSchema, "ReferentialIdentity");
     public static readonly DbTableName ResourceKey = new(_dmsSchema, "ResourceKey");
     public static readonly DbTableName SchemaComponent = new(_dmsSchema, "SchemaComponent");
+
+    public static readonly string ChangeVersionSequence = "ChangeVersionSequence";
 }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/EdFi.DataManagementService.Backend.Ddl.csproj b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/EdFi.DataManagementService.Backend.Ddl.csproj
index 01dd3013e..e8b19a413 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/EdFi.DataManagementService.Backend.Ddl.csproj
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/EdFi.DataManagementService.Backend.Ddl.csproj
@@ -5,6 +5,9 @@
         <ImplicitUsings>enable</ImplicitUsings>
         <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
     </PropertyGroup>
+    <ItemGroup>
+        <InternalsVisibleTo Include="EdFi.DataManagementService.Backend.Ddl.Tests.Unit" />
+    </ItemGroup>
     <ItemGroup>
         <ProjectReference Include="..\EdFi.DataManagementService.Backend.External\EdFi.DataManagementService.Backend.External.csproj" />
         <ProjectReference Include="..\EdFi.DataManagementService.Backend.RelationalModel\EdFi.DataManagementService.Backend.RelationalModel.csproj" />
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/RelationalModelDdlEmitter.cs b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/RelationalModelDdlEmitter.cs
index 0f0d9c64a..8b880111f 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/RelationalModelDdlEmitter.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.Ddl/RelationalModelDdlEmitter.cs
@@ -11,19 +11,10 @@ namespace EdFi.DataManagementService.Backend.Ddl;
 /// <summary>
 /// Emits dialect-specific DDL (schemas, tables, indexes, and triggers) from a derived relational model set.
 /// </summary>
-public sealed class RelationalModelDdlEmitter
+public sealed class RelationalModelDdlEmitter(ISqlDialectRules dialectRules)
 {
-    private readonly ISqlDialectRules _dialectRules;
-
-    /// <summary>
-    /// Initializes a new DDL emitter using the specified SQL dialect rules.
-    /// </summary>
-    /// <param name="dialectRules">The dialect rules used for quoting and scalar type defaults.</param>
-    public RelationalModelDdlEmitter(ISqlDialectRules dialectRules)
-    {
-        ArgumentNullException.ThrowIfNull(dialectRules);
-        _dialectRules = dialectRules;
-    }
+    private readonly ISqlDialectRules _dialectRules =
+        dialectRules ?? throw new ArgumentNullException(nameof(dialectRules));
 
     /// <summary>
     /// Builds a SQL script that creates all schemas, tables, indexes, and triggers in the model set.
@@ -46,11 +37,27 @@ public string Emit(DerivedRelationalModelSet modelSet)
 
         var builder = new StringBuilder();
 
+        // Phase 1: Schemas
         AppendSchemas(builder, modelSet.ProjectSchemasInEndpointOrder);
+
+        // Phase 2: Tables (PK/UK/CHECK only, no cross-table FKs)
         AppendTables(builder, modelSet.ConcreteResourcesInNameOrder);
+
+        // Phase 3: Abstract Identity Tables (must precede FKs that reference them)
+        AppendAbstractIdentityTables(builder, modelSet.AbstractIdentityTablesInNameOrder);
+
+        // Phase 4: Foreign Keys (separate ALTER TABLE statements)
+        AppendForeignKeys(builder, modelSet.ConcreteResourcesInNameOrder);
+
+        // Phase 5: Indexes
         AppendIndexes(builder, modelSet.IndexesInCreateOrder);
+
+        // Phase 6: Triggers
         AppendTriggers(builder, modelSet.TriggersInCreateOrder);
 
+        // Phase 7: Abstract Union Views
+        AppendAbstractUnionViews(builder, modelSet.AbstractUnionViewsInNameOrder);
+
         return builder.ToString();
     }
 
@@ -113,7 +120,11 @@ private void AppendCreateTable(StringBuilder builder, DbTableModel table)
 
         foreach (var constraint in table.Constraints)
         {
-            definitions.Add(FormatConstraint(constraint));
+            var formatted = FormatConstraint(constraint);
+            if (formatted is not null) // Skip null (FK) constraints
+            {
+                definitions.Add(formatted);
+            }
         }
 
         for (var i = 0; i < definitions.Count; i++)
@@ -133,6 +144,51 @@ private void AppendCreateTable(StringBuilder builder, DbTableModel table)
         builder.AppendLine();
     }
 
+    /// <summary>
+    /// Appends <c>ALTER TABLE ADD CONSTRAINT</c> statements for all foreign keys.
+    /// </summary>
+    private void AppendForeignKeys(StringBuilder builder, IReadOnlyList<ConcreteResourceModel> resources)
+    {
+        foreach (var resource in resources)
+        {
+            foreach (var table in resource.RelationalModel.TablesInDependencyOrder)
+            {
+                foreach (var fk in table.Constraints.OfType<TableConstraint.ForeignKey>())
+                {
+                    builder.Append("ALTER TABLE ");
+                    builder.Append(Quote(table.Table));
+                    builder.Append(" ADD CONSTRAINT ");
+                    builder.Append(Quote(fk.Name));
+                    builder.Append(" FOREIGN KEY (");
+                    builder.Append(FormatColumnList(fk.Columns));
+                    builder.Append(") REFERENCES ");
+                    builder.Append(Quote(fk.TargetTable));
+                    builder.Append(" (");
+                    builder.Append(FormatColumnList(fk.TargetColumns));
+                    builder.Append(")");
+                    builder.Append(FormatReferentialActions(fk));
+                    builder.AppendLine(";");
+                    builder.AppendLine();
+                }
+            }
+        }
+    }
+
+    /// <summary>
+    /// Appends <c>CREATE TABLE</c> statements for abstract identity tables.
+    /// </summary>
+    private void AppendAbstractIdentityTables(
+        StringBuilder builder,
+        IReadOnlyList<AbstractIdentityTableInfo> tables
+    )
+    {
+        foreach (var tableInfo in tables)
+        {
+            // Reuse existing AppendCreateTable - it already handles all table types
+            AppendCreateTable(builder, tableInfo.TableModel);
+        }
+    }
+
     /// <summary>
     /// Appends <c>CREATE INDEX</c> statements for each index in create-order.
     /// </summary>
@@ -161,33 +217,803 @@ private void AppendTriggers(StringBuilder builder, IReadOnlyList<DbTriggerInfo>
     {
         foreach (var trigger in triggers)
         {
-            builder.Append("CREATE TRIGGER ");
-            builder.Append(Quote(trigger.Name));
-            builder.Append(" ON ");
-            builder.Append(Quote(trigger.Table));
-            builder.Append(' ');
-            builder.AppendLine(BuildTriggerBody());
-            builder.AppendLine();
+            if (_dialectRules.Dialect == SqlDialect.Pgsql)
+            {
+                AppendPgsqlTrigger(builder, trigger);
+            }
+            else
+            {
+                AppendMssqlTrigger(builder, trigger);
+            }
         }
     }
 
     /// <summary>
-    /// Builds a dialect-specific trigger body statement.
+    /// Appends a PostgreSQL trigger (function + trigger).
     /// </summary>
-    private string BuildTriggerBody()
+    private void AppendPgsqlTrigger(StringBuilder builder, DbTriggerInfo trigger)
     {
-        var body = _dialectRules.Dialect switch
+        var funcName = $"TF_{trigger.Name.Value}";
+        var schema = trigger.Table.Schema;
+
+        // Function
+        builder.Append("CREATE OR REPLACE FUNCTION ");
+        builder.Append(Quote(schema));
+        builder.Append('.');
+        builder.Append(Quote(funcName));
+        builder.AppendLine("()");
+        builder.AppendLine("RETURNS TRIGGER AS $$");
+        builder.AppendLine("BEGIN");
+        AppendTriggerBody(builder, trigger, "    ");
+        builder.AppendLine("    RETURN NEW;");
+        builder.AppendLine("END;");
+        builder.AppendLine("$$ LANGUAGE plpgsql;");
+        builder.AppendLine();
+
+        // Trigger
+        builder.Append("CREATE OR REPLACE TRIGGER ");
+        builder.Append(Quote(trigger.Name));
+        builder.AppendLine();
+        builder.Append("BEFORE INSERT OR UPDATE ON ");
+        builder.Append(Quote(trigger.Table));
+        builder.AppendLine();
+        builder.AppendLine("FOR EACH ROW");
+        builder.Append("EXECUTE FUNCTION ");
+        builder.Append(Quote(schema));
+        builder.Append('.');
+        builder.Append(Quote(funcName));
+        builder.AppendLine("();");
+        builder.AppendLine();
+    }
+
+    /// <summary>
+    /// Appends a SQL Server trigger.
+    /// </summary>
+    private void AppendMssqlTrigger(StringBuilder builder, DbTriggerInfo trigger)
+    {
+        // CREATE OR ALTER TRIGGER must be the first statement in a T-SQL batch.
+        builder.AppendLine("GO");
+        builder.Append("CREATE OR ALTER TRIGGER ");
+        builder.Append(Quote(trigger.Table.Schema));
+        builder.Append('.');
+        builder.Append(Quote(trigger.Name));
+        builder.AppendLine();
+        builder.Append("ON ");
+        builder.Append(Quote(trigger.Table));
+        builder.AppendLine();
+        builder.AppendLine(
+            trigger.Parameters is TriggerKindParameters.IdentityPropagationFallback
+                ? "AFTER UPDATE"
+                : "AFTER INSERT, UPDATE"
+        );
+        builder.AppendLine("AS");
+        builder.AppendLine("BEGIN");
+        builder.AppendLine("    SET NOCOUNT ON;");
+        AppendTriggerBody(builder, trigger, "    ");
+        builder.AppendLine("END;");
+        builder.AppendLine();
+    }
+
+    /// <summary>
+    /// Appends the trigger body logic based on trigger kind.
+    /// </summary>
+    private void AppendTriggerBody(StringBuilder builder, DbTriggerInfo trigger, string indent)
+    {
+        switch (trigger.Parameters)
         {
-            SqlDialect.Pgsql => $"EXECUTE FUNCTION {Quote("noop")}();",
-            SqlDialect.Mssql => "AS BEGIN END;",
-            _ => throw new ArgumentOutOfRangeException(
-                nameof(_dialectRules.Dialect),
-                _dialectRules.Dialect,
-                "Unsupported SQL dialect."
-            ),
-        };
+            case TriggerKindParameters.DocumentStamping:
+                AppendDocumentStampingBody(builder, trigger, indent);
+                break;
+            case TriggerKindParameters.ReferentialIdentityMaintenance refId:
+                AppendReferentialIdentityBody(builder, trigger, indent, refId);
+                break;
+            case TriggerKindParameters.AbstractIdentityMaintenance abstractId:
+                AppendAbstractIdentityBody(builder, trigger, indent, abstractId);
+                break;
+            case TriggerKindParameters.IdentityPropagationFallback propagation:
+                AppendIdentityPropagationBody(builder, trigger, indent, propagation);
+                break;
+            default:
+                throw new ArgumentOutOfRangeException(nameof(trigger.Parameters));
+        }
+    }
+
+    /// <summary>
+    /// Appends document stamping trigger body that stamps <c>dms.Document.ContentVersion</c>
+    /// and (for root tables with identity projection columns) <c>IdentityVersion</c> on writes.
+    /// </summary>
+    private void AppendDocumentStampingBody(StringBuilder builder, DbTriggerInfo trigger, string indent)
+    {
+        if (trigger.KeyColumns.Count == 0)
+            throw new InvalidOperationException(
+                $"Trigger '{trigger.Name.Value}' requires at least one key column."
+            );
+
+        var documentTable = Quote(DmsTableNames.Document);
+        var sequenceName = FormatSequenceName();
+        var keyColumn = trigger.KeyColumns[0];
 
-        return body;
+        if (_dialectRules.Dialect == SqlDialect.Pgsql)
+        {
+            AppendPgsqlDocumentStampingBody(builder, trigger, indent, documentTable, sequenceName, keyColumn);
+        }
+        else
+        {
+            AppendMssqlDocumentStampingBody(builder, trigger, indent, documentTable, sequenceName, keyColumn);
+        }
+    }
+
+    private void AppendPgsqlDocumentStampingBody(
+        StringBuilder builder,
+        DbTriggerInfo trigger,
+        string indent,
+        string documentTable,
+        string sequenceName,
+        DbColumnName keyColumn
+    )
+    {
+        // ContentVersion stamp
+        builder.Append(indent);
+        builder.Append("UPDATE ");
+        builder.AppendLine(documentTable);
+        builder.Append(indent);
+        builder.Append("SET ");
+        builder.Append(Quote(new DbColumnName("ContentVersion")));
+        builder.Append(" = nextval('");
+        builder.Append(sequenceName);
+        builder.Append("'), ");
+        builder.Append(Quote(new DbColumnName("ContentLastModifiedAt")));
+        builder.AppendLine(" = now()");
+        builder.Append(indent);
+        builder.Append("WHERE ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" = NEW.");
+        builder.Append(Quote(keyColumn));
+        builder.AppendLine(";");
+
+        // IdentityVersion stamp for root tables with identity projection columns
+        if (trigger.IdentityProjectionColumns.Count > 0)
+        {
+            builder.Append(indent);
+            builder.Append("IF TG_OP = 'UPDATE' AND (");
+            for (int i = 0; i < trigger.IdentityProjectionColumns.Count; i++)
+            {
+                if (i > 0)
+                    builder.Append(" OR ");
+                var col = Quote(trigger.IdentityProjectionColumns[i]);
+                builder.Append("OLD.");
+                builder.Append(col);
+                builder.Append(" IS DISTINCT FROM NEW.");
+                builder.Append(col);
+            }
+            builder.AppendLine(") THEN");
+
+            var innerIndent = indent + "    ";
+            builder.Append(innerIndent);
+            builder.Append("UPDATE ");
+            builder.AppendLine(documentTable);
+            builder.Append(innerIndent);
+            builder.Append("SET ");
+            builder.Append(Quote(new DbColumnName("IdentityVersion")));
+            builder.Append(" = nextval('");
+            builder.Append(sequenceName);
+            builder.Append("'), ");
+            builder.Append(Quote(new DbColumnName("IdentityLastModifiedAt")));
+            builder.AppendLine(" = now()");
+            builder.Append(innerIndent);
+            builder.Append("WHERE ");
+            builder.Append(Quote(new DbColumnName("DocumentId")));
+            builder.Append(" = NEW.");
+            builder.Append(Quote(keyColumn));
+            builder.AppendLine(";");
+
+            builder.Append(indent);
+            builder.AppendLine("END IF;");
+        }
+    }
+
+    private void AppendMssqlDocumentStampingBody(
+        StringBuilder builder,
+        DbTriggerInfo trigger,
+        string indent,
+        string documentTable,
+        string sequenceName,
+        DbColumnName keyColumn
+    )
+    {
+        // ContentVersion stamp
+        builder.Append(indent);
+        builder.AppendLine("UPDATE d");
+        builder.Append(indent);
+        builder.Append("SET d.");
+        builder.Append(Quote(new DbColumnName("ContentVersion")));
+        builder.Append(" = NEXT VALUE FOR ");
+        builder.Append(sequenceName);
+        builder.Append(", d.");
+        builder.Append(Quote(new DbColumnName("ContentLastModifiedAt")));
+        builder.AppendLine(" = sysutcdatetime()");
+        builder.Append(indent);
+        builder.Append("FROM ");
+        builder.Append(documentTable);
+        builder.AppendLine(" d");
+        builder.Append(indent);
+        builder.Append("INNER JOIN inserted i ON d.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" = i.");
+        builder.Append(Quote(keyColumn));
+        builder.AppendLine(";");
+
+        // IdentityVersion stamp for root tables with identity projection columns
+        if (trigger.IdentityProjectionColumns.Count > 0)
+        {
+            builder.Append(indent);
+            builder.Append("IF EXISTS (SELECT 1 FROM deleted) AND (");
+            for (int i = 0; i < trigger.IdentityProjectionColumns.Count; i++)
+            {
+                if (i > 0)
+                    builder.Append(" OR ");
+                builder.Append("UPDATE(");
+                builder.Append(Quote(trigger.IdentityProjectionColumns[i]));
+                builder.Append(')');
+            }
+            builder.AppendLine(")");
+
+            builder.Append(indent);
+            builder.AppendLine("BEGIN");
+
+            var innerIndent = indent + "    ";
+            builder.Append(innerIndent);
+            builder.AppendLine("UPDATE d");
+            builder.Append(innerIndent);
+            builder.Append("SET d.");
+            builder.Append(Quote(new DbColumnName("IdentityVersion")));
+            builder.Append(" = NEXT VALUE FOR ");
+            builder.Append(sequenceName);
+            builder.Append(", d.");
+            builder.Append(Quote(new DbColumnName("IdentityLastModifiedAt")));
+            builder.AppendLine(" = sysutcdatetime()");
+            builder.Append(innerIndent);
+            builder.Append("FROM ");
+            builder.Append(documentTable);
+            builder.AppendLine(" d");
+            builder.Append(innerIndent);
+            builder.Append("INNER JOIN inserted i ON d.");
+            builder.Append(Quote(new DbColumnName("DocumentId")));
+            builder.Append(" = i.");
+            builder.AppendLine(Quote(keyColumn));
+            builder.Append(innerIndent);
+            builder.Append("INNER JOIN deleted del ON del.");
+            builder.Append(Quote(keyColumn));
+            builder.Append(" = i.");
+            builder.AppendLine(Quote(keyColumn));
+            builder.Append(innerIndent);
+            builder.Append("WHERE ");
+            for (int i = 0; i < trigger.IdentityProjectionColumns.Count; i++)
+            {
+                if (i > 0)
+                {
+                    builder.Append(" OR ");
+                }
+                var col = Quote(trigger.IdentityProjectionColumns[i]);
+                AppendMssqlNullSafeNotEqual(builder, "i", col, "del", col);
+            }
+            builder.AppendLine(";");
+
+            builder.Append(indent);
+            builder.AppendLine("END");
+        }
+    }
+
+    /// <summary>
+    /// Appends referential identity maintenance trigger body that maintains
+    /// <c>dms.ReferentialIdentity</c> rows via UUIDv5 computation.
+    /// </summary>
+    private void AppendReferentialIdentityBody(
+        StringBuilder builder,
+        DbTriggerInfo trigger,
+        string indent,
+        TriggerKindParameters.ReferentialIdentityMaintenance refId
+    )
+    {
+        if (_dialectRules.Dialect == SqlDialect.Pgsql)
+        {
+            AppendPgsqlReferentialIdentityBody(builder, indent, refId);
+        }
+        else
+        {
+            AppendMssqlReferentialIdentityBody(builder, indent, refId);
+        }
+    }
+
+    private void AppendPgsqlReferentialIdentityBody(
+        StringBuilder builder,
+        string indent,
+        TriggerKindParameters.ReferentialIdentityMaintenance refId
+    )
+    {
+        var refIdTable = Quote(DmsTableNames.ReferentialIdentity);
+
+        // Primary referential identity
+        AppendPgsqlReferentialIdentityBlock(
+            builder,
+            indent,
+            refIdTable,
+            refId.ResourceKeyId,
+            refId.ProjectName,
+            refId.ResourceName,
+            refId.IdentityElements
+        );
+
+        // Superclass alias
+        if (refId.SuperclassAlias is { } alias)
+        {
+            AppendPgsqlReferentialIdentityBlock(
+                builder,
+                indent,
+                refIdTable,
+                alias.ResourceKeyId,
+                alias.ProjectName,
+                alias.ResourceName,
+                alias.IdentityElements
+            );
+        }
+    }
+
+    private void AppendPgsqlReferentialIdentityBlock(
+        StringBuilder builder,
+        string indent,
+        string refIdTable,
+        short resourceKeyId,
+        string projectName,
+        string resourceName,
+        IReadOnlyList<IdentityElementMapping> identityElements
+    )
+    {
+        if (identityElements.Count == 0)
+        {
+            throw new InvalidOperationException(
+                $"ReferentialIdentityMaintenance trigger requires at least one identity element for resource '{resourceName}'."
+            );
+        }
+
+        var uuidv5Func = FormatUuidv5FunctionName();
+
+        // DELETE existing row
+        builder.Append(indent);
+        builder.Append("DELETE FROM ");
+        builder.AppendLine(refIdTable);
+        builder.Append(indent);
+        builder.Append("WHERE ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" = NEW.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" AND ");
+        builder.Append(Quote(new DbColumnName("ResourceKeyId")));
+        builder.Append(" = ");
+        builder.Append(resourceKeyId);
+        builder.AppendLine(";");
+
+        // INSERT new row with UUIDv5
+        builder.Append(indent);
+        builder.Append("INSERT INTO ");
+        builder.Append(refIdTable);
+        builder.Append(" (");
+        builder.Append(Quote(new DbColumnName("ReferentialId")));
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("ResourceKeyId")));
+        builder.AppendLine(")");
+        builder.Append(indent);
+        builder.Append("VALUES (");
+        builder.Append(uuidv5Func);
+        builder.Append("('");
+        builder.Append(Uuidv5Namespace);
+        // Format intentionally matches ReferentialIdCalculator.ResourceInfoString: {ProjectName}{ResourceName}
+        // with no separator — do not add one without updating the calculator.
+        builder.Append("'::uuid, '");
+        builder.Append(EscapeSqlLiteral(projectName));
+        builder.Append(EscapeSqlLiteral(resourceName));
+        builder.Append("' || ");
+        AppendPgsqlIdentityHashExpression(builder, identityElements);
+        builder.Append("), NEW.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(", ");
+        builder.Append(resourceKeyId);
+        builder.AppendLine(");");
+    }
+
+    private void AppendPgsqlIdentityHashExpression(
+        StringBuilder builder,
+        IReadOnlyList<IdentityElementMapping> elements
+    )
+    {
+        for (int i = 0; i < elements.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(" || '#' || ");
+            builder.Append("'$");
+            builder.Append(EscapeSqlLiteral(elements[i].IdentityJsonPath));
+            builder.Append("=' || NEW.");
+            builder.Append(Quote(elements[i].Column));
+            builder.Append("::text");
+        }
+    }
+
+    private void AppendMssqlReferentialIdentityBody(
+        StringBuilder builder,
+        string indent,
+        TriggerKindParameters.ReferentialIdentityMaintenance refId
+    )
+    {
+        var refIdTable = Quote(DmsTableNames.ReferentialIdentity);
+
+        // Primary referential identity
+        AppendMssqlReferentialIdentityBlock(
+            builder,
+            indent,
+            refIdTable,
+            refId.ResourceKeyId,
+            refId.ProjectName,
+            refId.ResourceName,
+            refId.IdentityElements
+        );
+
+        // Superclass alias
+        if (refId.SuperclassAlias is { } alias)
+        {
+            AppendMssqlReferentialIdentityBlock(
+                builder,
+                indent,
+                refIdTable,
+                alias.ResourceKeyId,
+                alias.ProjectName,
+                alias.ResourceName,
+                alias.IdentityElements
+            );
+        }
+    }
+
+    private void AppendMssqlReferentialIdentityBlock(
+        StringBuilder builder,
+        string indent,
+        string refIdTable,
+        short resourceKeyId,
+        string projectName,
+        string resourceName,
+        IReadOnlyList<IdentityElementMapping> identityElements
+    )
+    {
+        if (identityElements.Count == 0)
+        {
+            throw new InvalidOperationException(
+                $"ReferentialIdentityMaintenance trigger requires at least one identity element for resource '{resourceName}'."
+            );
+        }
+
+        var uuidv5Func = FormatUuidv5FunctionName();
+
+        // DELETE existing row
+        builder.Append(indent);
+        builder.Append("DELETE FROM ");
+        builder.AppendLine(refIdTable);
+        builder.Append(indent);
+        builder.Append("WHERE ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" IN (SELECT ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" FROM inserted) AND ");
+        builder.Append(Quote(new DbColumnName("ResourceKeyId")));
+        builder.Append(" = ");
+        builder.Append(resourceKeyId);
+        builder.AppendLine(";");
+
+        // INSERT new rows from inserted table with UUIDv5
+        builder.Append(indent);
+        builder.Append("INSERT INTO ");
+        builder.Append(refIdTable);
+        builder.Append(" (");
+        builder.Append(Quote(new DbColumnName("ReferentialId")));
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("ResourceKeyId")));
+        builder.AppendLine(")");
+        builder.Append(indent);
+        builder.Append("SELECT ");
+        builder.Append(uuidv5Func);
+        builder.Append("('");
+        builder.Append(Uuidv5Namespace);
+        // Format intentionally matches ReferentialIdCalculator.ResourceInfoString: {ProjectName}{ResourceName}
+        // with no separator — do not add one without updating the calculator.
+        builder.Append("', N'");
+        builder.Append(EscapeSqlLiteral(projectName));
+        builder.Append(EscapeSqlLiteral(resourceName));
+        builder.Append("' + ");
+        AppendMssqlIdentityHashExpression(builder, identityElements);
+        builder.Append("), i.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(", ");
+        builder.AppendLine(resourceKeyId.ToString());
+        builder.Append(indent);
+        builder.AppendLine("FROM inserted i;");
+    }
+
+    private void AppendMssqlIdentityHashExpression(
+        StringBuilder builder,
+        IReadOnlyList<IdentityElementMapping> elements
+    )
+    {
+        for (int i = 0; i < elements.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(" + N'#' + ");
+            builder.Append("N'$");
+            builder.Append(EscapeSqlLiteral(elements[i].IdentityJsonPath));
+            builder.Append("=' + CAST(i.");
+            builder.Append(Quote(elements[i].Column));
+            builder.Append(" AS nvarchar(max))");
+        }
+    }
+
+    /// <summary>
+    /// Appends abstract identity maintenance trigger body that maintains abstract identity
+    /// tables from concrete resource root tables.
+    /// </summary>
+    private void AppendAbstractIdentityBody(
+        StringBuilder builder,
+        DbTriggerInfo trigger,
+        string indent,
+        TriggerKindParameters.AbstractIdentityMaintenance abstractId
+    )
+    {
+        if (_dialectRules.Dialect == SqlDialect.Pgsql)
+        {
+            AppendPgsqlAbstractIdentityBody(
+                builder,
+                indent,
+                abstractId.TargetTable,
+                abstractId.TargetColumnMappings,
+                abstractId.DiscriminatorValue
+            );
+        }
+        else
+        {
+            AppendMssqlAbstractIdentityBody(
+                builder,
+                indent,
+                abstractId.TargetTable,
+                abstractId.TargetColumnMappings,
+                abstractId.DiscriminatorValue
+            );
+        }
+    }
+
+    private void AppendPgsqlAbstractIdentityBody(
+        StringBuilder builder,
+        string indent,
+        DbTableName targetTableName,
+        IReadOnlyList<TriggerColumnMapping> mappings,
+        string discriminatorValue
+    )
+    {
+        var targetTable = Quote(targetTableName);
+
+        // INSERT ... ON CONFLICT DO UPDATE
+        builder.Append(indent);
+        builder.Append("INSERT INTO ");
+        builder.Append(targetTable);
+        builder.Append(" (");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        foreach (var mapping in mappings)
+        {
+            builder.Append(", ");
+            builder.Append(Quote(mapping.TargetColumn));
+        }
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("Discriminator")));
+        builder.AppendLine(")");
+
+        builder.Append(indent);
+        builder.Append("VALUES (NEW.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        foreach (var mapping in mappings)
+        {
+            builder.Append(", NEW.");
+            builder.Append(Quote(mapping.SourceColumn));
+        }
+        builder.Append(", '");
+        builder.Append(EscapeSqlLiteral(discriminatorValue));
+        builder.AppendLine("')");
+
+        builder.Append(indent);
+        builder.Append("ON CONFLICT (");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.AppendLine(")");
+
+        builder.Append(indent);
+        builder.Append("DO UPDATE SET ");
+        for (int i = 0; i < mappings.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(", ");
+            builder.Append(Quote(mappings[i].TargetColumn));
+            builder.Append(" = EXCLUDED.");
+            builder.Append(Quote(mappings[i].TargetColumn));
+        }
+        builder.AppendLine(";");
+    }
+
+    private void AppendMssqlAbstractIdentityBody(
+        StringBuilder builder,
+        string indent,
+        DbTableName targetTableName,
+        IReadOnlyList<TriggerColumnMapping> mappings,
+        string discriminatorValue
+    )
+    {
+        var targetTable = Quote(targetTableName);
+
+        // MERGE statement
+        builder.Append(indent);
+        builder.Append("MERGE ");
+        builder.Append(targetTable);
+        builder.AppendLine(" AS t");
+        builder.Append(indent);
+        builder.Append("USING inserted AS s ON t.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        builder.Append(" = s.");
+        builder.AppendLine(Quote(new DbColumnName("DocumentId")));
+
+        // WHEN MATCHED THEN UPDATE
+        builder.Append(indent);
+        builder.Append("WHEN MATCHED THEN UPDATE SET ");
+        for (int i = 0; i < mappings.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(", ");
+            builder.Append("t.");
+            builder.Append(Quote(mappings[i].TargetColumn));
+            builder.Append(" = s.");
+            builder.Append(Quote(mappings[i].SourceColumn));
+        }
+        builder.AppendLine();
+
+        // WHEN NOT MATCHED THEN INSERT
+        builder.Append(indent);
+        builder.Append("WHEN NOT MATCHED THEN INSERT (");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        foreach (var mapping in mappings)
+        {
+            builder.Append(", ");
+            builder.Append(Quote(mapping.TargetColumn));
+        }
+        builder.Append(", ");
+        builder.Append(Quote(new DbColumnName("Discriminator")));
+        builder.AppendLine(")");
+
+        builder.Append(indent);
+        builder.Append("VALUES (s.");
+        builder.Append(Quote(new DbColumnName("DocumentId")));
+        foreach (var mapping in mappings)
+        {
+            builder.Append(", s.");
+            builder.Append(Quote(mapping.SourceColumn));
+        }
+        builder.Append(", N'");
+        builder.Append(EscapeSqlLiteral(discriminatorValue));
+        builder.AppendLine("');");
+    }
+
+    /// <summary>
+    /// Appends identity propagation fallback trigger body (MSSQL only) that cascades
+    /// identity column updates to target tables when <c>ON UPDATE CASCADE</c> is not available.
+    /// </summary>
+    private void AppendIdentityPropagationBody(
+        StringBuilder builder,
+        DbTriggerInfo trigger,
+        string indent,
+        TriggerKindParameters.IdentityPropagationFallback propagation
+    )
+    {
+        if (_dialectRules.Dialect != SqlDialect.Mssql)
+        {
+            throw new InvalidOperationException(
+                $"Identity propagation fallback triggers are only supported for MSSQL, but dialect is {_dialectRules.Dialect}."
+            );
+        }
+
+        if (trigger.KeyColumns.Count == 0)
+            throw new InvalidOperationException(
+                $"Trigger '{trigger.Name.Value}' requires at least one key column."
+            );
+
+        var targetTable = Quote(propagation.TargetTable);
+        var fkColumn = trigger.KeyColumns[0];
+
+        builder.Append(indent);
+        builder.AppendLine("UPDATE t");
+        builder.Append(indent);
+        builder.Append("SET ");
+        for (int i = 0; i < propagation.TargetColumnMappings.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(", ");
+            builder.Append("t.");
+            builder.Append(Quote(propagation.TargetColumnMappings[i].TargetColumn));
+            builder.Append(" = i.");
+            builder.Append(Quote(propagation.TargetColumnMappings[i].SourceColumn));
+        }
+        builder.AppendLine();
+
+        builder.Append(indent);
+        builder.Append("FROM ");
+        builder.Append(targetTable);
+        builder.AppendLine(" t");
+        // Join target to the OLD FK value (from deleted) so we find the row that needs updating.
+        builder.Append(indent);
+        builder.Append("INNER JOIN deleted d ON t.");
+        builder.Append(Quote(fkColumn));
+        builder.Append(" = d.");
+        builder.AppendLine(Quote(fkColumn));
+        // Correlate old/new rows of the trigger's owning table by DocumentId (the universal PK),
+        // not by the FK column — the FK column is what changes, so it cannot be the join key.
+        var documentIdCol = Quote(new DbColumnName("DocumentId"));
+        builder.Append(indent);
+        builder.Append("INNER JOIN inserted i ON i.");
+        builder.Append(documentIdCol);
+        builder.Append(" = d.");
+        builder.AppendLine(documentIdCol);
+
+        builder.Append(indent);
+        builder.Append("WHERE ");
+        for (int i = 0; i < propagation.TargetColumnMappings.Count; i++)
+        {
+            if (i > 0)
+                builder.Append(" OR ");
+            var col = Quote(propagation.TargetColumnMappings[i].SourceColumn);
+            AppendMssqlNullSafeNotEqual(builder, "i", col, "d", col);
+        }
+        builder.AppendLine(";");
+    }
+
+    /// <summary>
+    /// Appends a NULL-safe inequality comparison for MSSQL, equivalent to PostgreSQL's
+    /// <c>IS DISTINCT FROM</c>. Emits <c>(left.col &lt;&gt; right.col OR (left.col IS NULL AND right.col IS NOT NULL) OR (left.col IS NOT NULL AND right.col IS NULL))</c>.
+    /// </summary>
+    private static void AppendMssqlNullSafeNotEqual(
+        StringBuilder builder,
+        string leftAlias,
+        string quotedColumn,
+        string rightAlias,
+        string rightQuotedColumn
+    )
+    {
+        builder.Append('(');
+        builder.Append(leftAlias);
+        builder.Append('.');
+        builder.Append(quotedColumn);
+        builder.Append(" <> ");
+        builder.Append(rightAlias);
+        builder.Append('.');
+        builder.Append(rightQuotedColumn);
+        builder.Append(" OR (");
+        builder.Append(leftAlias);
+        builder.Append('.');
+        builder.Append(quotedColumn);
+        builder.Append(" IS NULL AND ");
+        builder.Append(rightAlias);
+        builder.Append('.');
+        builder.Append(rightQuotedColumn);
+        builder.Append(" IS NOT NULL) OR (");
+        builder.Append(leftAlias);
+        builder.Append('.');
+        builder.Append(quotedColumn);
+        builder.Append(" IS NOT NULL AND ");
+        builder.Append(rightAlias);
+        builder.Append('.');
+        builder.Append(rightQuotedColumn);
+        builder.Append(" IS NULL))");
     }
 
     /// <summary>
@@ -202,7 +1028,12 @@ private string ResolveColumnType(DbColumnModel column)
             return column.Kind switch
             {
                 ColumnKind.Ordinal => _dialectRules.ScalarTypeDefaults.Int32Type,
-                _ => _dialectRules.ScalarTypeDefaults.Int64Type,
+                ColumnKind.DocumentFk or ColumnKind.DescriptorFk or ColumnKind.ParentKeyPart => _dialectRules
+                    .ScalarTypeDefaults
+                    .Int64Type,
+                _ => throw new InvalidOperationException(
+                    $"Column '{column.ColumnName.Value}' of kind {column.Kind} has no ScalarType."
+                ),
             };
         }
 
@@ -234,12 +1065,16 @@ private string ResolveColumnType(RelationalScalarType scalarType)
 
     /// <summary>
     /// Formats a string scalar type including a length specifier when present.
+    /// For SQL Server, unbounded strings use (max) suffix.
     /// </summary>
     private string FormatStringType(RelationalScalarType scalarType)
     {
         if (scalarType.MaxLength is null)
         {
-            return _dialectRules.ScalarTypeDefaults.StringType;
+            // Unbounded string - use (max) for SQL Server
+            return _dialectRules.Dialect == SqlDialect.Mssql
+                ? $"{_dialectRules.ScalarTypeDefaults.StringType}(max)"
+                : _dialectRules.ScalarTypeDefaults.StringType;
         }
 
         return $"{_dialectRules.ScalarTypeDefaults.StringType}({scalarType.MaxLength.Value})";
@@ -261,17 +1096,15 @@ private string FormatDecimalType(RelationalScalarType scalarType)
 
     /// <summary>
     /// Formats a table constraint for inclusion within a <c>CREATE TABLE</c> statement.
+    /// Returns null for FK constraints which are emitted separately in Phase 3.
     /// </summary>
-    private string FormatConstraint(TableConstraint constraint)
+    private string? FormatConstraint(TableConstraint constraint)
     {
         return constraint switch
         {
             TableConstraint.Unique unique =>
                 $"CONSTRAINT {Quote(unique.Name)} UNIQUE ({FormatColumnList(unique.Columns)})",
-            TableConstraint.ForeignKey foreignKey =>
-                $"CONSTRAINT {Quote(foreignKey.Name)} FOREIGN KEY ({FormatColumnList(foreignKey.Columns)}) "
-                    + $"REFERENCES {Quote(foreignKey.TargetTable)} ({FormatColumnList(foreignKey.TargetColumns)})"
-                    + FormatReferentialActions(foreignKey),
+            TableConstraint.ForeignKey => null, // Skip FKs, emit in Phase 3
             TableConstraint.AllOrNoneNullability allOrNone =>
                 $"CONSTRAINT {Quote(allOrNone.Name)} CHECK ({FormatAllOrNoneCheck(allOrNone)})",
             _ => throw new ArgumentOutOfRangeException(
@@ -339,13 +1172,141 @@ private string FormatColumnList(IReadOnlyList<DbKeyColumn> columns)
         return string.Join(", ", columns.Select(column => Quote(column.ColumnName)));
     }
 
+    /// <summary>
+    /// Appends <c>CREATE VIEW</c> statements for abstract union views.
+    /// </summary>
+    private void AppendAbstractUnionViews(StringBuilder builder, IReadOnlyList<AbstractUnionViewInfo> views)
+    {
+        foreach (var viewInfo in views)
+        {
+            AppendCreateView(builder, viewInfo);
+        }
+    }
+
+    /// <summary>
+    /// Appends a <c>CREATE VIEW</c> statement for a single abstract union view.
+    /// </summary>
+    private void AppendCreateView(StringBuilder builder, AbstractUnionViewInfo viewInfo)
+    {
+        // MSSQL: CREATE OR ALTER VIEW must be the first statement in a T-SQL batch.
+        if (_dialectRules.Dialect == SqlDialect.Mssql)
+        {
+            builder.AppendLine("GO");
+        }
+
+        // Determine view creation pattern based on dialect
+        var createKeyword = _dialectRules.Dialect switch
+        {
+            SqlDialect.Pgsql => "CREATE OR REPLACE VIEW",
+            SqlDialect.Mssql => "CREATE OR ALTER VIEW",
+            _ => throw new ArgumentOutOfRangeException(),
+        };
+
+        builder.Append(createKeyword);
+        builder.Append(" ");
+        builder.Append(Quote(viewInfo.ViewName));
+        builder.AppendLine(" AS");
+
+        // Emit UNION ALL arms
+        for (int i = 0; i < viewInfo.UnionArmsInOrder.Count; i++)
+        {
+            var arm = viewInfo.UnionArmsInOrder[i];
+
+            if (i > 0)
+            {
+                builder.AppendLine("UNION ALL");
+            }
+
+            builder.Append("SELECT ");
+
+            // Emit projection expressions
+            for (int j = 0; j < arm.ProjectionExpressionsInSelectOrder.Count; j++)
+            {
+                if (j > 0)
+                    builder.Append(", ");
+
+                var expr = arm.ProjectionExpressionsInSelectOrder[j];
+                var outputColumn = viewInfo.OutputColumnsInSelectOrder[j];
+
+                AppendProjectionExpression(builder, expr, outputColumn.ScalarType);
+                builder.Append(" AS ");
+                builder.Append(Quote(outputColumn.ColumnName));
+            }
+
+            builder.AppendLine();
+            builder.Append("FROM ");
+            builder.AppendLine(Quote(arm.FromTable));
+        }
+
+        builder.AppendLine(";");
+        builder.AppendLine();
+    }
+
+    /// <summary>
+    /// Appends a projection expression for an abstract union view select list.
+    /// </summary>
+    private void AppendProjectionExpression(
+        StringBuilder builder,
+        AbstractUnionViewProjectionExpression expr,
+        RelationalScalarType targetType
+    )
+    {
+        switch (expr)
+        {
+            case AbstractUnionViewProjectionExpression.SourceColumn sourceCol:
+                builder.Append(Quote(sourceCol.ColumnName));
+                break;
+
+            case AbstractUnionViewProjectionExpression.StringLiteral literal:
+                AppendStringLiteralWithCast(builder, literal.Value, targetType);
+                break;
+
+            default:
+                throw new ArgumentOutOfRangeException(
+                    nameof(expr),
+                    expr,
+                    "Unsupported projection expression"
+                );
+        }
+    }
+
+    /// <summary>
+    /// Appends a string literal with dialect-specific CAST expression.
+    /// </summary>
+    private void AppendStringLiteralWithCast(
+        StringBuilder builder,
+        string value,
+        RelationalScalarType targetType
+    )
+    {
+        var sqlType = ResolveColumnType(targetType);
+
+        if (_dialectRules.Dialect == SqlDialect.Pgsql)
+        {
+            // PostgreSQL: 'literal'::type
+            builder.Append('\'');
+            builder.Append(EscapeSqlLiteral(value));
+            builder.Append("'::");
+            builder.Append(sqlType);
+        }
+        else
+        {
+            // SQL Server: CAST(N'literal' AS type)
+            builder.Append("CAST(N'");
+            builder.Append(EscapeSqlLiteral(value));
+            builder.Append("' AS ");
+            builder.Append(sqlType);
+            builder.Append(')');
+        }
+    }
+
     /// <summary>
     /// Resolves the primary key constraint name, falling back to a conventional default when unset.
     /// </summary>
     private static string ResolvePrimaryKeyConstraintName(DbTableModel table)
     {
         return string.IsNullOrWhiteSpace(table.Key.ConstraintName)
-            ? $"PK_{table.Table.Name}"
+            ? $"PK_{table.Table.Schema.Value}_{table.Table.Name}"
             : table.Key.ConstraintName;
     }
 
@@ -396,4 +1357,33 @@ private string Quote(DbTriggerName trigger)
     {
         return SqlIdentifierQuoter.QuoteIdentifier(_dialectRules.Dialect, trigger);
     }
+
+    /// <summary>
+    /// The UUIDv5 namespace used for referential identity computation.
+    /// Must match <c>ReferentialIdCalculator.EdFiUuidv5Namespace</c> in
+    /// <c>EdFi.DataManagementService.Core</c>. A guard test in the unit test project
+    /// asserts this value to prevent silent divergence.
+    /// </summary>
+    internal const string Uuidv5Namespace = "edf1edf1-3df1-3df1-3df1-3df1edf1edf1";
+
+    /// <summary>
+    /// Formats the qualified <c>dms.ChangeVersionSequence</c> name for the current dialect.
+    /// </summary>
+    private string FormatSequenceName()
+    {
+        return $"{Quote(DmsTableNames.Document.Schema)}.{Quote(DmsTableNames.ChangeVersionSequence)}";
+    }
+
+    /// <summary>
+    /// Formats the qualified <c>dms.uuidv5</c> function name for the current dialect.
+    /// </summary>
+    private string FormatUuidv5FunctionName()
+    {
+        return $"{Quote(DmsTableNames.Document.Schema)}.{Quote("uuidv5")}";
+    }
+
+    /// <summary>
+    /// Escapes single quotes in a value for safe embedding in a SQL string literal.
+    /// </summary>
+    private static string EscapeSqlLiteral(string value) => value.Replace("'", "''");
 }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs b/src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs
index 564639306..e1374eafa 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.External/DerivedRelationalModelSetContracts.cs
@@ -212,29 +212,58 @@ DbIndexKind Kind
 );
 
 /// <summary>
-/// Classifies the logical intent of a derived trigger.
+/// Discriminated union for trigger-kind-specific parameters. Each subtype carries exactly
+/// the fields required by its trigger kind, providing compile-time type safety instead of
+/// nullable optional parameters.
 /// </summary>
-public enum DbTriggerKind
+public abstract record TriggerKindParameters
 {
+    private TriggerKindParameters() { }
+
     /// <summary>
-    /// Trigger that stamps document representation/identity versions.
+    /// Parameters for triggers that stamp document representation/identity versions.
     /// </summary>
-    DocumentStamping,
+    public sealed record DocumentStamping() : TriggerKindParameters;
 
     /// <summary>
-    /// Trigger that maintains referential identity for concrete resources.
+    /// Parameters for triggers that maintain referential identity for concrete resources.
     /// </summary>
-    ReferentialIdentityMaintenance,
+    /// <param name="ResourceKeyId">The resource key ID for UUIDv5 computation.</param>
+    /// <param name="ProjectName">The project name for UUIDv5 computation.</param>
+    /// <param name="ResourceName">The resource name for UUIDv5 computation.</param>
+    /// <param name="IdentityElements">Identity element mappings for UUIDv5 computation.</param>
+    /// <param name="SuperclassAlias">
+    /// Superclass alias information for subclass resources. <c>null</c> for non-subclass resources.
+    /// </param>
+    public sealed record ReferentialIdentityMaintenance(
+        short ResourceKeyId,
+        string ProjectName,
+        string ResourceName,
+        IReadOnlyList<IdentityElementMapping> IdentityElements,
+        SuperclassAliasInfo? SuperclassAlias = null
+    ) : TriggerKindParameters;
 
     /// <summary>
-    /// Trigger that maintains abstract identity tables from concrete roots.
+    /// Parameters for triggers that maintain abstract identity tables from concrete roots.
     /// </summary>
-    AbstractIdentityMaintenance,
+    /// <param name="TargetTable">The abstract identity table being maintained.</param>
+    /// <param name="TargetColumnMappings">Column mappings from the source table to the target table.</param>
+    /// <param name="DiscriminatorValue">The discriminator value written to the abstract identity table.</param>
+    public sealed record AbstractIdentityMaintenance(
+        DbTableName TargetTable,
+        IReadOnlyList<TriggerColumnMapping> TargetColumnMappings,
+        string DiscriminatorValue
+    ) : TriggerKindParameters;
 
     /// <summary>
-    /// Trigger-based fallback for identity propagation when cascade paths are constrained.
+    /// Parameters for trigger-based fallback for identity propagation when cascade paths are constrained.
     /// </summary>
-    IdentityPropagationFallback,
+    /// <param name="TargetTable">The target table whose columns are updated.</param>
+    /// <param name="TargetColumnMappings">Column mappings from the source table to the target table.</param>
+    public sealed record IdentityPropagationFallback(
+        DbTableName TargetTable,
+        IReadOnlyList<TriggerColumnMapping> TargetColumnMappings
+    ) : TriggerKindParameters;
 }
 
 /// <summary>
@@ -243,33 +272,56 @@ public enum DbTriggerKind
 /// <param name="Value">The trigger identifier.</param>
 public readonly record struct DbTriggerName(string Value);
 
+/// <summary>
+/// Maps a root table column to its identity JSON path for UUIDv5 computation.
+/// </summary>
+/// <param name="Column">The physical column on the root table.</param>
+/// <param name="IdentityJsonPath">The canonical JSON path label used in the UUIDv5 hash string.</param>
+public sealed record IdentityElementMapping(DbColumnName Column, string IdentityJsonPath);
+
+/// <summary>
+/// Superclass alias information for subclass resources that must also maintain referential identity
+/// under their superclass resource key.
+/// </summary>
+/// <param name="ResourceKeyId">The superclass resource key ID.</param>
+/// <param name="ProjectName">The superclass project name.</param>
+/// <param name="ResourceName">The superclass resource name.</param>
+/// <param name="IdentityElements">Identity element mappings for the superclass identity.</param>
+public sealed record SuperclassAliasInfo(
+    short ResourceKeyId,
+    string ProjectName,
+    string ResourceName,
+    IReadOnlyList<IdentityElementMapping> IdentityElements
+);
+
+/// <summary>
+/// Maps a source column on the trigger's owning table to a target column on the maintenance table.
+/// </summary>
+/// <param name="SourceColumn">The column on the trigger's owning table.</param>
+/// <param name="TargetColumn">The corresponding column on the target table.</param>
+public sealed record TriggerColumnMapping(DbColumnName SourceColumn, DbColumnName TargetColumn);
+
 /// <summary>
 /// Derived trigger inventory entry.
 /// </summary>
 /// <param name="Name">The trigger name.</param>
 /// <param name="Table">The owning table.</param>
-/// <param name="Kind">The trigger intent classification.</param>
 /// <param name="KeyColumns">Key columns used to identify the affected <c>DocumentId</c>.</param>
 /// <param name="IdentityProjectionColumns">
 /// Columns whose change affects the resource identity projection. For
-/// <see cref="DbTriggerKind.DocumentStamping"/> triggers on root tables, these are the columns
+/// <see cref="TriggerKindParameters.DocumentStamping"/> triggers on root tables, these are the columns
 /// that should additionally bump <c>IdentityVersion</c>. For
-/// <see cref="DbTriggerKind.ReferentialIdentityMaintenance"/> and
-/// <see cref="DbTriggerKind.AbstractIdentityMaintenance"/> triggers, these are the columns that
+/// <see cref="TriggerKindParameters.ReferentialIdentityMaintenance"/> and
+/// <see cref="TriggerKindParameters.AbstractIdentityMaintenance"/> triggers, these are the columns that
 /// trigger recomputation. Empty for child/extension table stamping triggers.
 /// </param>
-/// <param name="TargetTable">
-/// The maintenance target table, when applicable. For
-/// <see cref="DbTriggerKind.AbstractIdentityMaintenance"/> triggers, this identifies the abstract
-/// identity table being maintained. <c>null</c> for other trigger kinds.
-/// </param>
+/// <param name="Parameters">The trigger-kind-specific parameters.</param>
 public sealed record DbTriggerInfo(
     DbTriggerName Name,
     DbTableName Table,
-    DbTriggerKind Kind,
     IReadOnlyList<DbColumnName> KeyColumns,
     IReadOnlyList<DbColumnName> IdentityProjectionColumns,
-    DbTableName? TargetTable = null
+    TriggerKindParameters Parameters
 );
 
 /// <summary>
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DdlIdentifierQuotingTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DdlIdentifierQuotingTests.cs
index 694e777d1..64a776cd0 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DdlIdentifierQuotingTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DdlIdentifierQuotingTests.cs
@@ -91,7 +91,7 @@ public static void AssertQuotedIdentifiers(string sql, SqlDialect dialect)
         sql.Should().Contain(quoted);
         sql.Should().Contain("CREATE TABLE");
         Regex.IsMatch(sql, @"CREATE\s+(UNIQUE\s+)?INDEX").Should().BeTrue();
-        sql.Should().Contain("CREATE TRIGGER");
+        Regex.IsMatch(sql, @"CREATE\s+(OR\s+(REPLACE|ALTER)\s+)?TRIGGER").Should().BeTrue();
         sql.Should().Contain($"CONSTRAINT {quoted}");
 
         AssertNoUnquotedIdentifier(sql, dialect);
@@ -188,9 +188,9 @@ [new DbIndexInfo(new DbIndexName(Identifier), table, [column], true, DbIndexKind
                 new DbTriggerInfo(
                     new DbTriggerName(Identifier),
                     table,
-                    DbTriggerKind.DocumentStamping,
                     [column],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 ),
             ]
         );
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs
index b4ba2b6a2..77be8f139 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DeriveTriggerInventoryPassTests.cs
@@ -45,7 +45,7 @@ public void Setup()
     public void It_should_create_DocumentStamping_trigger_for_root_table()
     {
         var schoolStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "School" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "School" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         schoolStamp.Should().NotBeNull();
@@ -60,7 +60,7 @@ public void It_should_create_DocumentStamping_trigger_for_root_table()
     public void It_should_include_identity_projection_columns_on_root_table_stamping_trigger()
     {
         var schoolStamp = _triggers.Single(t =>
-            t.Table.Name == "School" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "School" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         schoolStamp.IdentityProjectionColumns.Should().NotBeEmpty();
@@ -77,7 +77,7 @@ public void It_should_include_identity_projection_columns_on_root_table_stamping
     public void It_should_create_DocumentStamping_trigger_for_child_table()
     {
         var childStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "SchoolAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         childStamp.Should().NotBeNull();
@@ -91,7 +91,7 @@ public void It_should_create_DocumentStamping_trigger_for_child_table()
     public void It_should_use_root_document_ID_as_KeyColumns_on_child_table_stamping_trigger()
     {
         var childStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         childStamp.KeyColumns.Should().ContainSingle();
@@ -105,7 +105,7 @@ public void It_should_use_root_document_ID_as_KeyColumns_on_child_table_stamping
     public void It_should_have_empty_identity_projection_columns_on_child_table_stamping_trigger()
     {
         var childStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         childStamp.IdentityProjectionColumns.Should().BeEmpty();
@@ -118,13 +118,17 @@ public void It_should_have_empty_identity_projection_columns_on_child_table_stam
     public void It_should_create_ReferentialIdentityMaintenance_trigger_on_root_table()
     {
         var refIdentity = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "School" && t.Kind == DbTriggerKind.ReferentialIdentityMaintenance
+            t.Table.Name == "School" && t.Parameters is TriggerKindParameters.ReferentialIdentityMaintenance
         );
 
         refIdentity.Should().NotBeNull();
         refIdentity!.Name.Value.Should().Be("TR_School_ReferentialIdentity");
         refIdentity.KeyColumns.Select(c => c.Value).Should().Equal("DocumentId");
         refIdentity.IdentityProjectionColumns.Should().NotBeEmpty();
+        var refIdParams = refIdentity.Parameters as TriggerKindParameters.ReferentialIdentityMaintenance;
+        refIdParams.Should().NotBeNull();
+        refIdParams!.IdentityElements.Should().NotBeEmpty();
+        refIdParams.IdentityElements.Select(e => e.Column.Value).Should().Contain("EducationOrganizationId");
     }
 
     /// <summary>
@@ -134,14 +138,22 @@ public void It_should_create_ReferentialIdentityMaintenance_trigger_on_root_tabl
     public void It_should_create_AbstractIdentityMaintenance_trigger_for_subclass_resource()
     {
         var abstractMaintenance = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "School" && t.Kind == DbTriggerKind.AbstractIdentityMaintenance
+            t.Table.Name == "School" && t.Parameters is TriggerKindParameters.AbstractIdentityMaintenance
         );
 
         abstractMaintenance.Should().NotBeNull();
         abstractMaintenance!.Name.Value.Should().Be("TR_School_AbstractIdentity");
         abstractMaintenance.KeyColumns.Select(c => c.Value).Should().Equal("DocumentId");
-        abstractMaintenance.TargetTable.Should().NotBeNull();
-        abstractMaintenance.TargetTable!.Value.Name.Should().Be("EducationOrganizationIdentity");
+        var abstractParams =
+            abstractMaintenance.Parameters as TriggerKindParameters.AbstractIdentityMaintenance;
+        abstractParams.Should().NotBeNull();
+        abstractParams!.TargetTable.Name.Should().Be("EducationOrganizationIdentity");
+        abstractParams.TargetColumnMappings.Should().NotBeEmpty();
+        abstractParams
+            .TargetColumnMappings.Select(m => m.TargetColumn.Value)
+            .Should()
+            .Contain("EducationOrganizationId");
+        abstractParams.DiscriminatorValue.Should().Be("Ed-Fi:School");
     }
 }
 
@@ -188,7 +200,7 @@ public void Setup()
     public void It_should_create_DocumentStamping_trigger_on_extension_table()
     {
         var extensionStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "ContactExtension" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "ContactExtension" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         extensionStamp.Should().NotBeNull();
@@ -201,7 +213,7 @@ public void It_should_create_DocumentStamping_trigger_on_extension_table()
     public void It_should_use_DocumentId_as_KeyColumns_on_extension_table_stamping_trigger()
     {
         var extensionStamp = _triggers.Single(t =>
-            t.Table.Name == "ContactExtension" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "ContactExtension" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         extensionStamp.KeyColumns.Should().ContainSingle();
@@ -282,7 +294,9 @@ public void Setup()
     [Test]
     public void It_should_not_emit_any_IdentityPropagationFallback_triggers_on_Pgsql()
     {
-        var fallbackTriggers = _triggers.Where(t => t.Kind == DbTriggerKind.IdentityPropagationFallback);
+        var fallbackTriggers = _triggers.Where(t =>
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
+        );
 
         fallbackTriggers.Should().BeEmpty();
     }
@@ -324,7 +338,7 @@ public void Setup()
     public void It_should_emit_propagation_trigger_for_allowIdentityUpdates_target()
     {
         var schoolPropagation = _triggers.SingleOrDefault(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_School"
         );
 
@@ -339,7 +353,7 @@ public void It_should_emit_propagation_trigger_for_allowIdentityUpdates_target()
     public void It_should_not_emit_propagation_trigger_for_non_updatable_target()
     {
         var studentPropagation = _triggers.SingleOrDefault(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_Student"
         );
 
@@ -353,7 +367,7 @@ public void It_should_not_emit_propagation_trigger_for_non_updatable_target()
     public void It_should_use_FK_column_as_key_column()
     {
         var schoolPropagation = _triggers.Single(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_School"
         );
 
@@ -368,7 +382,7 @@ public void It_should_use_FK_column_as_key_column()
     public void It_should_include_propagated_identity_columns()
     {
         var schoolPropagation = _triggers.Single(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_School"
         );
 
@@ -386,12 +400,14 @@ public void It_should_include_propagated_identity_columns()
     public void It_should_set_target_table_to_referenced_resource_root()
     {
         var schoolPropagation = _triggers.Single(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_School"
         );
 
-        schoolPropagation.TargetTable.Should().NotBeNull();
-        schoolPropagation.TargetTable!.Value.Name.Should().Be("School");
+        var propagationParams =
+            schoolPropagation.Parameters as TriggerKindParameters.IdentityPropagationFallback;
+        propagationParams.Should().NotBeNull();
+        propagationParams!.TargetTable.Name.Should().Be("School");
     }
 }
 
@@ -431,7 +447,7 @@ public void Setup()
     public void It_should_emit_propagation_trigger_for_abstract_target()
     {
         var propagation = _triggers.SingleOrDefault(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_EducationOrganization"
         );
 
@@ -446,12 +462,13 @@ public void It_should_emit_propagation_trigger_for_abstract_target()
     public void It_should_target_the_abstract_identity_table()
     {
         var propagation = _triggers.Single(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_EducationOrganization"
         );
 
-        propagation.TargetTable.Should().NotBeNull();
-        propagation.TargetTable!.Value.Name.Should().Be("EducationOrganizationIdentity");
+        var propagationParams = propagation.Parameters as TriggerKindParameters.IdentityPropagationFallback;
+        propagationParams.Should().NotBeNull();
+        propagationParams!.TargetTable.Name.Should().Be("EducationOrganizationIdentity");
     }
 
     /// <summary>
@@ -461,7 +478,7 @@ public void It_should_target_the_abstract_identity_table()
     public void It_should_use_FK_column_as_key_column_for_abstract_reference()
     {
         var propagation = _triggers.Single(t =>
-            t.Kind == DbTriggerKind.IdentityPropagationFallback
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
             && t.Name.Value == "TR_Enrollment_Propagation_EducationOrganization"
         );
 
@@ -505,7 +522,7 @@ public void Setup()
     public void It_should_create_DocumentStamping_trigger_for_grandchild_table()
     {
         var grandchildStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "SchoolAddressPeriod" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddressPeriod" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         grandchildStamp.Should().NotBeNull();
@@ -519,7 +536,7 @@ public void It_should_create_DocumentStamping_trigger_for_grandchild_table()
     public void It_should_use_root_document_ID_as_KeyColumns_on_grandchild_table()
     {
         var grandchildStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddressPeriod" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddressPeriod" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         grandchildStamp.KeyColumns.Should().ContainSingle();
@@ -533,7 +550,7 @@ public void It_should_use_root_document_ID_as_KeyColumns_on_grandchild_table()
     public void It_should_have_empty_identity_projection_columns_on_grandchild_table()
     {
         var grandchildStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddressPeriod" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddressPeriod" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         grandchildStamp.IdentityProjectionColumns.Should().BeEmpty();
@@ -545,7 +562,7 @@ public void It_should_have_empty_identity_projection_columns_on_grandchild_table
     [Test]
     public void It_should_create_DocumentStamping_triggers_for_all_three_levels()
     {
-        var stampTriggers = _triggers.Where(t => t.Kind == DbTriggerKind.DocumentStamping);
+        var stampTriggers = _triggers.Where(t => t.Parameters is TriggerKindParameters.DocumentStamping);
 
         stampTriggers.Should().HaveCount(3);
     }
@@ -557,10 +574,10 @@ public void It_should_create_DocumentStamping_triggers_for_all_three_levels()
     public void It_should_use_same_root_document_ID_column_across_all_child_levels()
     {
         var childStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
         var grandchildStamp = _triggers.Single(t =>
-            t.Table.Name == "SchoolAddressPeriod" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "SchoolAddressPeriod" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         childStamp.KeyColumns[0].Value.Should().Be("School_DocumentId");
@@ -603,10 +620,10 @@ public void Setup()
     public void It_should_create_DocumentStamping_trigger_for_each_sibling_collection()
     {
         var addressStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "StudentAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "StudentAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
         var telephoneStamp = _triggers.SingleOrDefault(t =>
-            t.Table.Name == "StudentTelephone" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "StudentTelephone" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         addressStamp.Should().NotBeNull();
@@ -620,10 +637,10 @@ public void It_should_create_DocumentStamping_trigger_for_each_sibling_collectio
     public void It_should_produce_distinct_trigger_names_for_sibling_tables()
     {
         var addressStamp = _triggers.Single(t =>
-            t.Table.Name == "StudentAddress" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "StudentAddress" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
         var telephoneStamp = _triggers.Single(t =>
-            t.Table.Name == "StudentTelephone" && t.Kind == DbTriggerKind.DocumentStamping
+            t.Table.Name == "StudentTelephone" && t.Parameters is TriggerKindParameters.DocumentStamping
         );
 
         addressStamp.Name.Value.Should().Be("TR_StudentAddress_Stamp");
@@ -636,7 +653,7 @@ public void It_should_produce_distinct_trigger_names_for_sibling_tables()
     [Test]
     public void It_should_create_three_DocumentStamping_triggers_total()
     {
-        var stampTriggers = _triggers.Where(t => t.Kind == DbTriggerKind.DocumentStamping);
+        var stampTriggers = _triggers.Where(t => t.Parameters is TriggerKindParameters.DocumentStamping);
 
         stampTriggers.Should().HaveCount(3);
     }
@@ -683,8 +700,25 @@ private static IReadOnlyList<DbTriggerInfo> BuildTriggers()
     [Test]
     public void It_should_produce_identical_trigger_sequence_on_repeated_builds()
     {
-        var firstSequence = _triggersFirst.Select(t => (t.Table.Name, t.Name.Value, t.Kind)).ToList();
-        var secondSequence = _triggersSecond.Select(t => (t.Table.Name, t.Name.Value, t.Kind)).ToList();
+        static string KindLabel(TriggerKindParameters p) =>
+            p switch
+            {
+                TriggerKindParameters.DocumentStamping => "DocumentStamping",
+                TriggerKindParameters.ReferentialIdentityMaintenance => "ReferentialIdentityMaintenance",
+                TriggerKindParameters.AbstractIdentityMaintenance => "AbstractIdentityMaintenance",
+                TriggerKindParameters.IdentityPropagationFallback => "IdentityPropagationFallback",
+                _ => throw new ArgumentOutOfRangeException(
+                    nameof(p),
+                    "Unsupported trigger kind parameters type."
+                ),
+            };
+
+        var firstSequence = _triggersFirst
+            .Select(t => (t.Table.Name, t.Name.Value, KindLabel(t.Parameters)))
+            .ToList();
+        var secondSequence = _triggersSecond
+            .Select(t => (t.Table.Name, t.Name.Value, KindLabel(t.Parameters)))
+            .ToList();
 
         firstSequence.Should().Equal(secondSequence);
     }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderInvariantTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderInvariantTests.cs
index f838440b6..2f593d5a4 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderInvariantTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderInvariantTests.cs
@@ -222,18 +222,18 @@ public void Execute(RelationalModelSetBuilderContext context)
                 new DbTriggerInfo(
                     new DbTriggerName("TR_School"),
                     table,
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
             context.TriggerInventory.Add(
                 new DbTriggerInfo(
                     new DbTriggerName("TR_School"),
                     table,
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
         }
@@ -426,18 +426,18 @@ public void Execute(RelationalModelSetBuilderContext context)
             new DbTriggerInfo(
                 new DbTriggerName("TR_Common"),
                 tableAlpha,
-                DbTriggerKind.DocumentStamping,
                 [],
-                []
+                [],
+                new TriggerKindParameters.DocumentStamping()
             )
         );
         context.TriggerInventory.Add(
             new DbTriggerInfo(
                 new DbTriggerName("TR_Common"),
                 tableBeta,
-                DbTriggerKind.DocumentStamping,
                 [],
-                []
+                [],
+                new TriggerKindParameters.DocumentStamping()
             )
         );
     }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderOrderingTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderOrderingTests.cs
index 0f9a82b04..21f293f0a 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderOrderingTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DerivedRelationalModelSetBuilderOrderingTests.cs
@@ -127,9 +127,21 @@ private sealed class PopulateUnorderedCollectionsPass : IRelationalModelSetPass
         /// </summary>
         public PopulateUnorderedCollectionsPass(EffectiveSchemaSet effectiveSchemaSet)
         {
-            _school = FindResourceKey(effectiveSchemaSet, "Ed-Fi", "School");
-            _schoolTypeDescriptor = FindResourceKey(effectiveSchemaSet, "Ed-Fi", "SchoolTypeDescriptor");
-            _section = FindResourceKey(effectiveSchemaSet, "Sample", "Section");
+            _school = DerivedRelationalModelSetInvariantTestHelpers.FindResourceKey(
+                effectiveSchemaSet,
+                "Ed-Fi",
+                "School"
+            );
+            _schoolTypeDescriptor = DerivedRelationalModelSetInvariantTestHelpers.FindResourceKey(
+                effectiveSchemaSet,
+                "Ed-Fi",
+                "SchoolTypeDescriptor"
+            );
+            _section = DerivedRelationalModelSetInvariantTestHelpers.FindResourceKey(
+                effectiveSchemaSet,
+                "Sample",
+                "Section"
+            );
         }
 
         /// <summary>
@@ -209,36 +221,36 @@ public void Execute(RelationalModelSetBuilderContext context)
                 new DbTriggerInfo(
                     new DbTriggerName("TR_Section_B"),
                     new DbTableName(sampleSchema, "Section"),
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
             context.TriggerInventory.Add(
                 new DbTriggerInfo(
                     new DbTriggerName("TR_School_B"),
                     new DbTableName(edfiSchema, "School"),
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
             context.TriggerInventory.Add(
                 new DbTriggerInfo(
                     new DbTriggerName("TR_SchoolTypeDescriptor"),
                     new DbTableName(edfiSchema, "SchoolTypeDescriptor"),
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
             context.TriggerInventory.Add(
                 new DbTriggerInfo(
                     new DbTriggerName("TR_School_A"),
                     new DbTableName(edfiSchema, "School"),
-                    DbTriggerKind.DocumentStamping,
                     [],
-                    []
+                    [],
+                    new TriggerKindParameters.DocumentStamping()
                 )
             );
         }
@@ -309,23 +321,5 @@ string tableName
                 ]
             );
         }
-
-        /// <summary>
-        /// Find resource key.
-        /// </summary>
-        private static ResourceKeyEntry FindResourceKey(
-            EffectiveSchemaSet effectiveSchemaSet,
-            string projectName,
-            string resourceName
-        )
-        {
-            ArgumentNullException.ThrowIfNull(effectiveSchemaSet);
-
-            var resourceKey = effectiveSchemaSet.EffectiveSchema.ResourceKeysInIdOrder.Single(entry =>
-                entry.Resource.ProjectName == projectName && entry.Resource.ResourceName == resourceName
-            );
-
-            return resourceKey;
-        }
     }
 }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DialectIdentifierShorteningTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DialectIdentifierShorteningTests.cs
index 09d41bbae..a069e31d5 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DialectIdentifierShorteningTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/DialectIdentifierShorteningTests.cs
@@ -552,6 +552,181 @@ public string ShortenIdentifier(string identifier)
     }
 }
 
+/// <summary>
+/// Test fixture verifying that dialect shortening applies to column names inside trigger parameter subtypes.
+/// </summary>
+[TestFixture]
+public class Given_Trigger_Parameter_Column_Shortening
+{
+    private DerivedRelationalModelSet _result = default!;
+    private ISqlDialectRules _dialectRules = default!;
+    private TriggerParameterColumnIdentifiers _identifiers = default!;
+
+    [SetUp]
+    public void Setup()
+    {
+        _dialectRules = new PgsqlDialectRules();
+        _identifiers = TriggerParameterColumnIdentifiers.Create(_dialectRules.MaxIdentifierLength + 12);
+        var effectiveSchemaSet = EffectiveSchemaSetFixtureBuilder.CreateHandAuthoredEffectiveSchemaSet();
+        var builder = new DerivedRelationalModelSetBuilder([
+            new TriggerParameterColumnFixturePass(_identifiers),
+            new ApplyDialectIdentifierShorteningPass(),
+        ]);
+
+        _result = builder.Build(effectiveSchemaSet, _dialectRules.Dialect, _dialectRules);
+    }
+
+    [Test]
+    public void It_should_shorten_abstract_identity_maintenance_target_column_mappings()
+    {
+        var trigger = _result.TriggersInCreateOrder.Single(t =>
+            t.Parameters is TriggerKindParameters.AbstractIdentityMaintenance
+        );
+        var parameters = (TriggerKindParameters.AbstractIdentityMaintenance)trigger.Parameters;
+        var mapping = parameters.TargetColumnMappings.Single();
+
+        mapping.SourceColumn.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.SourceColumn));
+        mapping.TargetColumn.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.TargetColumn));
+    }
+
+    [Test]
+    public void It_should_shorten_identity_propagation_fallback_target_column_mappings()
+    {
+        var trigger = _result.TriggersInCreateOrder.Single(t =>
+            t.Parameters is TriggerKindParameters.IdentityPropagationFallback
+        );
+        var parameters = (TriggerKindParameters.IdentityPropagationFallback)trigger.Parameters;
+        var mapping = parameters.TargetColumnMappings.Single();
+
+        mapping.SourceColumn.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.SourceColumn));
+        mapping.TargetColumn.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.TargetColumn));
+    }
+
+    [Test]
+    public void It_should_shorten_referential_identity_maintenance_identity_elements()
+    {
+        var trigger = _result.TriggersInCreateOrder.Single(t =>
+            t.Parameters is TriggerKindParameters.ReferentialIdentityMaintenance
+        );
+        var parameters = (TriggerKindParameters.ReferentialIdentityMaintenance)trigger.Parameters;
+        var element = parameters.IdentityElements.Single();
+
+        element.Column.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.IdentityColumn));
+    }
+
+    [Test]
+    public void It_should_shorten_superclass_alias_identity_elements()
+    {
+        var trigger = _result.TriggersInCreateOrder.Single(t =>
+            t.Parameters is TriggerKindParameters.ReferentialIdentityMaintenance
+        );
+        var parameters = (TriggerKindParameters.ReferentialIdentityMaintenance)trigger.Parameters;
+        var aliasElement = parameters.SuperclassAlias!.IdentityElements.Single();
+
+        aliasElement.Column.Value.Should().Be(_dialectRules.ShortenIdentifier(_identifiers.AliasColumn));
+    }
+}
+
+/// <summary>
+/// Long identifier values for trigger parameter column shortening tests.
+/// </summary>
+internal sealed record TriggerParameterColumnIdentifiers(
+    string SourceColumn,
+    string TargetColumn,
+    string IdentityColumn,
+    string AliasColumn
+)
+{
+    public static TriggerParameterColumnIdentifiers Create(int length)
+    {
+        return new TriggerParameterColumnIdentifiers(
+            SourceColumn: BuildLong("SourceCol", length),
+            TargetColumn: BuildLong("TargetCol", length),
+            IdentityColumn: BuildLong("IdentityCol", length),
+            AliasColumn: BuildLong("AliasCol", length)
+        );
+    }
+
+    private static string BuildLong(string label, int length)
+    {
+        return label.Length >= length ? label : label + new string('A', length - label.Length);
+    }
+}
+
+/// <summary>
+/// Fixture pass that seeds triggers with each non-DocumentStamping parameter subtype containing long column names.
+/// </summary>
+file sealed class TriggerParameterColumnFixturePass(TriggerParameterColumnIdentifiers identifiers)
+    : IRelationalModelSetPass
+{
+    public void Execute(RelationalModelSetBuilderContext context)
+    {
+        ArgumentNullException.ThrowIfNull(context);
+
+        var schema = new DbSchemaName("edfi");
+        var table = new DbTableName(schema, "School");
+        var targetTable = new DbTableName(schema, "EducationOrganization");
+
+        context.TriggerInventory.Add(
+            new DbTriggerInfo(
+                new DbTriggerName("TR_AbstractId"),
+                table,
+                [],
+                [],
+                new TriggerKindParameters.AbstractIdentityMaintenance(
+                    targetTable,
+                    [
+                        new TriggerColumnMapping(
+                            new DbColumnName(identifiers.SourceColumn),
+                            new DbColumnName(identifiers.TargetColumn)
+                        ),
+                    ],
+                    "School"
+                )
+            )
+        );
+
+        context.TriggerInventory.Add(
+            new DbTriggerInfo(
+                new DbTriggerName("TR_Propagation"),
+                table,
+                [],
+                [],
+                new TriggerKindParameters.IdentityPropagationFallback(
+                    targetTable,
+                    [
+                        new TriggerColumnMapping(
+                            new DbColumnName(identifiers.SourceColumn),
+                            new DbColumnName(identifiers.TargetColumn)
+                        ),
+                    ]
+                )
+            )
+        );
+
+        context.TriggerInventory.Add(
+            new DbTriggerInfo(
+                new DbTriggerName("TR_RefIdentity"),
+                table,
+                [],
+                [],
+                new TriggerKindParameters.ReferentialIdentityMaintenance(
+                    1,
+                    "Ed-Fi",
+                    "School",
+                    [new IdentityElementMapping(new DbColumnName(identifiers.IdentityColumn), "$.id")],
+                    new SuperclassAliasInfo(
+                        2,
+                        "Ed-Fi",
+                        "EducationOrganization",
+                        [new IdentityElementMapping(new DbColumnName(identifiers.AliasColumn), "$.parentId")]
+                    )
+                )
+            )
+        );
+    }
+}
+
 /// <summary>
 /// Captures a single identifier-shortening test run, including the derived model and the long identifiers
 /// used as inputs.
@@ -989,9 +1164,9 @@ [new DbColumnName(_identifiers.KeyColumnName)],
             new DbTriggerInfo(
                 new DbTriggerName(_identifiers.TriggerName),
                 tableName,
-                DbTriggerKind.DocumentStamping,
                 [new DbColumnName(_identifiers.KeyColumnName)],
-                []
+                [],
+                new TriggerKindParameters.DocumentStamping()
             )
         );
     }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/Fixtures/authoritative/sample/expected/authoritative-derived-relational-model-set.json b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/Fixtures/authoritative/sample/expected/authoritative-derived-relational-model-set.json
index df4db4adf..f37db27e4 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/Fixtures/authoritative/sample/expected/authoritative-derived-relational-model-set.json
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/Fixtures/authoritative/sample/expected/authoritative-derived-relational-model-set.json
@@ -30146,7 +30146,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "CommunityOrganizationId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:CommunityOrganization"
     },
     {
       "name": "TR_CommunityOrganization_ReferentialIdentity",
@@ -30288,7 +30295,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "CommunityProviderId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:CommunityProvider"
     },
     {
       "name": "TR_CommunityProvider_ReferentialIdentity",
@@ -31332,7 +31346,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "EducationOrganizationNetworkId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:EducationOrganizationNetwork"
     },
     {
       "name": "TR_EducationOrganizationNetwork_ReferentialIdentity",
@@ -31534,7 +31555,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "EducationServiceCenterId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:EducationServiceCenter"
     },
     {
       "name": "TR_EducationServiceCenter_ReferentialIdentity",
@@ -32680,7 +32708,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "LocalEducationAgencyId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:LocalEducationAgency"
     },
     {
       "name": "TR_LocalEducationAgency_ReferentialIdentity",
@@ -33154,7 +33189,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "OrganizationDepartmentId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:OrganizationDepartment"
     },
     {
       "name": "TR_OrganizationDepartment_ReferentialIdentity",
@@ -33358,7 +33400,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "PostSecondaryInstitutionId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:PostSecondaryInstitution"
     },
     {
       "name": "TR_PostSecondaryInstitution_ReferentialIdentity",
@@ -33918,7 +33967,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "SchoolId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:School"
     },
     {
       "name": "TR_School_ReferentialIdentity",
@@ -34944,7 +35000,14 @@
       "target_table": {
         "schema": "edfi",
         "name": "EducationOrganizationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "StateEducationAgencyId",
+          "target_column": "EducationOrganizationId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StateEducationAgency"
     },
     {
       "name": "TR_StateEducationAgency_ReferentialIdentity",
@@ -35479,7 +35542,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentCTEProgramAssociation"
     },
     {
       "name": "TR_StudentCTEProgramAssociation_ReferentialIdentity",
@@ -36228,7 +36318,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentHomelessProgramAssociation"
     },
     {
       "name": "TR_StudentHomelessProgramAssociation_ReferentialIdentity",
@@ -36395,7 +36512,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentLanguageInstructionProgramAssociation"
     },
     {
       "name": "TR_StudentLanguageInstructionProgramAssociation_Refe_8658d721a3",
@@ -36486,7 +36630,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentMigrantEducationProgramAssociation"
     },
     {
       "name": "TR_StudentMigrantEducationProgramAssociation_Referen_654de036cb",
@@ -36565,7 +36736,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentNeglectedOrDelinquentProgramAssociation"
     },
     {
       "name": "TR_StudentNeglectedOrDelinquentProgramAssociation_Re_699dcdd09c",
@@ -36668,7 +36866,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentProgramAssociation"
     },
     {
       "name": "TR_StudentProgramAssociation_ReferentialIdentity",
@@ -36943,7 +37168,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentSchoolFoodServiceProgramAssociation"
     },
     {
       "name": "TR_StudentSchoolFoodServiceProgramAssociation_Refere_e2f2b09b1b",
@@ -37022,7 +37274,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentSection504ProgramAssociation"
     },
     {
       "name": "TR_StudentSection504ProgramAssociation_ReferentialIdentity",
@@ -37179,7 +37458,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentSpecialEducationProgramAssociation"
     },
     {
       "name": "TR_StudentSpecialEducationProgramAssociation_Referen_e816d5e0e9",
@@ -37340,7 +37646,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Ed-Fi:StudentTitleIPartAProgramAssociation"
     },
     {
       "name": "TR_StudentTitleIPartAProgramAssociation_ReferentialIdentity",
@@ -38209,7 +38542,34 @@
       "target_table": {
         "schema": "edfi",
         "name": "GeneralStudentProgramAssociationIdentity"
-      }
+      },
+      "target_column_mappings": [
+        {
+          "source_column": "BeginDate",
+          "target_column": "BeginDate"
+        },
+        {
+          "source_column": "EducationOrganization_DocumentId",
+          "target_column": "EducationOrganizationReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceEducationOrganizationId"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramName"
+        },
+        {
+          "source_column": "ProgramProgram_DocumentId",
+          "target_column": "ProgramReferenceProgramTypeDescriptor"
+        },
+        {
+          "source_column": "Student_DocumentId",
+          "target_column": "StudentReferenceStudentUniqueId"
+        }
+      ],
+      "discriminator_value": "Sample:StudentArtProgramAssociation"
     },
     {
       "name": "TR_StudentArtProgramAssociation_ReferentialIdentity",
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/IdentifierShorteningScopeTests.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/IdentifierShorteningScopeTests.cs
index 63963cf07..e46565af5 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/IdentifierShorteningScopeTests.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel.Tests.Unit/IdentifierShorteningScopeTests.cs
@@ -262,18 +262,18 @@ public void Execute(RelationalModelSetBuilderContext context)
             new DbTriggerInfo(
                 new DbTriggerName("TR_LongAlpha"),
                 tableAlpha,
-                DbTriggerKind.DocumentStamping,
                 [],
-                []
+                [],
+                new TriggerKindParameters.DocumentStamping()
             )
         );
         context.TriggerInventory.Add(
             new DbTriggerInfo(
                 new DbTriggerName("TR_LongBeta"),
                 tableBeta,
-                DbTriggerKind.DocumentStamping,
                 [],
-                []
+                [],
+                new TriggerKindParameters.DocumentStamping()
             )
         );
     }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Build/RelationalModelManifestEmitter.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Build/RelationalModelManifestEmitter.cs
index 0b699dafb..00b9b310c 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Build/RelationalModelManifestEmitter.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Build/RelationalModelManifestEmitter.cs
@@ -15,7 +15,7 @@ namespace EdFi.DataManagementService.Backend.RelationalModel.Build;
 /// </summary>
 public static class RelationalModelManifestEmitter
 {
-    private static readonly JsonWriterOptions _writerOptions = new() { Indented = true };
+    private static readonly JsonWriterOptions _writerOptions = new() { Indented = true, NewLine = "\n" };
 
     /// <summary>
     /// Emits a JSON manifest for a completed relational model build.
@@ -24,10 +24,7 @@ public static class RelationalModelManifestEmitter
     /// <returns>The JSON manifest.</returns>
     public static string Emit(RelationalModelBuildResult buildResult)
     {
-        if (buildResult is null)
-        {
-            throw new ArgumentNullException(nameof(buildResult));
-        }
+        ArgumentNullException.ThrowIfNull(buildResult);
 
         return Emit(buildResult.ResourceModel, buildResult.ExtensionSites);
     }
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Manifest/DerivedModelSetManifestEmitter.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Manifest/DerivedModelSetManifestEmitter.cs
index 1bb194215..0412cb983 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Manifest/DerivedModelSetManifestEmitter.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/Manifest/DerivedModelSetManifestEmitter.cs
@@ -311,16 +311,46 @@ private static void WriteTriggers(Utf8JsonWriter writer, IReadOnlyList<DbTrigger
             writer.WriteString("name", trigger.Name.Value);
             writer.WritePropertyName("table");
             WriteTableReference(writer, trigger.Table);
-            writer.WriteString("kind", trigger.Kind.ToString());
+            writer.WriteString(
+                "kind",
+                trigger.Parameters switch
+                {
+                    TriggerKindParameters.DocumentStamping => "DocumentStamping",
+                    TriggerKindParameters.ReferentialIdentityMaintenance => "ReferentialIdentityMaintenance",
+                    TriggerKindParameters.AbstractIdentityMaintenance => "AbstractIdentityMaintenance",
+                    TriggerKindParameters.IdentityPropagationFallback => "IdentityPropagationFallback",
+                    _ => throw new ArgumentOutOfRangeException(
+                        nameof(trigger),
+                        "Unsupported trigger kind parameters type."
+                    ),
+                }
+            );
             writer.WritePropertyName("key_columns");
             WriteColumnNameList(writer, trigger.KeyColumns);
             writer.WritePropertyName("identity_projection_columns");
             WriteColumnNameList(writer, trigger.IdentityProjectionColumns);
 
-            if (trigger.TargetTable is { } targetTable)
+            var targetTable = trigger.Parameters switch
+            {
+                TriggerKindParameters.AbstractIdentityMaintenance a => (DbTableName?)a.TargetTable,
+                TriggerKindParameters.IdentityPropagationFallback p => p.TargetTable,
+                _ => null,
+            };
+
+            if (targetTable is { } tt)
             {
                 writer.WritePropertyName("target_table");
-                WriteTableReference(writer, targetTable);
+                WriteTableReference(writer, tt);
+            }
+
+            if (trigger.Parameters is TriggerKindParameters.AbstractIdentityMaintenance abstractId)
+            {
+                WriteTargetColumnMappings(writer, abstractId.TargetColumnMappings);
+                writer.WriteString("discriminator_value", abstractId.DiscriminatorValue);
+            }
+            else if (trigger.Parameters is TriggerKindParameters.IdentityPropagationFallback propagation)
+            {
+                WriteTargetColumnMappings(writer, propagation.TargetColumnMappings);
             }
 
             writer.WriteEndObject();
@@ -329,6 +359,26 @@ private static void WriteTriggers(Utf8JsonWriter writer, IReadOnlyList<DbTrigger
         writer.WriteEndArray();
     }
 
+    /// <summary>
+    /// Writes a <c>target_column_mappings</c> array of source/target column pairs.
+    /// </summary>
+    private static void WriteTargetColumnMappings(
+        Utf8JsonWriter writer,
+        IReadOnlyList<TriggerColumnMapping> mappings
+    )
+    {
+        writer.WritePropertyName("target_column_mappings");
+        writer.WriteStartArray();
+        foreach (var mapping in mappings)
+        {
+            writer.WriteStartObject();
+            writer.WriteString("source_column", mapping.SourceColumn.Value);
+            writer.WriteString("target_column", mapping.TargetColumn.Value);
+            writer.WriteEndObject();
+        }
+        writer.WriteEndArray();
+    }
+
     /// <summary>
     /// Writes the optional <c>resource_details</c> array for the requested resources.
     /// </summary>
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/ApplyDialectIdentifierShorteningPass.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/ApplyDialectIdentifierShorteningPass.cs
index 1344e926d..d0d8c29d6 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/ApplyDialectIdentifierShorteningPass.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/ApplyDialectIdentifierShorteningPass.cs
@@ -702,18 +702,16 @@ out bool changed
             dialectRules,
             out var identityColumnsChanged
         );
-        var updatedTargetTable = trigger.TargetTable is { } target
-            ? ShortenTable(target, dialectRules)
-            : trigger.TargetTable;
-        var targetTableChanged =
-            updatedTargetTable is not null
-            && trigger.TargetTable is not null
-            && !updatedTargetTable.Value.Equals(trigger.TargetTable.Value);
+        var updatedParameters = ApplyToTriggerParameters(
+            trigger.Parameters,
+            dialectRules,
+            out var parametersChanged
+        );
 
         changed =
             columnsChanged
             || identityColumnsChanged
-            || targetTableChanged
+            || parametersChanged
             || !updatedTable.Equals(trigger.Table)
             || !updatedName.Equals(trigger.Name);
 
@@ -728,10 +726,163 @@ updatedTargetTable is not null
             Table = updatedTable,
             KeyColumns = updatedColumns,
             IdentityProjectionColumns = updatedIdentityColumns,
-            TargetTable = updatedTargetTable,
+            Parameters = updatedParameters,
         };
     }
 
+    /// <summary>
+    /// Applies dialect shortening to trigger-kind-specific parameters and reports whether they changed.
+    /// </summary>
+    private static TriggerKindParameters ApplyToTriggerParameters(
+        TriggerKindParameters parameters,
+        ISqlDialectRules dialectRules,
+        out bool changed
+    )
+    {
+        switch (parameters)
+        {
+            case TriggerKindParameters.ReferentialIdentityMaintenance refId:
+            {
+                var updatedElements = ShortenIdentityElementMappings(
+                    refId.IdentityElements,
+                    dialectRules,
+                    out var elementsChanged
+                );
+                var updatedAlias = ShortenSuperclassAlias(
+                    refId.SuperclassAlias,
+                    dialectRules,
+                    out var aliasChanged
+                );
+                changed = elementsChanged || aliasChanged;
+                return changed
+                    ? refId with
+                    {
+                        IdentityElements = updatedElements,
+                        SuperclassAlias = updatedAlias,
+                    }
+                    : parameters;
+            }
+            case TriggerKindParameters.AbstractIdentityMaintenance abstractId:
+            {
+                var updatedTargetTable = ShortenTable(abstractId.TargetTable, dialectRules);
+                var updatedMappings = ShortenTriggerColumnMappings(
+                    abstractId.TargetColumnMappings,
+                    dialectRules,
+                    out var mappingsChanged
+                );
+                changed = mappingsChanged || !updatedTargetTable.Equals(abstractId.TargetTable);
+                return changed
+                    ? abstractId with
+                    {
+                        TargetTable = updatedTargetTable,
+                        TargetColumnMappings = updatedMappings,
+                    }
+                    : parameters;
+            }
+            case TriggerKindParameters.IdentityPropagationFallback propagation:
+            {
+                var updatedTargetTable = ShortenTable(propagation.TargetTable, dialectRules);
+                var updatedMappings = ShortenTriggerColumnMappings(
+                    propagation.TargetColumnMappings,
+                    dialectRules,
+                    out var mappingsChanged
+                );
+                changed = mappingsChanged || !updatedTargetTable.Equals(propagation.TargetTable);
+                return changed
+                    ? propagation with
+                    {
+                        TargetTable = updatedTargetTable,
+                        TargetColumnMappings = updatedMappings,
+                    }
+                    : parameters;
+            }
+            default:
+                changed = false;
+                return parameters;
+        }
+    }
+
+    /// <summary>
+    /// Shortens column names in trigger column mappings using dialect rules.
+    /// </summary>
+    private static IReadOnlyList<TriggerColumnMapping> ShortenTriggerColumnMappings(
+        IReadOnlyList<TriggerColumnMapping> mappings,
+        ISqlDialectRules dialectRules,
+        out bool changed
+    )
+    {
+        changed = false;
+        var updated = new TriggerColumnMapping[mappings.Count];
+
+        for (var i = 0; i < mappings.Count; i++)
+        {
+            var mapping = mappings[i];
+            var updatedSource = ShortenColumn(mapping.SourceColumn, dialectRules);
+            var updatedTarget = ShortenColumn(mapping.TargetColumn, dialectRules);
+
+            if (!updatedSource.Equals(mapping.SourceColumn) || !updatedTarget.Equals(mapping.TargetColumn))
+            {
+                changed = true;
+            }
+
+            updated[i] = new TriggerColumnMapping(updatedSource, updatedTarget);
+        }
+
+        return changed ? updated : mappings;
+    }
+
+    /// <summary>
+    /// Shortens column names in identity element mappings using dialect rules.
+    /// </summary>
+    private static IReadOnlyList<IdentityElementMapping> ShortenIdentityElementMappings(
+        IReadOnlyList<IdentityElementMapping> elements,
+        ISqlDialectRules dialectRules,
+        out bool changed
+    )
+    {
+        changed = false;
+        var updated = new IdentityElementMapping[elements.Count];
+
+        for (var i = 0; i < elements.Count; i++)
+        {
+            var element = elements[i];
+            var updatedColumn = ShortenColumn(element.Column, dialectRules);
+
+            if (!updatedColumn.Equals(element.Column))
+            {
+                changed = true;
+            }
+
+            updated[i] = element with { Column = updatedColumn };
+        }
+
+        return changed ? updated : elements;
+    }
+
+    /// <summary>
+    /// Shortens column names in a superclass alias's identity elements using dialect rules.
+    /// </summary>
+    private static SuperclassAliasInfo? ShortenSuperclassAlias(
+        SuperclassAliasInfo? alias,
+        ISqlDialectRules dialectRules,
+        out bool changed
+    )
+    {
+        if (alias is null)
+        {
+            changed = false;
+            return null;
+        }
+
+        var updatedElements = ShortenIdentityElementMappings(
+            alias.IdentityElements,
+            dialectRules,
+            out changed
+        );
+
+        return changed ? alias with { IdentityElements = updatedElements } : alias;
+    }
+
     /// <summary>
     /// Shortens a schema identifier using dialect rules.
     /// </summary>
diff --git a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/DeriveTriggerInventoryPass.cs b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/DeriveTriggerInventoryPass.cs
index b77bf2cff..deb2c7a1d 100644
--- a/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/DeriveTriggerInventoryPass.cs
+++ b/src/dms/backend/EdFi.DataManagementService.Backend.RelationalModel/SetPasses/DeriveTriggerInventoryPass.cs
@@ -14,6 +14,17 @@ namespace EdFi.DataManagementService.Backend.RelationalModel.SetPasses;
 /// Derives the trigger inventory for all schema-derived tables (concrete resources with
 /// <see cref="ResourceStorageKind.RelationalTables"/> storage). Descriptor resources are skipped.
 /// </summary>
+/// <remarks>
+/// <para>
+/// <b>MSSQL trigger ordering:</b> Multiple AFTER triggers may be emitted for the same table
+/// (e.g., DocumentStamping, AbstractIdentityMaintenance, ReferentialIdentityMaintenance). SQL Server
+/// does not guarantee a deterministic firing order for multiple AFTER triggers unless
+/// <c>sp_settriggerorder</c> is used. The current triggers are designed to be order-independent:
+/// each writes to a different target table and has no dependency on another trigger's side effects.
+/// If a future trigger introduces such a dependency, explicit ordering via <c>sp_settriggerorder</c>
+/// must be emitted.
+/// </para>
+/// </remarks>
 public sealed class DeriveTriggerInventoryPass : IRelationalModelSetPass
 {
     private const string StampToken = "Stamp";
@@ -31,9 +42,9 @@ public void Execute(RelationalModelSetBuilderContext context)
     {
         ArgumentNullException.ThrowIfNull(context);
 
-        var resourcesByKey = context
-            .ConcreteResourcesInNameOrder.Select((model, index) => new ResourceEntry(index, model))
-            .ToDictionary(entry => entry.Model.ResourceKey.Resource, entry => entry);
+        var resourcesByKey = context.ConcreteResourcesInNameOrder.ToDictionary(model =>
+            model.ResourceKey.Resource
+        );
 
         var abstractTablesByResource = context.AbstractIdentityTablesInNameOrder.ToDictionary(table =>
             table.AbstractResourceKey.Resource
@@ -53,15 +64,13 @@ public void Execute(RelationalModelSetBuilderContext context)
                 resourceContext.ResourceName
             );
 
-            if (!resourcesByKey.TryGetValue(resource, out var entry))
+            if (!resourcesByKey.TryGetValue(resource, out var concreteModel))
             {
                 throw new InvalidOperationException(
                     $"Concrete resource '{FormatResource(resource)}' was not found for trigger derivation."
                 );
             }
 
-            var concreteModel = entry.Model;
-
             if (concreteModel.StorageKind == ResourceStorageKind.SharedDescriptorTable)
             {
                 continue;
@@ -102,23 +111,18 @@ public void Execute(RelationalModelSetBuilderContext context)
                     new DbTriggerInfo(
                         new DbTriggerName(BuildTriggerName(table.Table, StampToken)),
                         table.Table,
-                        DbTriggerKind.DocumentStamping,
                         keyColumns,
-                        isRootTable ? identityProjectionColumns : []
+                        isRootTable ? identityProjectionColumns : [],
+                        new TriggerKindParameters.DocumentStamping()
                     )
                 );
             }
 
-            // ReferentialIdentityMaintenance trigger on the root table.
-            context.TriggerInventory.Add(
-                new DbTriggerInfo(
-                    new DbTriggerName(BuildTriggerName(rootTable.Table, ReferentialIdentityToken)),
-                    rootTable.Table,
-                    DbTriggerKind.ReferentialIdentityMaintenance,
-                    [RelationalNameConventions.DocumentIdColumnName],
-                    identityProjectionColumns
-                )
-            );
+            // Build identity element mappings for UUIDv5 computation.
+            var identityElements = BuildIdentityElementMappings(resourceModel, builderContext, resource);
+
+            // Resolve the resource key entry for referential identity metadata.
+            var resourceKeyEntry = context.GetResourceKeyEntry(resource);
 
             // AbstractIdentityMaintenance triggers — one per abstract identity table this
             // resource contributes to (discovered via subclass metadata).
@@ -128,6 +132,8 @@ public void Execute(RelationalModelSetBuilderContext context)
                 defaultValue: false
             );
 
+            SuperclassAliasInfo? superclassAlias = null;
+
             if (isSubclass)
             {
                 var superclassProjectName = RequireString(
@@ -143,21 +149,88 @@ public void Execute(RelationalModelSetBuilderContext context)
                     superclassResourceName
                 );
 
+                var superclassResourceKeyEntry = context.GetResourceKeyEntry(superclassResource);
+
+                // Build superclass identity element mappings, handling superclassIdentityJsonPath remapping.
+                var superclassIdentityJsonPath = TryGetOptionalString(
+                    resourceContext.ResourceSchema,
+                    "superclassIdentityJsonPath"
+                );
+
+                IReadOnlyList<IdentityElementMapping> superclassIdentityElements;
+                if (superclassIdentityJsonPath is not null)
+                {
+                    // When superclassIdentityJsonPath is set, the subclass has exactly one identity path
+                    // that maps to the superclass's single identity path.
+                    if (identityElements.Count != 1)
+                    {
+                        throw new InvalidOperationException(
+                            $"Subclass resource '{FormatResource(resource)}' with superclassIdentityJsonPath "
+                                + $"must have exactly one identity element, but found {identityElements.Count}."
+                        );
+                    }
+
+                    superclassIdentityElements =
+                    [
+                        new IdentityElementMapping(identityElements[0].Column, superclassIdentityJsonPath),
+                    ];
+                }
+                else
+                {
+                    // Same identity paths — reuse the concrete identity elements.
+                    superclassIdentityElements = identityElements;
+                }
+
+                superclassAlias = new SuperclassAliasInfo(
+                    superclassResourceKeyEntry.ResourceKeyId,
+                    superclassProjectName,
+                    superclassResourceName,
+                    superclassIdentityElements
+                );
+
                 if (abstractTablesByResource.TryGetValue(superclassResource, out var abstractTable))
                 {
+                    var targetColumnMappings = BuildAbstractIdentityColumnMappings(
+                        abstractTable.TableModel,
+                        resourceModel,
+                        builderContext,
+                        resource,
+                        superclassIdentityJsonPath
+                    );
+
                     context.TriggerInventory.Add(
                         new DbTriggerInfo(
                             new DbTriggerName(BuildTriggerName(rootTable.Table, AbstractIdentityToken)),
                             rootTable.Table,
-                            DbTriggerKind.AbstractIdentityMaintenance,
                             [RelationalNameConventions.DocumentIdColumnName],
                             identityProjectionColumns,
-                            abstractTable.TableModel.Table
+                            new TriggerKindParameters.AbstractIdentityMaintenance(
+                                abstractTable.TableModel.Table,
+                                targetColumnMappings,
+                                $"{resource.ProjectName}:{resource.ResourceName}"
+                            )
                         )
                     );
                 }
             }
 
+            // ReferentialIdentityMaintenance trigger on the root table.
+            context.TriggerInventory.Add(
+                new DbTriggerInfo(
+                    new DbTriggerName(BuildTriggerName(rootTable.Table, ReferentialIdentityToken)),
+                    rootTable.Table,
+                    [RelationalNameConventions.DocumentIdColumnName],
+                    identityProjectionColumns,
+                    new TriggerKindParameters.ReferentialIdentityMaintenance(
+                        resourceKeyEntry.ResourceKeyId,
+                        resource.ProjectName,
+                        resource.ResourceName,
+                        identityElements,
+                        superclassAlias
+                    )
+                )
+            );
+
             // IdentityPropagationFallback — MSSQL only: emits triggers for reference FKs that
             // would use ON UPDATE CASCADE on PostgreSQL but must use NO ACTION on SQL Server.
             if (context.Dialect == SqlDialect.Mssql && builderContext.DocumentReferenceMappings.Count > 0)
@@ -169,6 +242,7 @@ public void Execute(RelationalModelSetBuilderContext context)
                     rootTable,
                     abstractTablesByResource,
                     resourceContextsByResource,
+                    resourcesByKey,
                     resource
                 );
             }
@@ -224,7 +298,7 @@ QualifiedResourceName resource
     }
 
     /// <summary>
-    /// Emits <see cref="DbTriggerKind.IdentityPropagationFallback"/> triggers for each root-table
+    /// Emits <see cref="TriggerKindParameters.IdentityPropagationFallback"/> triggers for each root-table
     /// reference binding whose target is abstract or allows identity updates. These replace the
     /// <c>ON UPDATE CASCADE</c> that PostgreSQL handles natively but SQL Server rejects due to
     /// multiple cascade paths.
@@ -236,6 +310,7 @@ private static void EmitPropagationFallbackTriggers(
         DbTableModel rootTable,
         IReadOnlyDictionary<QualifiedResourceName, AbstractIdentityTableInfo> abstractTablesByResource,
         IReadOnlyDictionary<QualifiedResourceName, ConcreteResourceSchemaContext> resourceContextsByResource,
+        IReadOnlyDictionary<QualifiedResourceName, ConcreteResourceModel> concreteResourcesByName,
         QualifiedResourceName resource
     )
     {
@@ -257,11 +332,13 @@ QualifiedResourceName resource
                 continue;
             }
 
-            DbTableName? targetTable;
+            DbTableName targetTable;
+            DbTableModel targetTableModel;
 
             if (abstractTablesByResource.TryGetValue(mapping.TargetResource, out var abstractTableInfo))
             {
                 targetTable = abstractTableInfo.TableModel.Table;
+                targetTableModel = abstractTableInfo.TableModel;
             }
             else if (
                 resourceContextsByResource.TryGetValue(mapping.TargetResource, out var targetResourceContext)
@@ -274,16 +351,13 @@ QualifiedResourceName resource
                     continue;
                 }
 
-                var targetEntry = context.ConcreteResourcesInNameOrder.FirstOrDefault(model =>
-                    model.ResourceKey.Resource == mapping.TargetResource
-                );
-
-                if (targetEntry is null)
+                if (!concreteResourcesByName.TryGetValue(mapping.TargetResource, out var targetEntry))
                 {
                     continue;
                 }
 
                 targetTable = targetEntry.RelationalModel.Root.Table;
+                targetTableModel = targetEntry.RelationalModel.Root;
             }
             else
             {
@@ -293,16 +367,25 @@ QualifiedResourceName resource
             var referenceBaseName = ResolveReferenceBaseName(binding.FkColumn);
             var propagatedColumns = binding.IdentityBindings.Select(ib => ib.Column).ToArray();
 
+            // Build column mappings from source to target for identity propagation,
+            // resolving target column names via the identity JSON path rather than
+            // assuming source and target column names are identical.
+            var targetColumnMappings = BuildPropagationTargetColumnMappings(
+                binding,
+                mapping,
+                targetTableModel,
+                resource
+            );
+
             context.TriggerInventory.Add(
                 new DbTriggerInfo(
                     new DbTriggerName(
                         BuildTriggerName(rootTable.Table, $"{PropagationFallbackPrefix}_{referenceBaseName}")
                     ),
                     rootTable.Table,
-                    DbTriggerKind.IdentityPropagationFallback,
                     [binding.FkColumn],
                     propagatedColumns,
-                    targetTable
+                    new TriggerKindParameters.IdentityPropagationFallback(targetTable, targetColumnMappings)
                 )
             );
         }
@@ -320,6 +403,196 @@ private static string ResolveReferenceBaseName(DbColumnName fkColumn)
             : fkColumn.Value;
     }
 
+    /// <summary>
+    /// Resolves target column mappings for identity propagation by mapping each identity binding's
+    /// reference JSON path through the target resource's identity path to the physical target column.
+    /// Source column names (on the referencing table) include a reference prefix (e.g.,
+    /// <c>School_SchoolId</c>) that differs from the target table's own column name (e.g.,
+    /// <c>SchoolId</c>), so the mapping cannot assume source and target names are identical.
+    /// </summary>
+    private static IReadOnlyList<TriggerColumnMapping> BuildPropagationTargetColumnMappings(
+        DocumentReferenceBinding binding,
+        DocumentReferenceMapping mapping,
+        DbTableModel targetTableModel,
+        QualifiedResourceName resource
+    )
+    {
+        // Build lookup: reference JSON path → target identity JSON path.
+        var identityPathByReferencePath = new Dictionary<string, string>(StringComparer.Ordinal);
+        foreach (var entry in mapping.ReferenceJsonPaths)
+        {
+            identityPathByReferencePath[entry.ReferenceJsonPath.Canonical] = entry.IdentityJsonPath.Canonical;
+        }
+
+        // Build lookup: identity JSON path → target table column name.
+        var targetColumnByIdentityPath = new Dictionary<string, DbColumnName>(StringComparer.Ordinal);
+        foreach (var column in targetTableModel.Columns)
+        {
+            if (column.SourceJsonPath is not null)
+            {
+                targetColumnByIdentityPath[column.SourceJsonPath.Value.Canonical] = column.ColumnName;
+            }
+        }
+
+        return binding
+            .IdentityBindings.Select(ib =>
+            {
+                if (
+                    !identityPathByReferencePath.TryGetValue(
+                        ib.ReferenceJsonPath.Canonical,
+                        out var identityPath
+                    )
+                )
+                {
+                    throw new InvalidOperationException(
+                        $"Propagation fallback trigger derivation for resource '{FormatResource(resource)}': "
+                            + $"reference JSON path '{ib.ReferenceJsonPath.Canonical}' did not map to "
+                            + "a target identity path."
+                    );
+                }
+
+                if (!targetColumnByIdentityPath.TryGetValue(identityPath, out var targetColumn))
+                {
+                    throw new InvalidOperationException(
+                        $"Propagation fallback trigger derivation for resource '{FormatResource(resource)}': "
+                            + $"target identity path '{identityPath}' did not resolve to a column on "
+                            + $"target table '{targetTableModel.Table.Schema.Value}.{targetTableModel.Table.Name}'."
+                    );
+                }
+
+                return new TriggerColumnMapping(ib.Column, targetColumn);
+            })
+            .ToArray();
+    }
+
+    /// <summary>
+    /// Builds identity element mappings for UUIDv5 computation by pairing each identity projection
+    /// column with its canonical JSON path.
+    /// </summary>
+    private static IReadOnlyList<IdentityElementMapping> BuildIdentityElementMappings(
+        RelationalResourceModel resourceModel,
+        RelationalModelBuilderContext builderContext,
+        QualifiedResourceName resource
+    )
+    {
+        if (builderContext.IdentityJsonPaths.Count == 0)
+        {
+            return [];
+        }
+
+        var rootTable = resourceModel.Root;
+        var rootColumnsByPath = BuildColumnNameLookupBySourceJsonPath(rootTable, resource);
+        var referenceBindingsByIdentityPath = BuildReferenceIdentityBindings(
+            resourceModel.DocumentReferenceBindings,
+            resource
+        );
+
+        HashSet<string> seenColumns = new(StringComparer.Ordinal);
+        List<IdentityElementMapping> mappings = new(builderContext.IdentityJsonPaths.Count);
+
+        foreach (var identityPath in builderContext.IdentityJsonPaths)
+        {
+            DbColumnName column;
+
+            if (referenceBindingsByIdentityPath.TryGetValue(identityPath.Canonical, out var binding))
+            {
+                column = binding.FkColumn;
+            }
+            else if (rootColumnsByPath.TryGetValue(identityPath.Canonical, out var columnName))
+            {
+                column = columnName;
+            }
+            else
+            {
+                throw new InvalidOperationException(
+                    $"Identity path '{identityPath.Canonical}' on resource '{FormatResource(resource)}' "
+                        + "did not map to a root table column during identity element mapping."
+                );
+            }
+
+            if (seenColumns.Add(column.Value))
+            {
+                mappings.Add(new IdentityElementMapping(column, identityPath.Canonical));
+            }
+        }
+
+        return mappings.ToArray();
+    }
+
+    /// <summary>
+    /// Builds column mappings from concrete root table columns to abstract identity table columns
+    /// for <see cref="TriggerKindParameters.AbstractIdentityMaintenance"/> triggers.
+    /// </summary>
+    private static IReadOnlyList<TriggerColumnMapping> BuildAbstractIdentityColumnMappings(
+        DbTableModel abstractTable,
+        RelationalResourceModel resourceModel,
+        RelationalModelBuilderContext builderContext,
+        QualifiedResourceName resource,
+        string? superclassIdentityJsonPath
+    )
+    {
+        var rootTable = resourceModel.Root;
+        var rootColumnsByPath = BuildColumnNameLookupBySourceJsonPath(rootTable, resource);
+        var referenceBindingsByIdentityPath = BuildReferenceIdentityBindings(
+            resourceModel.DocumentReferenceBindings,
+            resource
+        );
+
+        List<TriggerColumnMapping> mappings = [];
+
+        // Iterate over abstract identity table columns that have a source JSON path
+        // (these are the identity columns, excluding DocumentId and Discriminator).
+        foreach (var abstractColumn in abstractTable.Columns)
+        {
+            if (abstractColumn.SourceJsonPath is null)
+            {
+                continue;
+            }
+
+            var abstractPath = abstractColumn.SourceJsonPath.Value.Canonical;
+
+            // Determine which concrete identity path maps to this abstract path.
+            string concretePath;
+            if (
+                superclassIdentityJsonPath is not null
+                && string.Equals(abstractPath, superclassIdentityJsonPath, StringComparison.Ordinal)
+            )
+            {
+                // When superclassIdentityJsonPath is set, the first concrete identity path
+                // maps to the superclass identity path.
+                concretePath = builderContext.IdentityJsonPaths[0].Canonical;
+            }
+            else
+            {
+                // Normal case: the concrete path is the same as the abstract path.
+                concretePath = abstractPath;
+            }
+
+            // Resolve the concrete source column.
+            DbColumnName sourceColumn;
+            if (referenceBindingsByIdentityPath.TryGetValue(concretePath, out var binding))
+            {
+                sourceColumn = binding.FkColumn;
+            }
+            else if (rootColumnsByPath.TryGetValue(concretePath, out var columnName))
+            {
+                sourceColumn = columnName;
+            }
+            else
+            {
+                throw new InvalidOperationException(
+                    $"Abstract identity path '{abstractPath}' (concrete path '{concretePath}') "
+                        + $"on resource '{FormatResource(resource)}' did not map to a root table column "
+                        + "during abstract identity column mapping."
+                );
+            }
+
+            mappings.Add(new TriggerColumnMapping(sourceColumn, abstractColumn.ColumnName));
+        }
+
+        return mappings.ToArray();
+    }
+
     /// <summary>
     /// Builds a lookup from qualified resource name to its concrete schema context (excluding extensions).
     /// </summary>
