2026-02-13
- Completed: tasks.json#0 Algorithm subsection under "Integration Point + Pass Ordering" (DMS-1033)
- Decisions: single ordered list; explicitly lists fail-fast + pass mutations (Columns/Constraints/KeyUnificationClasses/eq-constraint diagnostics); inlines canonical+presence naming + hash formulas; explicit non-goals (no FK rewrite; FK derivation later in ReferenceConstraintPass)
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Notes: follow-up tasks likely: #4 FK responsibility/allowIdentityUpdates/ON DELETE wording; #3 make ref-membership detection rule normative for presence gating (SourceJsonPath lookup vs current "identity binding" wording)
- Completed: tasks.json#3 Presence Gating (design doc)
- Decisions: presence gating uses authoritative lookup (member SourceJsonPath == DocumentReferenceBinding.IdentityBindings[*].ReferenceJsonPath); gate by binding FkColumn when found; non-reference optional uses synthetic ..._Present; non-reference required is ungated; fail fast on ambiguous multiple bindings; avoid name parsing heuristics
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#2 Schema Exceptions (DMS-1033)
- Decisions: ApiSchema `equalityConstraints` authoritative; legacy ODS physical-schema differences are non-authoritative; no v1 suppression/override; canonical always new column + members become `UnifiedAlias` (presence-gated when optional)
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Notes: if an equality constraint appears incorrect, fix upstream (ApiSchema generation / effective schema inputs); diagnostics remain `applied`/`redundant`/`ignored`
- Completed: tasks.json#9 Defaults (design doc)
- Decisions: ColumnStorage init default = `Stored` for all pre-existing columns; KeyUnificationPass only pass that sets `UnifiedAlias`; canonical + synthetic presence columns always `Stored`; old artifacts missing storage metadata rejected via `RelationalMappingVersion` mismatch (back-compat only via explicit older-version mode)
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#4 Foreign Keys (DMS-1033)
- Decisions: KeyUnificationPass mutates columns/classes only (no FK emission); ReferenceConstraintPass emits composite ref FKs by mapping binding→storage via `DbColumnModel.Storage`; referential actions unchanged (ON UPDATE allowIdentityUpdates-gated + existing SQL Server fallback; ON DELETE NO ACTION)
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#1 Dialect Hashing (DMS-1033)
- Decisions: NullOrTrue constraint signature = (kind="NullOrTrue", table=(schema,name), column=PresenceColumnName); explicitly participates in ApplyConstraintDialectHashingPass + ApplyDialectIdentifierShorteningPass; shortening updates Name + Column references
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#7 Ordering (DMS-1033)
- Decisions: KeyUnificationPass not required to establish final `DbTableModel.Columns` order; CanonicalizeOrderingPass (or later reorder) must restore alias dependency invariant using `DbColumnModel.Storage` (CanonicalColumn/PresenceColumn before alias); restate recommended per-table ordering (key, support cols, remaining)
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Notes: implementation note: current canonical ordering needs to account for alias dependencies (avoid name-sort breaking canonical-before-alias)
- Completed: tasks.json#5 Diagnostics (design doc)
- Decisions: emit deterministic `descriptor_fk_deduplications[]` per-table manifest entries when descriptor FK constraints are de-duplicated (storage_column + binding_columns + final constraint_name); deterministic ordering; explicitly separate from equality-constraint applied/redundant/ignored report
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#8 Constraints (design doc)
- Decisions: All-or-none CHECK constraints reference per-site binding columns even when they are persisted/stored `UnifiedAlias` computed/generated cols; valid in SQL Server + PostgreSQL; no workaround
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#2 Examples (design doc) (DMS-1033)
- Decisions: worked example for optional non-reference scalar unification w/ synthetic `..._Present` flags; shows canonical stored col + two presence gates + two unified aliases; includes SQL Server + PostgreSQL DDL; enumerates coalescing scenarios + “absent path stays absent” semantics
- Files: reference/design/backend-redesign/design-docs/key-unification.md; tasks.json; progress.txt
- Completed: tasks.json#15 Docs: Flattening + Reconstitution (DMS-1033)
- Decisions: add `DbColumnModel.Storage` + `DbTableModel.KeyUnificationClasses`; add `WriteValueSource.Precomputed` + `KeyUnificationWritePlan`; plan compiler excludes `UnifiedAlias` from writes; flattener two-phase materialization w/ deterministic coalescing + conflict detection + synthetic presence flags (absent=NULL, present=TRUE)
- Files: reference/design/backend-redesign/design-docs/flattening-reconstitution.md; tasks.json; progress.txt
- Completed: tasks.json#17 Docs: Mapping Pack Format (DMS-1033)
- Decisions: add `DbColumnModel.storage` (Stored vs UnifiedAlias canonical+presence); add `DbTableModel.key_unification_classes`; add `WriteValueSource.Precomputed` + `TableWritePlan.key_unification_plans`; determinism rules for new repeated fields; key-unification gating via `RelationalMappingVersion` (reject older packs missing metadata unless explicitly in older mode)
- Files: reference/design/backend-redesign/design-docs/mpack-format-v1.md; tasks.json; progress.txt
- Notes: proto uses `optional uint32 presence_binding_index`; ensure contracts generator/protoc version supports proto3 optional
- Completed: tasks.json#12 Docs: Data Model (DMS-1033)
- Decisions: bind vs store clarified; NK uniques are API/binding-path columns; RefKey uniques + composite ref FKs use storage columns (canonical via `DbColumnModel.Storage`); all-or-none CHECK remains over per-site binding/alias cols; name docs now mention `_Unified` canonical + `_Present` synthetic flags (delegated to key-unification.md); examples updated to show NK vs RefKey + composite FKs
- Files: reference/design/backend-redesign/design-docs/data-model.md; tasks.json; progress.txt
- Completed: tasks.json#13 Docs: DDL Generation (DMS-1033)
- Decisions: replace outdated key unification note; canonical stored cols + persisted/stored generated aliases; presence gating uses `..._DocumentId` or synthetic `..._Present`; composite ref FKs + descriptor FKs anchored on storage cols via `DbColumnModel.Storage`; descriptor FK de-dup by (table, storage col); no DB CHECK colA=colB for writable cols; cross-ref key-unification.md for dialect DDL
- Files: reference/design/backend-redesign/design-docs/ddl-generation.md; tasks.json; progress.txt
- Completed: tasks.json#14 Docs: Transactions + Concurrency (DMS-1033)
- Decisions: binding/path vs canonical/storage explicitly called out; cascades + SQL Server trigger-based fallback update canonical/storage cols (never aliases); writers set canonical cols + synthetic presence flags deterministically (no keep previous)
- Files: reference/design/backend-redesign/design-docs/transactions-and-concurrency.md; tasks.json; progress.txt
- Notes: remaining doc tasks: #10 #11 #16 #18 #19
