# DMS-939: Emit Seed + Fingerprint Recording SQL (Insert-if-Missing + Validate)

## Jira Summary

**Ticket:** DMS-939
**Status:** In Progress
**Epic:** DMS-935 (DDL Emission 02)
**Branch:** `DMS-939`
**Blocked by:** DMS-936 (Done), DMS-925 (Done), DMS-926 (Done), DMS-937 (Done)
**Blocks:** DMS-940, DMS-950

## Objective

Emit deterministic seed/recording DML as Phase 7 of the provisioning script:

1. `dms.ResourceKey` seed inserts with explicit `ResourceKeyId` values
2. `dms.EffectiveSchema` singleton insert-if-missing with preflight hash mismatch check
3. `dms.SchemaComponent` inserts for the current `EffectiveSchemaHash`
4. Inline SQL validation that fails fast on mismatches (no migrations)

## Acceptance Criteria (from Jira)

- Generated SQL uses insert-if-missing semantics (no truncate) and validates:
  - `dms.ResourceKey` contents match expected exactly
  - `dms.SchemaComponent` contents match expected exactly
- Provisioning fails fast if `dms.EffectiveSchema` exists with a different `EffectiveSchemaHash`
- Re-running the same provisioning script completes successfully and does not change recorded fingerprints
- Negative tests exist for: mismatched `EffectiveSchemaHash`, tampered `dms.ResourceKey` contents

---

## Design Reference

**Source:** `reference/design/backend-redesign/design-docs/ddl-generation.md` (lines 189-313)

### Phase Ordering

Per the design doc, seed data is **Phase 8** in the full pipeline. The current
`CoreDdlEmitter` implements Phases 1-6 (schemas, sequences, tables, FKs, indexes,
triggers) and skips views (Phase 6 in the doc) since there are no core views.
We will add seed data as **Phase 7** in `CoreDdlEmitter`'s local numbering via a
new `Emit(EffectiveSchemaInfo)` overload.

### Seed Data Ordering (design doc lines 353-355)

- `dms.ResourceKey` inserts ordered by `ResourceKeyId` ascending
- `dms.SchemaComponent` rows ordered by `ProjectEndpointName` ordinal

### Insert-if-Missing Semantics per Dialect

| Concept | PostgreSQL | SQL Server |
|---------|-----------|------------|
| Insert-if-missing | `INSERT ... ON CONFLICT (...) DO NOTHING` | `IF NOT EXISTS (SELECT ...) INSERT ...` |
| Fail-fast error | `RAISE EXCEPTION '...'` inside `DO $$ ... END $$` | `THROW 50000, '...', 1` |
| Binary literal | `'\xHEX...'::bytea` | `0xHEX...` |
| Boolean literal | `true` / `false` | `1` / `0` |
| String literal | `'text'` | `N'text'` |

---

## Implementation Plan

### Phase 1: Add Dialect Helper Methods to `ISqlDialect`

**File:** `Backend.Ddl/ISqlDialect.cs`

Add the following methods to the interface:

```csharp
/// Renders a binary byte[] as a SQL literal (PG: '\xHEX'::bytea, MSSQL: 0xHEX).
string RenderBinaryLiteral(byte[] value);

/// Renders a boolean value as a SQL literal (PG: true/false, MSSQL: 1/0).
string RenderBooleanLiteral(bool value);

/// Renders a string as a safely-escaped SQL literal (PG: 'text', MSSQL: N'text').
string RenderStringLiteral(string value);

/// Renders a smallint as a SQL literal.
string RenderSmallintLiteral(short value);

/// Renders an integer as a SQL literal.
string RenderIntegerLiteral(int value);
```

**Files to update:**
- `Backend.Ddl/SqlDialectBase.cs` - implement common methods (smallint, integer)
- `Backend.Ddl/PgsqlDialect.cs` - implement `RenderBinaryLiteral`, `RenderBooleanLiteral`, `RenderStringLiteral`
- `Backend.Ddl/MssqlDialect.cs` - implement same three methods with SQL Server semantics

### Phase 2: Add `Emit(EffectiveSchemaInfo)` Overload to `CoreDdlEmitter`

**File:** `Backend.Ddl/CoreDdlEmitter.cs`

Instead of creating a separate class, add an overload to `CoreDdlEmitter`:

```csharp
// Existing — emits Phases 1-6 (static DDL only, no seed data)
public string Emit() { ... }

// New — emits Phases 1-7 (DDL + seed DML)
public string Emit(EffectiveSchemaInfo effectiveSchema) { ... }
```

**Why an overload instead of a separate class:**
- **Zero duplication** — table name statics (`_resourceKeyTable`, `_effectiveSchemaTable`,
  `_schemaComponentTable`, etc.), helpers (`Col()`, `StringType()`, `BooleanType`),
  `SqlWriter` + `ISqlDialect` wiring, and phase banner pattern are all shared
- **Single class owns all `dms.*` emission** — both structure and data
- **Existing tests untouched** — they call the parameterless `Emit()`
- The new overload internally calls the same 6 phase methods, then appends Phase 7

**Internal structure of Phase 7 (new private methods, in emission order):**

#### 2a. `EmitSeedData(SqlWriter, EffectiveSchemaInfo)` — orchestrator

Writes the Phase 7 banner comment and delegates to sub-methods in order:

1. `EmitEffectiveSchemaHashPreflight` — fail-fast mismatch check
2. `EmitResourceKeySeeds` — insert-if-missing for each resource key
3. `EmitResourceKeyValidation` — count + content exact-match validation
4. `EmitEffectiveSchemaInsert` — singleton insert-if-missing
5. `EmitSchemaComponentSeeds` — insert-if-missing for each component
6. `EmitSchemaComponentValidation` — count + content exact-match validation

#### 2b. Preflight: EffectiveSchemaHash Mismatch Check

Before any inserts, emit a fail-fast check:

**PostgreSQL:**
```sql
DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM "dms"."EffectiveSchema"
        WHERE "EffectiveSchemaSingletonId" = 1
          AND "EffectiveSchemaHash" <> 'expected_hash'
    ) THEN
        RAISE EXCEPTION 'EffectiveSchemaHash mismatch: database is provisioned for a different schema hash (expected: expected_hash)';
    END IF;
END $$;
```

**SQL Server:**
```sql
IF EXISTS (
    SELECT 1 FROM [dms].[EffectiveSchema]
    WHERE [EffectiveSchemaSingletonId] = 1
      AND [EffectiveSchemaHash] <> N'expected_hash'
)
    THROW 50000, N'EffectiveSchemaHash mismatch: database is provisioned for a different schema hash', 1;
```

#### 2c. ResourceKey Seed Inserts (Insert-if-Missing)

For each `ResourceKeyEntry` in `effectiveSchema.ResourceKeysInIdOrder`:

**PostgreSQL:**
```sql
INSERT INTO "dms"."ResourceKey" ("ResourceKeyId", "ProjectName", "ResourceName", "ResourceVersion")
VALUES (1, 'Ed-Fi', 'Student', '5.1.0')
ON CONFLICT ("ResourceKeyId") DO NOTHING;
```

**SQL Server:**
```sql
IF NOT EXISTS (SELECT 1 FROM [dms].[ResourceKey] WHERE [ResourceKeyId] = 1)
    INSERT INTO [dms].[ResourceKey] ([ResourceKeyId], [ProjectName], [ResourceName], [ResourceVersion])
    VALUES (1, N'Ed-Fi', N'Student', N'5.1.0');
```

#### 2d. ResourceKey Full-Table Validation

After inserts, validate exact match (row count + content):

**PostgreSQL approach:**
```sql
DO $$
DECLARE
    _actual_count integer;
    _mismatched_count integer;
BEGIN
    SELECT COUNT(*) INTO _actual_count FROM "dms"."ResourceKey";
    IF _actual_count <> <expected_count> THEN
        RAISE EXCEPTION 'dms.ResourceKey count mismatch: expected %, found %', <expected>, _actual_count;
    END IF;

    SELECT COUNT(*) INTO _mismatched_count
    FROM "dms"."ResourceKey" rk
    WHERE NOT EXISTS (
        SELECT 1 FROM (VALUES
            (1::smallint, 'Ed-Fi', 'Student', '5.1.0'),
            (2::smallint, 'Ed-Fi', 'School', '5.1.0')
        ) AS expected("ResourceKeyId", "ProjectName", "ResourceName", "ResourceVersion")
        WHERE expected."ResourceKeyId" = rk."ResourceKeyId"
          AND expected."ProjectName" = rk."ProjectName"
          AND expected."ResourceName" = rk."ResourceName"
          AND expected."ResourceVersion" = rk."ResourceVersion"
    );
    IF _mismatched_count > 0 THEN
        RAISE EXCEPTION 'dms.ResourceKey contents mismatch: % unexpected or modified rows', _mismatched_count;
    END IF;
END $$;
```

**SQL Server approach:** Same logic using `DECLARE`, `SET`, `IF ... THROW`.

#### 2e. EffectiveSchema Insert-if-Missing

**PostgreSQL:**
```sql
INSERT INTO "dms"."EffectiveSchema" (
    "EffectiveSchemaSingletonId", "ApiSchemaFormatVersion",
    "EffectiveSchemaHash", "ResourceKeyCount", "ResourceKeySeedHash"
)
VALUES (1, 'format_ver', 'hash_hex', 42, '\xABCD...'::bytea)
ON CONFLICT ("EffectiveSchemaSingletonId") DO NOTHING;
```

**SQL Server:**
```sql
IF NOT EXISTS (SELECT 1 FROM [dms].[EffectiveSchema] WHERE [EffectiveSchemaSingletonId] = 1)
    INSERT INTO [dms].[EffectiveSchema] (...)
    VALUES (1, N'format_ver', N'hash_hex', 42, 0xABCD...);
```

#### 2f. SchemaComponent Inserts (Insert-if-Missing)

For each `SchemaComponentInfo` in `effectiveSchema.SchemaComponentsInEndpointOrder`:

**PostgreSQL:**
```sql
INSERT INTO "dms"."SchemaComponent" (
    "EffectiveSchemaHash", "ProjectEndpointName", "ProjectName",
    "ProjectVersion", "IsExtensionProject"
)
VALUES ('hash_hex', 'ed-fi', 'Ed-Fi', '5.1.0', false)
ON CONFLICT ("EffectiveSchemaHash", "ProjectEndpointName") DO NOTHING;
```

**SQL Server:** `IF NOT EXISTS` pattern.

#### 2g. SchemaComponent Exact-Match Validation

Similar to ResourceKey validation: count + content match for rows keyed by the
current `EffectiveSchemaHash`.

### Phase 3: Unit Tests

**New file:** `Backend.Ddl.Tests.Unit/SeedDmlEmitterTests.cs`

> Note: Even though the code lives in `CoreDdlEmitter`, the test file is named
> `SeedDmlEmitterTests.cs` to keep seed-data tests separate from the existing
> `CoreDdlEmitterTests.cs` (which tests Phases 1-6). This avoids bloating the
> existing test file and makes it clear what DMS-939 added.

#### Test Fixtures & Data

Create a helper method/builder that constructs a representative `EffectiveSchemaInfo` with:
- 2-3 resource keys (e.g., `Ed-Fi/Student`, `Ed-Fi/School`, `Ed-Fi/AcademicWeek`)
- 2 schema components (e.g., `ed-fi` core + `tpdm` extension)
- Known `EffectiveSchemaHash`, `ResourceKeySeedHash`, etc.

#### Test Classes (NUnit, `Given_` prefix, `It_` prefix)

**1. Determinism tests (both dialects):**
- `Given_CoreDdlEmitter_With_PgsqlDialect_And_SeedData_Emitting_Twice`
  - `It_should_produce_byte_for_byte_identical_output`
  - `It_should_produce_non_empty_output`
- `Given_CoreDdlEmitter_With_MssqlDialect_And_SeedData_Emitting_Twice`
  - Same tests

**2. PostgreSQL snapshot tests:**
- `Given_CoreDdlEmitter_With_PgsqlDialect_And_SeedData`
  - `It_should_emit_phase_7_header` (seed data phase comment)
  - `It_should_emit_phases_1_through_6_before_seed_data`
  - `It_should_emit_effective_schema_hash_preflight_check`
  - `It_should_emit_resource_key_inserts_with_on_conflict_do_nothing`
  - `It_should_emit_resource_key_inserts_in_id_order`
  - `It_should_emit_resource_key_validation_block`
  - `It_should_emit_effective_schema_insert_with_on_conflict`
  - `It_should_emit_schema_component_inserts_in_endpoint_order`
  - `It_should_emit_schema_component_validation_block`
  - `It_should_use_bytea_literal_for_seed_hash`
  - `It_should_use_boolean_literals_for_is_extension`
  - `It_should_use_raise_exception_for_errors`
  - `It_should_use_unix_line_endings`
  - `It_should_not_have_trailing_whitespace`
  - `It_should_not_contain_mssql_syntax` (no THROW, no N'...', no 0x...)

**3. SQL Server snapshot tests:**
- `Given_CoreDdlEmitter_With_MssqlDialect_And_SeedData`
  - `It_should_emit_phase_7_header`
  - `It_should_emit_phases_1_through_6_before_seed_data`
  - `It_should_emit_effective_schema_hash_preflight_check`
  - `It_should_emit_resource_key_inserts_with_if_not_exists`
  - `It_should_emit_resource_key_inserts_in_id_order`
  - `It_should_emit_resource_key_validation_block`
  - `It_should_emit_effective_schema_insert_with_if_not_exists`
  - `It_should_emit_schema_component_inserts_in_endpoint_order`
  - `It_should_emit_schema_component_validation_block`
  - `It_should_use_binary_hex_literal_for_seed_hash`
  - `It_should_use_bit_literals_for_is_extension`
  - `It_should_use_throw_for_errors`
  - `It_should_use_nvarchar_string_literals`
  - `It_should_use_unix_line_endings`
  - `It_should_not_have_trailing_whitespace`
  - `It_should_not_contain_pgsql_syntax`

**4. Validation logic tests (both dialects):**
- `Given_CoreDdlEmitter_With_PgsqlDialect_And_ResourceKeys`
  - `It_should_validate_resource_key_count`
  - `It_should_validate_resource_key_contents`
- `Given_CoreDdlEmitter_With_MssqlDialect_And_ResourceKeys`
  - Same tests

**5. Edge cases:**
- `Given_CoreDdlEmitter_With_Empty_ResourceKeys`
  - Verify emitter handles zero resource keys gracefully
- `Given_CoreDdlEmitter_With_Single_SchemaComponent`
  - Verify single-component scenario

### Phase 4: Add Dialect-Specific Tests for New Literal Methods

**Files:** `Backend.Ddl.Tests.Unit/PgsqlDialectTests.cs`, `MssqlDialectTests.cs`

Add tests for the new `RenderBinaryLiteral`, `RenderBooleanLiteral`, `RenderStringLiteral` methods.

### Phase 5: Format and Verify

- Run `dotnet csharpier format` on all changed `.cs` files
- Run `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`
- Run `dotnet test src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit --no-build`

---

## Files to Modify

| File | Changes |
|------|---------|
| `Backend.Ddl/ISqlDialect.cs` | Add `RenderBinaryLiteral`, `RenderBooleanLiteral`, `RenderStringLiteral`, `RenderSmallintLiteral`, `RenderIntegerLiteral` |
| `Backend.Ddl/SqlDialectBase.cs` | Implement common literal methods |
| `Backend.Ddl/PgsqlDialect.cs` | Implement PG-specific literal rendering |
| `Backend.Ddl/MssqlDialect.cs` | Implement MSSQL-specific literal rendering |
| `Backend.Ddl/CoreDdlEmitter.cs` | Add `Emit(EffectiveSchemaInfo)` overload + Phase 7 private methods |

## Files to Create

| File | Purpose |
|------|---------|
| `Backend.Ddl.Tests.Unit/SeedDmlEmitterTests.cs` | Comprehensive seed DML tests (separate file, tests the `CoreDdlEmitter` overload) |

## Files Unchanged

| File | Why |
|------|-----|
| `Backend.Ddl.Tests.Unit/CoreDdlEmitterTests.cs` | Existing tests call parameterless `Emit()` — no changes needed |

## Key Design Decisions

1. **`Emit(EffectiveSchemaInfo)` overload on `CoreDdlEmitter`** instead of a separate class:
   - Eliminates duplication of table name statics, helpers, writer setup, and dialect wiring
   - Single class owns all `dms.*` emission (both DDL structure and DML seed data)
   - Existing parameterless `Emit()` and its tests remain untouched
   - The overload calls the same 6 phase methods, then appends Phase 7

2. **Dialect branching in the emitter** for structural SQL differences (insert-if-missing
   pattern, DO blocks vs IF blocks) — consistent with existing patterns in `CoreDdlEmitter`
   (triggers, CHECK constraints).

3. **New literal-rendering methods on `ISqlDialect`** for value-level differences (binary,
   boolean, string) — these are reusable and testable in isolation.

4. **Validation embedded in the generated SQL** — the emitted script itself contains
   THROW/RAISE EXCEPTION blocks that cause provisioning to fail at execution time if data
   doesn't match expectations.

## Data Flow

```
EffectiveSchemaInfo
  ├── .EffectiveSchemaHash          → preflight check + EffectiveSchema insert + SchemaComponent FK
  ├── .ApiSchemaFormatVersion       → EffectiveSchema insert
  ├── .ResourceKeyCount             → EffectiveSchema insert + ResourceKey count validation
  ├── .ResourceKeySeedHash (byte[]) → EffectiveSchema insert (binary literal)
  ├── .ResourceKeysInIdOrder[]      → ResourceKey inserts + content validation
  │     ├── .ResourceKeyId (short)
  │     ├── .Resource.ProjectName
  │     ├── .Resource.ResourceName
  │     └── .ResourceVersion
  └── .SchemaComponentsInEndpointOrder[] → SchemaComponent inserts + content validation
        ├── .ProjectEndpointName
        ├── .ProjectName
        ├── .ProjectVersion
        └── .IsExtensionProject (bool)
```
