# DMS-937: Emit Core `dms.*` DDL (Including Update-Tracking Triggers)

## Execution Plan

**Jira:** [DMS-937](https://edfi.atlassian.net/browse/DMS-937)
**Epic:** DMS-935 DDL Emission (02)
**Depends on:** DMS-936 (SQL Dialect Abstraction + Writer) - DONE
**Blocks:** DMS-940, DMS-943, DMS-939, DMS-950, DMS-975, DMS-982, DMS-992, DMS-996, DMS-1002, DMS-1003, DMS-1010
**Branch:** `DMS-937`

---

## Progress Tracker

| Phase | Description | Status |
|---|---|---|
| **Phase 1** | ISqlDialect extensions + CoreDdlEmitter skeleton | DONE |
| **Phase 2** | Implement each DDL object (tables, FKs, indexes, triggers) | DONE |
| **Phase 3** | Deterministic ordering verification | DONE |
| **Phase 4** | Snapshot tests (both dialects) | DONE |

---

## Phase 1: COMPLETED

### What was done

#### 1. ISqlDialect Extensions (4 files modified)

**Files changed:**
- `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/ISqlDialect.cs`
- `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/SqlDialectBase.cs`
- `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/PgsqlDialect.cs`
- `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/MssqlDialect.cs`

**New type properties added to ISqlDialect:**

| Property | PostgreSQL | SQL Server |
|---|---|---|
| `SmallintColumnType` | `smallint` | `smallint` |
| `UuidColumnType` | `uuid` | `uniqueidentifier` |
| `JsonColumnType` | `jsonb` | `nvarchar(max)` |
| `IdentityBigintColumnType` | `bigint GENERATED ALWAYS AS IDENTITY` | `bigint IDENTITY(1,1)` |
| `CurrentTimestampDefaultExpression` | `now()` | `(sysutcdatetime())` |

**New methods added to ISqlDialect:**

| Method | PostgreSQL | SQL Server |
|---|---|---|
| `RenderBinaryColumnType(n)` | `bytea` (ignores length) | `binary(n)` |
| `RenderSequenceDefaultExpression(schema, name)` | `nextval('"dms"."ChangeVersionSequence"')` | `(NEXT VALUE FOR [dms].[ChangeVersionSequence])` |
| `RenderColumnDefinitionWithNamedDefault(...)` | Delegates to `RenderColumnDefinition` (PG ignores constraint names) | Emits `CONSTRAINT [name] DEFAULT (expr)` |
| `RenderNamedPrimaryKeyClause(name, cols, clustered)` | `CONSTRAINT "PK_X" PRIMARY KEY (...)` (ignores clustered) | `CONSTRAINT [PK_X] PRIMARY KEY CLUSTERED (...)` |

#### 2. CoreDdlEmitter Skeleton (1 new file)

**New file:** `src/dms/backend/EdFi.DataManagementService.Backend.Ddl/CoreDdlEmitter.cs`

- Primary constructor: `CoreDdlEmitter(ISqlDialect dialect)`
- Public method: `string Emit()` - generates the full core DDL script
- Phased emission structure with TODO stubs:
  - `EmitSchemas(writer)` - emits `CREATE SCHEMA dms` (implemented)
  - `EmitSequences(writer)` - emits `dms.ChangeVersionSequence` (implemented)
  - `EmitTables(writer)` - 8 stub methods in alphabetical order (TODO)
  - `EmitForeignKeys(writer)` - stub (TODO)
  - `EmitIndexes(writer)` - stub (TODO)
  - `EmitTriggers(writer)` - stub (TODO)

#### 3. Verification

- Build: **0 errors** (`dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln`)
- Tests: **146/146 passed** (`dotnet test Backend.Ddl.Tests.Unit --no-build`)
- CSharpier: formatted all 5 changed files

---

## Phase 2: Implement Each DDL Object (NEXT)

### Resumption Guide

To continue from Phase 1, start implementing the TODO stubs in `CoreDdlEmitter.cs`.
The recommended order within Phase 2 is:

| Step | What | Method to implement | Details |
|---|---|---|---|
| **2.1** | Schema + Sequence | `EmitSchemas`, `EmitChangeVersionSequence` | Already done in skeleton |
| **2.2** | `dms.ResourceKey` table | `EmitResourceKeyTable` | Simplest table - good warm-up |
| **2.3** | `dms.Document` table | `EmitDocumentTable` | Most complex - identity columns, sequence defaults, timestamp defaults, named constraints (MSSQL) |
| **2.4** | `dms.ReferentialIdentity` table | `EmitReferentialIdentityTable` | PK NONCLUSTERED (MSSQL), UNIQUE CLUSTERED (MSSQL) |
| **2.5** | `dms.Descriptor` table | `EmitDescriptorTable` | String columns + UNIQUE on (Uri, Discriminator) |
| **2.6** | `dms.EffectiveSchema` table | `EmitEffectiveSchemaTable` | Singleton CHECK, bytea/binary type, PG-only CHECK |
| **2.7** | `dms.SchemaComponent` table | `EmitSchemaComponentTable` | Composite PK, boolean/bit type |
| **2.8** | `dms.DocumentChangeEvent` table | `EmitDocumentChangeEventTable` | Composite PK, timestamp default |
| **2.9** | `dms.DocumentCache` table | `EmitDocumentCacheTable` | JSON type, dialect-specific CHECK constraints |
| **2.10** | All foreign keys | `EmitForeignKeys` | ~8 FK constraints via ALTER TABLE |
| **2.11** | All indexes | `EmitIndexes` | Explicit + FK-support indexes |
| **2.12** | PG journaling trigger | `EmitTriggers` (PG branch) | Trigger function + DROP/CREATE trigger |
| **2.13** | MSSQL journaling trigger | `EmitTriggers` (MSSQL branch) | CREATE OR ALTER TRIGGER |

### Key APIs to use (from Phase 1 extensions)

```csharp
// Creating a table
writer.AppendLine(dialect.CreateTableHeader(table));
writer.AppendLine("(");
using (writer.Indent())
{
    // Identity column (dms.Document)
    writer.AppendLine($"{dialect.RenderColumnDefinition(col, dialect.IdentityBigintColumnType, false)},");

    // Column with sequence default (MSSQL named constraint)
    writer.AppendLine($"{dialect.RenderColumnDefinitionWithNamedDefault(
        col, "bigint", false, "DF_Document_ContentVersion",
        dialect.RenderSequenceDefaultExpression(DmsSchema, "ChangeVersionSequence"))},");

    // Column with timestamp default (MSSQL named constraint)
    writer.AppendLine($"{dialect.RenderColumnDefinitionWithNamedDefault(
        col, dialect.Rules.ScalarTypeDefaults.DateTimeType, false,
        "DF_Document_CreatedAt", dialect.CurrentTimestampDefaultExpression)},");

    // Named PK (MSSQL CLUSTERED)
    writer.AppendLine(dialect.RenderNamedPrimaryKeyClause("PK_Document", [new("DocumentId")]));
}
writer.AppendLine(");");
```

### Table DDL Reference (per dialect)

All table schemas are fully specified in the plan sections below (unchanged from original).
Refer to:
- Section "2.3 Tables" for all column definitions and inline constraints
- Section "2.4 Foreign Keys" for the FK inventory
- Section "2.5 Indexes" for the index inventory
- Section "2.6 Triggers" for the journaling trigger SQL

---

## Phase 2 Detail: Table Specifications

### `dms.ResourceKey`

| Column | PG Type | MSSQL Type | Nullable | Default |
|---|---|---|---|---|
| `ResourceKeyId` | `smallint` | `smallint` | NOT NULL | - |
| `ProjectName` | `varchar(256)` | `nvarchar(256)` | NOT NULL | - |
| `ResourceName` | `varchar(256)` | `nvarchar(256)` | NOT NULL | - |
| `ResourceVersion` | `varchar(32)` | `nvarchar(32)` | NOT NULL | - |

- PK: `ResourceKeyId` (MSSQL: `CONSTRAINT PK_ResourceKey PRIMARY KEY CLUSTERED`)
- UNIQUE: `(ProjectName, ResourceName)` → `UX_ResourceKey_ProjectName_ResourceName`

### `dms.Document`

| Column | PG Type | MSSQL Type | Nullable | Default |
|---|---|---|---|---|
| `DocumentId` | `bigint GENERATED ALWAYS AS IDENTITY` | `bigint IDENTITY(1,1)` | NOT NULL | identity |
| `DocumentUuid` | `uuid` | `uniqueidentifier` | NOT NULL | - |
| `ResourceKeyId` | `smallint` | `smallint` | NOT NULL | - |
| `ContentVersion` | `bigint` | `bigint` | NOT NULL | sequence default |
| `IdentityVersion` | `bigint` | `bigint` | NOT NULL | sequence default |
| `ContentLastModifiedAt` | `timestamp with time zone` | `datetime2(7)` | NOT NULL | timestamp default |
| `IdentityLastModifiedAt` | `timestamp with time zone` | `datetime2(7)` | NOT NULL | timestamp default |
| `CreatedAt` | `timestamp with time zone` | `datetime2(7)` | NOT NULL | timestamp default |

- PK: `DocumentId` (MSSQL: `CONSTRAINT PK_Document PRIMARY KEY CLUSTERED`)
- UNIQUE: `DocumentUuid` → `UX_Document_DocumentUuid`
- MSSQL named defaults: `DF_Document_ContentVersion`, `DF_Document_IdentityVersion`, `DF_Document_ContentLastModifiedAt`, `DF_Document_IdentityLastModifiedAt`, `DF_Document_CreatedAt`

### `dms.ReferentialIdentity`

| Column | PG Type | MSSQL Type |
|---|---|---|
| `ReferentialId` | `uuid` | `uniqueidentifier` |
| `DocumentId` | `bigint` | `bigint` |
| `ResourceKeyId` | `smallint` | `smallint` |

- PG: PK on `ReferentialId`
- MSSQL: PK **NONCLUSTERED** on `ReferentialId`, UNIQUE **CLUSTERED** on `(DocumentId, ResourceKeyId)`

### `dms.Descriptor`

| Column | PG Type | MSSQL Type |
|---|---|---|
| `DocumentId` | `bigint` | `bigint` |
| `Namespace` | `varchar(255)` | `nvarchar(255)` |
| `CodeValue` | `varchar(50)` | `nvarchar(50)` |
| `ShortDescription` | `varchar(75)` | `nvarchar(75)` |
| `Description` | `varchar(1024)` | `nvarchar(1024)` |
| `Discriminator` | `varchar(128)` | `nvarchar(128)` |
| `Uri` | `varchar(306)` | `nvarchar(306)` |

- PK: `DocumentId` (MSSQL: `CONSTRAINT PK_Descriptor PRIMARY KEY CLUSTERED`)
- UNIQUE: `(Uri, Discriminator)` → `UX_Descriptor_Uri_Discriminator`
- `Description` is the only nullable column

### `dms.EffectiveSchema`

| Column | PG Type | MSSQL Type |
|---|---|---|
| `EffectiveSchemaSingletonId` | `smallint` | `smallint` |
| `ApiSchemaFormatVersion` | `varchar(64)` | `nvarchar(64)` |
| `EffectiveSchemaHash` | `varchar(64)` | `nvarchar(64)` |
| `ResourceKeyCount` | `smallint` | `smallint` |
| `ResourceKeySeedHash` | `bytea` | `binary(32)` |
| `AppliedAt` | `timestamp with time zone` | `datetime2(7)` |

- PK: `EffectiveSchemaSingletonId` (MSSQL: `CONSTRAINT PK_EffectiveSchema PRIMARY KEY CLUSTERED`)
- CHECK: `CK_EffectiveSchema_Singleton` → `EffectiveSchemaSingletonId = 1`
- CHECK (PG only): `CK_EffectiveSchema_ResourceKeySeedHash_Length` → `octet_length(ResourceKeySeedHash) = 32`
- UNIQUE: `EffectiveSchemaHash` → `UX_EffectiveSchema_EffectiveSchemaHash`
- MSSQL named default: `DF_EffectiveSchema_AppliedAt`

### `dms.SchemaComponent`

| Column | PG Type | MSSQL Type |
|---|---|---|
| `EffectiveSchemaHash` | `varchar(64)` | `nvarchar(64)` |
| `ProjectEndpointName` | `varchar(128)` | `nvarchar(128)` |
| `ProjectName` | `varchar(256)` | `nvarchar(256)` |
| `ProjectVersion` | `varchar(32)` | `nvarchar(32)` |
| `IsExtensionProject` | `boolean` | `bit` |

- PK: `(EffectiveSchemaHash, ProjectEndpointName)` (MSSQL: `CONSTRAINT PK_SchemaComponent PRIMARY KEY CLUSTERED`)

### `dms.DocumentChangeEvent`

| Column | PG Type | MSSQL Type |
|---|---|---|
| `ChangeVersion` | `bigint` | `bigint` |
| `DocumentId` | `bigint` | `bigint` |
| `ResourceKeyId` | `smallint` | `smallint` |
| `CreatedAt` | `timestamp with time zone` | `datetime2(7)` |

- PK: `(ChangeVersion, DocumentId)` (MSSQL: `CONSTRAINT PK_DocumentChangeEvent PRIMARY KEY CLUSTERED`)
- MSSQL named default: `DF_DocumentChangeEvent_CreatedAt`

### `dms.DocumentCache` (optional)

| Column | PG Type | MSSQL Type |
|---|---|---|
| `DocumentId` | `bigint` | `bigint` |
| `DocumentUuid` | `uuid` | `uniqueidentifier` |
| `ProjectName` | `varchar(256)` | `nvarchar(256)` |
| `ResourceName` | `varchar(256)` | `nvarchar(256)` |
| `ResourceVersion` | `varchar(32)` | `nvarchar(32)` |
| `Etag` | `varchar(64)` | `nvarchar(64)` |
| `LastModifiedAt` | `timestamp with time zone` | `datetime2(7)` |
| `DocumentJson` | `jsonb` | `nvarchar(max)` |
| `ComputedAt` | `timestamp with time zone` | `datetime2(7)` |

- PK: `DocumentId` (MSSQL: `CONSTRAINT PK_DocumentCache PRIMARY KEY CLUSTERED`)
- UNIQUE: `DocumentUuid` → `UX_DocumentCache_DocumentUuid`
- CHECK (PG): `CK_DocumentCache_JsonObject` → `jsonb_typeof(DocumentJson) = 'object'`
- CHECK (MSSQL): `CK_DocumentCache_IsJsonObject` → `ISJSON(DocumentJson) = 1 AND LEFT(LTRIM(DocumentJson), 1) = '{'`
- MSSQL named default: `DF_DocumentCache_ComputedAt`

---

## Phase 2 Detail: Foreign Keys

Emit in deterministic order (by table name, then constraint name):

| Constraint | Source | Target | ON DELETE | ON UPDATE |
|---|---|---|---|---|
| `FK_Descriptor_Document` | `dms.Descriptor(DocumentId)` | `dms.Document(DocumentId)` | CASCADE | NO ACTION |
| `FK_Document_ResourceKey` | `dms.Document(ResourceKeyId)` | `dms.ResourceKey(ResourceKeyId)` | NO ACTION | NO ACTION |
| `FK_DocumentCache_Document` | `dms.DocumentCache(DocumentId)` | `dms.Document(DocumentId)` | CASCADE | NO ACTION |
| `FK_DocumentChangeEvent_Document` | `dms.DocumentChangeEvent(DocumentId)` | `dms.Document(DocumentId)` | CASCADE | NO ACTION |
| `FK_DocumentChangeEvent_ResourceKey` | `dms.DocumentChangeEvent(ResourceKeyId)` | `dms.ResourceKey(ResourceKeyId)` | NO ACTION | NO ACTION |
| `FK_ReferentialIdentity_Document` | `dms.ReferentialIdentity(DocumentId)` | `dms.Document(DocumentId)` | CASCADE | NO ACTION |
| `FK_ReferentialIdentity_ResourceKey` | `dms.ReferentialIdentity(ResourceKeyId)` | `dms.ResourceKey(ResourceKeyId)` | NO ACTION | NO ACTION |
| `FK_SchemaComponent_EffectiveSchemaHash` | `dms.SchemaComponent(EffectiveSchemaHash)` | `dms.EffectiveSchema(EffectiveSchemaHash)` | CASCADE | NO ACTION |

---

## Phase 2 Detail: Indexes

Explicit indexes from design docs + FK-support indexes (deduplicated):

| Index | Table | Columns | Unique | Source |
|---|---|---|---|---|
| `IX_Descriptor_Uri_Discriminator` | `dms.Descriptor` | `(Uri, Discriminator)` | No | design doc |
| `IX_Document_ResourceKeyId_DocumentId` | `dms.Document` | `(ResourceKeyId, DocumentId)` | No | design doc (also covers FK on ResourceKeyId) |
| `IX_DocumentCache_ProjectName_ResourceName_LastModifiedAt` | `dms.DocumentCache` | `(ProjectName, ResourceName, LastModifiedAt, DocumentId)` | No | design doc |
| `IX_DocumentChangeEvent_DocumentId` | `dms.DocumentChangeEvent` | `(DocumentId)` | No | FK-support |
| `IX_DocumentChangeEvent_ResourceKeyId_ChangeVersion` | `dms.DocumentChangeEvent` | `(ResourceKeyId, ChangeVersion, DocumentId)` | No | design doc (also covers FK on ResourceKeyId) |
| `IX_ReferentialIdentity_DocumentId` | `dms.ReferentialIdentity` | `(DocumentId)` | No | design doc |

---

## Phase 2 Detail: Triggers (Journaling on `dms.Document`)

### PostgreSQL

```sql
CREATE OR REPLACE FUNCTION "dms"."TF_Document_Journal"()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO "dms"."DocumentChangeEvent" ("ChangeVersion", "DocumentId", "ResourceKeyId", "CreatedAt")
    SELECT d."ContentVersion", d."DocumentId", d."ResourceKeyId", now()
    FROM (
        SELECT DISTINCT ON ("DocumentId") "ContentVersion", "DocumentId", "ResourceKeyId"
        FROM new_table
    ) d;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS "TR_Document_Journal" ON "dms"."Document";
CREATE TRIGGER "TR_Document_Journal"
    AFTER INSERT OR UPDATE OF "ContentVersion" ON "dms"."Document"
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT
    EXECUTE FUNCTION "dms"."TF_Document_Journal"();
```

### SQL Server

```sql
CREATE OR ALTER TRIGGER [dms].[TR_Document_Journal]
ON [dms].[Document]
AFTER INSERT, UPDATE
AS
BEGIN
    SET NOCOUNT ON;
    IF UPDATE([ContentVersion]) OR NOT EXISTS (SELECT 1 FROM deleted)
    BEGIN
        INSERT INTO [dms].[DocumentChangeEvent] ([ChangeVersion], [DocumentId], [ResourceKeyId], [CreatedAt])
        SELECT i.[ContentVersion], i.[DocumentId], i.[ResourceKeyId], sysutcdatetime()
        FROM inserted i;
    END
END;
```

---

## Phase 3: Deterministic Ordering

Ordering is already embedded in the skeleton's method call order:

```
Phase 1: Schemas          → only `dms` (single schema)
Phase 2: Sequences        → only `ChangeVersionSequence`
Phase 3: Tables           → alphabetical: Descriptor, Document, DocumentCache, DocumentChangeEvent, EffectiveSchema, ReferentialIdentity, ResourceKey, SchemaComponent
Phase 4: Foreign keys     → alphabetical by (table, constraint name)
Phase 5: Indexes          → alphabetical by (table, index name)
Phase 6: Triggers         → alphabetical by (table, trigger name)
```

Verification: emit twice with same input, compare byte-for-byte.

---

## Phase 4: Snapshot Tests

**New test file:** `src/dms/backend/EdFi.DataManagementService.Backend.Ddl.Tests.Unit/CoreDdlEmitterTests.cs`

Test fixtures: `Given_CoreDdlEmitter_With_PgsqlDialect`, `Given_CoreDdlEmitter_With_MssqlDialect`

See original plan for test method listing.

---

## Out of Scope (Explicitly)

- **Seed data** (`dms.ResourceKey` inserts, `dms.EffectiveSchema` singleton, `dms.SchemaComponent`) - DMS-939
- **Per-resource-table stamping triggers** (content/identity version bumps) - DMS-1002
- **Per-resource tables** (project schemas, resource root/child tables, extensions) - DMS-938
- **Descriptor DDL details** beyond the `dms.Descriptor` table itself - DMS-943
- **Authorization objects** (`auth.*`, `dms.DocumentSubject`) - explicitly excluded
- **SQL canonicalization deterministic ordering tests** - DMS-940
- **CLI integration** (`dms-schema ddl emit`) - DMS-950

---

## Risks & Open Questions

| # | Item | Resolution |
|---|---|---|
| 1 | ~~ISqlDialect gaps for core-table types~~ | **RESOLVED in Phase 1** - added SmallintColumnType, UuidColumnType, JsonColumnType, IdentityBigintColumnType, RenderBinaryColumnType, RenderSequenceDefaultExpression, RenderColumnDefinitionWithNamedDefault, RenderNamedPrimaryKeyClause |
| 2 | ~~MSSQL CLUSTERED/NONCLUSTERED PK~~ | **RESOLVED in Phase 1** - `RenderNamedPrimaryKeyClause(name, cols, clustered)` |
| 3 | ~~PG GENERATED ALWAYS AS IDENTITY vs MSSQL IDENTITY(1,1)~~ | **RESOLVED in Phase 1** - `IdentityBigintColumnType` property |
| 4 | ~~Sequence default expression syntax~~ | **RESOLVED in Phase 1** - `RenderSequenceDefaultExpression(schema, name)` |
| 5 | `DocumentCache` is labeled "optional" - should it always be emitted? | **Recommend:** always emit. Design docs say "optional" but inventory includes it. |
| 6 | Trigger SQL is complex and dialect-specific | Snapshot tests for DDL text; DB-apply tests (DMS-940 / layer 4) will validate execution. |
| 7 | This story does NOT include seed data (DMS-939) or per-resource triggers (DMS-1002) | Only emit `dms.*` table structures and `dms.Document` journaling trigger. |

---

## Verification Checklist (Before PR)

- [ ] `dotnet build --no-restore ./src/dms/EdFi.DataManagementService.sln` passes
- [ ] `dotnet test` for `Backend.Ddl.Tests.Unit` passes
- [ ] `dotnet csharpier format` applied to all changed .cs files
- [ ] PG DDL snapshot matches expected output
- [ ] MSSQL DDL snapshot matches expected output
- [ ] All identifiers are quoted (PG double-quotes, MSSQL brackets)
- [ ] Output is deterministic (same input => byte-for-byte same output)
- [ ] No `auth.*` or authorization objects in output
- [ ] Phased ordering is correct (schemas -> sequences -> tables -> FKs -> indexes -> triggers)
- [ ] Journaling trigger SQL matches `update-tracking.md` semantics
- [ ] Code follows `.editorconfig` (LF line endings, spaces, no trailing whitespace)
- [ ] Code follows AGENTS.md style (file-scoped namespaces, modern C#, pattern matching)

---

## Key Design References

| Document | Path |
|---|---|
| Data Model | `reference/design/backend-redesign/design-docs/data-model.md` |
| Update Tracking | `reference/design/backend-redesign/design-docs/update-tracking.md` |
| DDL Generation | `reference/design/backend-redesign/design-docs/ddl-generation.md` |
| DDL Testing | `reference/design/backend-redesign/design-docs/ddl-generator-testing.md` |
| Epic Story | `reference/design/backend-redesign/epics/02-ddl-emission/01-core-dms-ddl.md` |
| AGENTS.md | `AGENTS.md` (project conventions) |
