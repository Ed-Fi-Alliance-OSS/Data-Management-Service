# Batch API Code Review (Round 3)

## Findings

1. **Resilience pipeline never sees backend result types**  
   - `BatchHandler.Execute` now wraps the whole batch in `_resiliencePipeline.ExecuteAsync`, but the delegate at `src/dms/core/EdFi.DataManagementService.Core/Handler/BatchHandler.cs:137-141` returns a literal `true`. The resilience pipeline configured in `DmsCoreServiceExtensions` looks for `UpsertResult/UpdateResult/DeleteResult` instances to decide when to retry or trip the breaker (`src/dms/core/EdFi.DataManagementService.Core/DmsCoreServiceExtensions.cs:188-199`). Because the batch delegate always returns `bool`, the retry/circuit-breaker logic never triggers and transient write conflicts (`UpsertFailureWriteConflict`, `UpdateFailureWriteConflict`, `DeleteFailureWriteConflict`) are no longer retried inside a batch. This regresses the concurrency protections that all `/data` endpoints rely on and allows hot paths to flake under normal load.  
   - **Fix:** run `_resiliencePipeline.ExecuteAsync` around each backend call (resolve, upsert, update, delete) so the pipeline observes the real result discriminated unions. Alternatively, change the batch delegate to return those result types and propagate failures so the existing policies can react.

2. **Bad `op`/`resource` types crash the parser instead of returning 400**  
   - `BatchRequestParser.ParseOperation` pulls `op` and `resource` with `operationNode["op"]?.GetValue<string>()` and `operationNode["resource"]?.GetValue<string>()` (`src/dms/core/EdFi.DataManagementService.Core/Batch/BatchRequestParser.cs:60-81`). If a caller passes a non-string (e.g., `{ "op": 123 }`), `GetValue<string>()` throws `InvalidOperationException`. That exception bypasses the `BatchRequestException` handling in `BatchHandler.Execute`, bubbles into `CoreExceptionLoggingMiddleware`, and the client receives a 500 instead of a validation error. This gives malformed payloads an easy way to trigger 500s and hides the root cause from the client.  
   - **Fix:** mirror the `ifMatch` handling just below: use `TryGetPropertyValue` + `TryGetValue(out string)` (or `JsonNode.GetValue<string>()` inside a `try`/`catch`) and convert failures into `BatchRequestException` so the response stays a deterministic 400 with a helpful message.

3. **Delete failures emit anonymous problems with no detail or correlation id**  
   - When a delete-by-key operation fails because the document is missing or a write conflict occurs, `InterpretDeleteResult` returns a `FrontendResponse` with `Body: null` (`src/dms/core/EdFi.DataManagementService.Core/Handler/BatchHandler.cs:843-874`). `BatchResponseBuilder.CreateFailureResponse` then calls `CloneOrCreateProblem`, which sees the null body and fabricates a generic object containing only `detail` and `status` (`src/dms/core/EdFi.DataManagementService.Core/Batch/BatchResponseBuilder.cs:89-111`). The resulting batch error lacks the `type`, `title`, `correlationId`, `validationErrors`, and resource-specific detail that the design in §3.4.2 promises (“failedOperation.problem is the exact problem-details JSON...”). Clients therefore cannot tell whether the delete failed because the resource didn’t exist, an ETag mismatched, or the record was locked.  
   - **Fix:** return the usual `FailureResponse.ForNotFound`, `ForDataConflict`, etc. from `InterpretDeleteResult` (as `UpdateResult` already does), or enrich the fallback path in `BatchResponseBuilder` with the proper problem-details envelope that includes the trace id and a useful message.
